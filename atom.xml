<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>windylee</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://windylee.cn/"/>
  <updated>2018-04-28T05:10:36.335Z</updated>
  <id>http://windylee.cn/</id>
  
  <author>
    <name>windylee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HAProxy从零开始到掌握</title>
    <link href="http://windylee.cn/posts/c28f24c2/"/>
    <id>http://windylee.cn/posts/c28f24c2/</id>
    <published>2018-04-28T04:33:13.000Z</published>
    <updated>2018-04-28T05:10:36.335Z</updated>
    
    <content type="html"><![CDATA[<h2 id="HAProxy是什么"><a href="#HAProxy是什么" class="headerlink" title="HAProxy是什么"></a>HAProxy是什么</h2><p>HAProxy是一个免费的负载均衡软件，可以运行于大部分主流的Linux操作系统上。</p><p>HAProxy提供了L4(TCP)和L7(HTTP)两种负载均衡能力，具备丰富的功能。HAProxy的社区非常活跃，版本更新快速。最关键的是，HAProxy具备媲美商用负载均衡器的性能和稳定性。</p><p>因为HAProxy的上述优点，它当前不仅仅是免费负载均衡软件的首选，更几乎成为了唯一选择。</p><h2 id="HAProxy的核心能力和关键特性"><a href="#HAProxy的核心能力和关键特性" class="headerlink" title="HAProxy的核心能力和关键特性"></a>HAProxy的核心能力和关键特性</h2><h3 id="HAProxy的核心功能"><a href="#HAProxy的核心功能" class="headerlink" title="HAProxy的核心功能"></a>HAProxy的核心功能</h3><ul><li>负载均衡：L4和L7两种模式，支持RR/静态RR/LC/IP Hash/URI Hash/URL_PARAM Hash/HTTP_HEADER Hash等丰富的负载均衡算法</li><li>健康检查：支持TCP和HTTP两种健康检查模式</li><li>会话保持：对于未实现会话共享的应用集群，可通过Insert Cookie/Rewrite Cookie/Prefix Cookie，以及上述的多种Hash方式实现会话保持</li><li>SSL：HAProxy可以解析HTTPS协议，并能够将请求解密为HTTP后向后端传输</li><li>HTTP请求重写与重定向</li><li>监控与统计：HAProxy提供了基于Web的统计信息页面，展现健康状态和流量数据。基于此功能，使用者可以开发监控程序来监控HAProxy的状态</li></ul><a id="more"></a><h3 id="HAProxy的关键特性"><a href="#HAProxy的关键特性" class="headerlink" title="HAProxy的关键特性"></a>HAProxy的关键特性</h3><p><strong>性能</strong></p><ul><li>采用单线程、事件驱动、非阻塞模型，减少上下文切换的消耗，能在1ms内处理数百个请求。并且每个会话只占用数KB的内存。</li><li>大量精细的性能优化，如O(1)复杂度的事件检查器、延迟更新技术、Single-buffereing、Zero-copy forwarding等等，这些技术使得HAProxy在中等负载下只占用极低的CPU资源。</li><li>HAProxy大量利用操作系统本身的功能特性，使得其在处理请求时能发挥极高的性能，通常情况下，HAProxy自身只占用15%的处理时间，剩余的85%都是在系统内核层完成的。</li><li>HAProxy作者在8年前（2009）年使用1.4版本进行了一次测试，单个HAProxy进程的处理能力突破了10万请求/秒，并轻松占满了10Gbps的网络带宽。</li></ul><p><strong>稳定性</strong></p><p>作为建议以单进程模式运行的程序，HAProxy对稳定性的要求是十分严苛的。按照作者的说法，HAProxy在13年间从未出现过一个会导致其崩溃的BUG，HAProxy一旦成功启动，除非操作系统或硬件故障，否则就不会崩溃（我觉得可能多少还是有夸大的成分）。</p><p>在上文中提到过，HAProxy的大部分工作都是在操作系统内核完成的，所以HAProxy的稳定性主要依赖于操作系统，作者建议使用2.6或3.x的Linux内核，对sysctls参数进行精细的优化，并且确保主机有足够的内存。这样HAProxy就能够持续满负载稳定运行数年之久。</p><p>个人的建议：</p><ul><li>使用3.x内核的Linux操作系统运行HAProxy</li><li>运行HAProxy的主机上不要部署其他的应用，确保HAProxy独占资源，同时避免其他应用引发操作系统或主机的故障</li><li>至少为HAProxy配备一台备机，以应对主机硬件故障、断电等突发情况（搭建双活HAProxy的方法在后文中有描述）</li><li>sysctl的建议配置（并不是万用配置，仍然需要针对具体情况进行更精细的调整，但可以作为首次使用HAProxy的初始配置使用）：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.ip_local_port_range = 1024 65023</span><br><span class="line">net.ipv4.tcp_max_syn_backlog = 10240</span><br><span class="line">net.ipv4.tcp_max_tw_buckets = 400000</span><br><span class="line">net.ipv4.tcp_max_orphans = 60000</span><br><span class="line">net.ipv4.tcp_synack_retries = 3</span><br><span class="line">net.core.somaxconn = 10000</span><br></pre></td></tr></table></figure><h2 id="HAProxy的安装和运行"><a href="#HAProxy的安装和运行" class="headerlink" title="HAProxy的安装和运行"></a>HAProxy的安装和运行</h2><p>下面介绍在CentOS7中安装和运行HAProxy最新稳定版(1.7.2)的方法</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li>为HAProxy创建用户和用户组，此例中用户和用户组都是”ha”。注意，如果想要让HAProxy监听1024以下的端口，则需要以root用户来启动</li><li>下载并解压</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.haproxy.org/download/1.7/src/haproxy-1.7.2.tar.gz</span><br><span class="line">tar -xzf haproxy-1.7.2.tar.gz</span><br></pre></td></tr></table></figure><ol><li>编译并安装</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">make PREFIX=/home/ha/haproxy TARGET=linux2628</span><br><span class="line">make install PREFIX=/home/ha/haproxy</span><br></pre></td></tr></table></figure><p>PREFIX为指定的安装路径，TARGET则根据当前操作系统内核版本指定：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- linux22     for Linux 2.2</span><br><span class="line">- linux24     for Linux 2.4 and above (default)</span><br><span class="line">- linux24e    for Linux 2.4 with support for a working epoll (&gt; 0.21)</span><br><span class="line">- linux26     for Linux 2.6 and above</span><br><span class="line">- linux2628   for Linux 2.6.28, 3.x, and above (enables splice and tproxy)</span><br></pre></td></tr></table></figure><p>此例中，我们的操作系统内核版本为3.10.0，所以TARGET指定为linux2628</p><ol><li>创建HAProxy配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /home/ha/haproxy/conf</span><br><span class="line">vi /home/ha/haproxy/conf/haproxy.cfg</span><br></pre></td></tr></table></figure><p>我们先创建一个最简单配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">global #全局属性</span><br><span class="line">    daemon  #以daemon方式在后台运行</span><br><span class="line">    maxconn 256  #最大同时256连接</span><br><span class="line">    pidfile /home/ha/haproxy/conf/haproxy.pid  #指定保存HAProxy进程号的文件</span><br><span class="line"></span><br><span class="line">defaults #默认参数</span><br><span class="line">    mode http  #http模式</span><br><span class="line">    timeout connect 5000ms  #连接server端超时5s</span><br><span class="line">    timeout client 50000ms  #客户端响应超时50s</span><br><span class="line">    timeout server 50000ms  #server端响应超时50s</span><br><span class="line"></span><br><span class="line">frontend http-in #前端服务http-in</span><br><span class="line">    bind *:8080  #监听8080端口</span><br><span class="line">    default_backend servers  #请求转发至名为"servers"的后端服务</span><br><span class="line"></span><br><span class="line">backend servers #后端服务servers</span><br><span class="line">    server server1 127.0.0.1:8000 maxconn 32  #backend servers中只有一个后端服务，名字叫server1，起在本机的8000端口，HAProxy同时最多向这个服务发起32个连接</span><br></pre></td></tr></table></figure><p>更加详细的配置会在后面章节中进行说明<br>注意：HAProxy要求系统的ulimit -n参数大于[maxconn*2+18]，在设置较大的maxconn时，注意检查并修改ulimit -n参数</p><ol><li>将HAProxy注册为系统服务</li></ol><p>在/etc/init.d目录下添加HAProxy服务的启停脚本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/init.d/haproxy</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>! /bin/sh</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin:/home/ha/haproxy/sbin</span><br><span class="line">PROGDIR=/home/ha/haproxy</span><br><span class="line">PROGNAME=haproxy</span><br><span class="line">DAEMON=$PROGDIR/sbin/$PROGNAME</span><br><span class="line">CONFIG=$PROGDIR/conf/$PROGNAME.cfg</span><br><span class="line">PIDFILE=$PROGDIR/conf/$PROGNAME.pid</span><br><span class="line">DESC="HAProxy daemon"</span><br><span class="line">SCRIPTNAME=/etc/init.d/$PROGNAME</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span> Gracefully exit if the package has been removed.</span><br><span class="line">test -x $DAEMON || exit 0</span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">       echo -e "Starting $DESC: $PROGNAME\n"</span><br><span class="line">       $DAEMON -f $CONFIG</span><br><span class="line">       echo "."</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">       echo -e "Stopping $DESC: $PROGNAME\n"</span><br><span class="line">       haproxy_pid="$(cat $PIDFILE)"</span><br><span class="line">       kill $haproxy_pid</span><br><span class="line">       echo "."</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">restart()</span><br><span class="line">&#123;</span><br><span class="line">       echo -e "Restarting $DESC: $PROGNAME\n"</span><br><span class="line">       $DAEMON -f $CONFIG -p $PIDFILE -sf $(cat $PIDFILE)</span><br><span class="line">       echo "."</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">case "$1" in</span><br><span class="line"> start)</span><br><span class="line">       start</span><br><span class="line">       ;;</span><br><span class="line"> stop)</span><br><span class="line">       stop</span><br><span class="line">       ;;</span><br><span class="line"> restart)</span><br><span class="line">       restart</span><br><span class="line">       ;;</span><br><span class="line"> *)</span><br><span class="line">       echo "Usage: $SCRIPTNAME &#123;start|stop|restart&#125;" &gt;&amp;2</span><br><span class="line">       exit 1</span><br><span class="line">       ;;</span><br><span class="line">esac</span><br><span class="line"></span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>启动、停止和重启：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service haproxy start</span><br><span class="line">service haproxy stop</span><br><span class="line">service haproxy restart</span><br></pre></td></tr></table></figure><h3 id="添加日志"><a href="#添加日志" class="headerlink" title="添加日志"></a>添加日志</h3><p>HAProxy不会直接输出文件日志，所以我们要借助Linux的rsyslog来让HAProxy输出日志</p><ol><li>修改haproxy.cfg</li></ol><p>在global域和defaults域中添加：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    ...</span><br><span class="line">    log 127.0.0.1 local0 info</span><br><span class="line">    log 127.0.0.1 local1 warning</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    ...</span><br><span class="line">    log global</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><p>意思是将info级（及以上）的日志推送到rsyslog的local0接口，将warn级（及以上）的日志推送到rsyslog的local1接口，并且所有frontend都默认使用global中的日志配置。</p><p>注：info级的日志会打印HAProxy处理的每一条请求，会占用很大的磁盘空间，在生产环境中，建议将日志级别调整为notice</p><ol><li>为rsyslog添加haproxy日志的配置</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/rsyslog.d/haproxy.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span>ModLoad imudp</span><br><span class="line"><span class="meta">$</span>UDPServerRun 514</span><br><span class="line"><span class="meta">$</span>FileCreateMode 0644  #日志文件的权限</span><br><span class="line"><span class="meta">$</span>FileOwner ha  #日志文件的owner</span><br><span class="line">local0.*     /var/log/haproxy.log  #local0接口对应的日志输出文件</span><br><span class="line">local1.*     /var/log/haproxy_warn.log  #local1接口对应的日志输出文件</span><br></pre></td></tr></table></figure><ol><li>修改rsyslog的启动参数</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/sysconfig/rsyslog</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> Options for rsyslogd</span><br><span class="line"><span class="meta">#</span> Syslogd options are deprecated since rsyslog v3.</span><br><span class="line"><span class="meta">#</span> If you want to use them, switch to compatibility mode 2 by "-c 2"</span><br><span class="line"><span class="meta">#</span> See rsyslogd(8) for more details</span><br><span class="line">SYSLOGD_OPTIONS="-c 2 -r -m 0"</span><br></pre></td></tr></table></figure><ol><li>重启rsyslog和HAProxy</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">service rsyslog restart</span><br><span class="line">service haproxy restart</span><br></pre></td></tr></table></figure><p>此时就应该能在/var/log目录下看到haproxy的日志文件了</p><ol><li>用logrotate进行日志切分</li></ol><p>通过rsyslog输出的日志是不会进行切分的，所以需要依靠Linux提供的logrotate来进行切分工作</p><p>使用root用户，创建haproxy日志切分配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir /root/logrotate</span><br><span class="line">vi /root/logrotate/haproxy</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/var/log/haproxy.log /var/log/haproxy_warn.log &#123;  #切分的两个文件名</span><br><span class="line">    daily        #按天切分</span><br><span class="line">    rotate 7     #保留7份</span><br><span class="line">    create 0644 ha ha  #创建新文件的权限、用户、用户组</span><br><span class="line">    compress     #压缩旧日志</span><br><span class="line">    delaycompress  #延迟一天压缩</span><br><span class="line">    missingok    #忽略文件不存在的错误</span><br><span class="line">    dateext      #旧日志加上日志后缀</span><br><span class="line">    sharedscripts  #切分后的重启脚本只运行一次</span><br><span class="line">    postrotate   #切分后运行脚本重载rsyslog，让rsyslog向新的日志文件中输出日志</span><br><span class="line">      /bin/kill -HUP $(/bin/cat /var/run/syslogd.pid 2&gt;/dev/null) &amp;&gt;/dev/null</span><br><span class="line">    endscript</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并配置在crontab中运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 0 * * * /usr/sbin/logrotate /root/logrotate/haproxy</span><br></pre></td></tr></table></figure><h1 id="使用HAProxy搭建L7负载均衡器"><a href="#使用HAProxy搭建L7负载均衡器" class="headerlink" title="使用HAProxy搭建L7负载均衡器"></a>使用HAProxy搭建L7负载均衡器</h1><h3 id="总体方案"><a href="#总体方案" class="headerlink" title="总体方案"></a>总体方案</h3><p>本节中，我们将使用HAProxy搭建一个L7负载均衡器，应用如下功能</p><ul><li>负载均衡</li><li>会话保持</li><li>健康检查</li><li>根据URI前缀向不同的后端集群转发</li><li>监控页面</li></ul><p>架构如下：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/10f6435761f56be6720b7273801b54b6.png" alt=""></p><p>架构中共有6个后端服务，划分为3组，每组中2个服务：</p><ul><li>ms1：服务URI前缀为ms1/的请求</li><li>ms2：服务URI前缀为ms2/的请求</li><li>def：服务其他请求</li></ul><h3 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h3><ol><li>搭建后端服务</li></ol><p>部署6个后端服务，可以使用任意的Web服务，如Nginx、Apache HTTPD、Tomcat、Jetty等，具体Web服务的安装过程省略。</p><p>此例中，我们在192.168.8.111和192.168.8.112两台主机上分别安装了3个Nginx：</p><blockquote><p>ms1.srv1 - 192.168.8.111:8080<br>ms1.srv2 - 192.168.8.112:8080<br>ms2.srv1 - 192.168.8.111:8081<br>ms2.srv2 - 192.168.8.112:8081<br>def.srv1 - 192.168.8.111:8082<br>def.srv2 - 192.168.8.112:8082</p></blockquote><p>在这6个Nginx服务分别部署健康检查页面healthCheck.html，页面内容任意。确保通过<a href="https://link.jianshu.com?t=http://ip:port/healthCheck.html" target="_blank" rel="noopener">http://ip:port/healthCheck.html</a>可以访问到这个页面</p><p>接下来在6个Nginx服务中部署服务页面：</p><blockquote><p>在第一组中部署ms1/demo.html<br>在第二组中部署ms2/demo.html<br>在第三组中部署def/demo.html</p></blockquote><p>demo.html的内容，以部署在192.168.8.111:8080上的为例：</p><blockquote><p>Hello! This is ms1.srv1!</p></blockquote><p>部署在192.168.8.112:8080上的就应该是</p><blockquote><p>Hello! This is ms1.srv2!</p></blockquote><p>以此类推</p><ol><li>搭建HAProxy</li></ol><p>在192.168.8.110主机安装HAProxy<br>HAProxy的安装和配置步骤如上一章中描述，此处略去</p><p>HAProxy配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    daemon</span><br><span class="line">    maxconn 30000   #ulimit -n至少为60018</span><br><span class="line">    user ha</span><br><span class="line">    pidfile /home/ha/haproxy/conf/haproxy.pid</span><br><span class="line">    log 127.0.0.1 local0 info</span><br><span class="line">    log 127.0.0.1 local1 warning</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    mode http</span><br><span class="line">    log global</span><br><span class="line">    option http-keep-alive   #使用keepAlive连接</span><br><span class="line">    option forwardfor        #记录客户端IP在X-Forwarded-For头域中</span><br><span class="line">    option httplog           #开启httplog，HAProxy会记录更丰富的请求信息</span><br><span class="line">    timeout connect 5000ms</span><br><span class="line">    timeout client 10000ms</span><br><span class="line">    timeout server 50000ms</span><br><span class="line">    timeout http-request 20000ms    #从连接创建开始到从客户端读取完整HTTP请求的超时时间，用于避免类DoS攻击</span><br><span class="line">    option httpchk GET /healthCheck.html    #定义默认的健康检查策略</span><br><span class="line"></span><br><span class="line">frontend http-in</span><br><span class="line">    bind *:9001</span><br><span class="line">    maxconn 30000                    #定义此端口上的maxconn</span><br><span class="line">    acl url_ms1 path_beg -i /ms1/    #定义ACL，当uri以/ms1/开头时，ACL[url_ms1]为true</span><br><span class="line">    acl url_ms2 path_beg -i /ms2/    #同上，url_ms2</span><br><span class="line">    use_backend ms1 if url_ms1       #当[url_ms1]为true时，定向到后端服务群ms1中</span><br><span class="line">    use_backend ms2 if url_ms2       #当[url_ms2]为true时，定向到后端服务群ms2中</span><br><span class="line">    default_backend default_servers  #其他情况时，定向到后端服务群default_servers中</span><br><span class="line"></span><br><span class="line">backend ms1    #定义后端服务群ms1</span><br><span class="line">    balance roundrobin    #使用RR负载均衡算法</span><br><span class="line">    cookie HA_STICKY_ms1 insert indirect nocache    #会话保持策略，insert名为"HA_STICKY_ms1"的cookie</span><br><span class="line">    #定义后端server[ms1.srv1]，请求定向到该server时会在响应中写入cookie值[ms1.srv1]</span><br><span class="line">    #针对此server的maxconn设置为300</span><br><span class="line">    #应用默认健康检查策略，健康检查间隔和超时时间为2000ms，两次成功视为节点UP，三次失败视为节点DOWN</span><br><span class="line">    server ms1.srv1 192.168.8.111:8080 cookie ms1.srv1 maxconn 300 check inter 2000ms rise 2 fall 3</span><br><span class="line">    #同上，inter 2000ms rise 2 fall 3是默认值，可以省略</span><br><span class="line">    server ms1.srv2 192.168.8.112:8080 cookie ms1.srv2 maxconn 300 check</span><br><span class="line"></span><br><span class="line">backend ms2    #定义后端服务群ms2</span><br><span class="line">    balance roundrobin</span><br><span class="line">    cookie HA_STICKY_ms2 insert indirect nocache</span><br><span class="line">    server ms2.srv1 192.168.8.111:8081 cookie ms2.srv1 maxconn 300 check</span><br><span class="line">    server ms2.srv2 192.168.8.112:8081 cookie ms2.srv2 maxconn 300 check</span><br><span class="line"></span><br><span class="line">backend default_servers    #定义后端服务群default_servers</span><br><span class="line">    balance roundrobin</span><br><span class="line">    cookie HA_STICKY_def insert indirect nocache</span><br><span class="line">    server def.srv1 192.168.8.111:8082 cookie def.srv1 maxconn 300 check</span><br><span class="line">    server def.srv2 192.168.8.112:8082 cookie def.srv2 maxconn 300 check</span><br><span class="line"></span><br><span class="line">listen stats    #定义监控页面</span><br><span class="line">    bind *:1080                   #绑定端口1080</span><br><span class="line">    stats refresh 30s             #每30秒更新监控数据</span><br><span class="line">    stats uri /stats              #访问监控页面的uri</span><br><span class="line">    stats realm HAProxy\ Stats    #监控页面的认证提示</span><br><span class="line">    stats auth admin:admin        #监控页面的用户名和密码</span><br></pre></td></tr></table></figure><p>修改完成后，启动HAProxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service haproxy start</span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>首先，访问一下监控页面<a href="https://link.jianshu.com?t=http://192.168.8.110:1080/stats" target="_blank" rel="noopener">http://192.168.8.110:1080/stats</a> 并按提示输入用户名密码</p><p>接下来就能看到监控页面：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/26ea0c07e62282ea71fad84057dc90e1.png" alt="">)</p><p>监控页面中列出了我们配置的所有frontend和backend服务，以及它们的详细指标。如连接数，队列情况，session rate，流量，后端服务的健康状态等等</p><p>接下来，我们一一测试在HAProxy中配置的功能</p><ol><li>健康检查</li></ol><p>从监控页面中就可以直接看出健康检查配置的是否正确，上图中可以看到，backend ms1、ms2、default_servers下属的6个后端服务的Status都是20h28m UP，代表健康状态已持续了20小时28分钟，而LastChk显示L7OK/200 in 1ms则代表在1ms前进行了L7的健康检查（即HTTP请求方式的健康检查），返回码为200</p><p>此时我们将ms1.srv1中的healthCheck.html改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv healthCheck.html healthCheck.html.bak</span><br></pre></td></tr></table></figure><p>然后再去看监控页面：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/07245ca54945eb31dedc9870ec04dc7f.png" alt="">ms1.srv1的状态变成了2s DOWN，LastChk则是L7STS/404 in 2ms，代表上次健康检查返回了404<br>再恢复healthCheck.html，很快就能看到ms1.srv1重新恢复到UP状态</p><ol><li>通过URI前缀转发请求</li></ol><p>访问<a href="https://link.jianshu.com?t=http://192.168.8.110:9001/ms1/demo.html" target="_blank" rel="noopener">http://192.168.8.110:9001/ms1/demo.html</a> ：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/629a459dbdca637d2acfdb61d2771d70.png" alt=""></p><p>可以看到成功定向到了ms1.srv1上</p><p>访问<a href="https://link.jianshu.com?t=http://192.168.8.110:9001/ms2/demo.html" target="_blank" rel="noopener">http://192.168.8.110:9001/ms2/demo.html</a> :</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/1433a52e8096b0d67e788decbc7558f6.png" alt=""></p><p>访问<a href="http://192.168.8.110:9001/def/demo.html" target="_blank" rel="noopener">http://192.168.8.110:9001/def/demo.html</a> :</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/841811c26e858c7c30b13a217dfb7422.png" alt=""></p><p>3） 负载均衡和会话保持策略</p><p>在分别访问过ms1/demo.html, ms2/demo.html, m3/demo.html后，查看一下浏览器的Cookie：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/b7e62fb33c1c7f9ff2018e75b6ea850a.png" alt=""></p><p>可以看到HAProxy已经回写了三个用于会话保持的cookie，此时反复刷新这三个页面，会发现总是被定向到*.srv1上</p><p>接下来我们删除HA_STICKY_ms1这条cookie，然后再访问ms1/demo.html，会看到：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/b4eec73ecdcf170039d844954efd0614.png" alt=""></p><p>同时也被新写入了一条Cookie：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/f87e9117f314599b210b043695d009c3.png" alt=""></p><p>如果发现仍然被定位到ms1.srv1，同时也没有写入新的HA_STICKY_ms1 Cookie，那么可能是浏览器缓存了ms1/demo.html页面，请求并没有到达HAProxy。F5刷新一下应该就可以了。</p><h1 id="使用HAProxy搭建L4负载均衡器"><a href="#使用HAProxy搭建L4负载均衡器" class="headerlink" title="使用HAProxy搭建L4负载均衡器"></a>使用HAProxy搭建L4负载均衡器</h1><p>HAProxy作为L4负载均衡器工作时，不会去解析任何与HTTP协议相关的内容，只在传输层对数据包进行处理。也就是说，以L4模式运行的HAProxy，无法实现根据URL向不同后端转发、通过cookie实现会话保持等功能。</p><p>同时，在L4模式下工作的HAProxy也无法提供监控页面。</p><p>但作为L4负载均衡器的HAProxy能够提供更高的性能，适合于基于套接字的服务（如数据库、消息队列、RPC、邮件服务、Redis等），或不需要逻辑规则判断，并已实现了会话共享的HTTP服务。</p><h3 id="总体方案-1"><a href="#总体方案-1" class="headerlink" title="总体方案"></a>总体方案</h3><p>本例中，我们使用HAProxy以L4方式来代理两个HTTP服务，不提供会话保持。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">global</span><br><span class="line">    daemon</span><br><span class="line">    maxconn 30000   #ulimit -n至少为60018</span><br><span class="line">    user ha</span><br><span class="line">    pidfile /home/ha/haproxy/conf/haproxy.pid</span><br><span class="line">    log 127.0.0.1 local0 info</span><br><span class="line">    log 127.0.0.1 local1 warning</span><br><span class="line"></span><br><span class="line">defaults</span><br><span class="line">    mode tcp</span><br><span class="line">    log global</span><br><span class="line">    option tcplog            #开启tcplog</span><br><span class="line">    timeout connect 5000ms</span><br><span class="line">    timeout client 10000ms</span><br><span class="line">    timeout server 10000ms   #TCP模式下，应将timeout client和timeout server设置为一样的值，以防止出现问题</span><br><span class="line">    option httpchk GET /healthCheck.html    #定义默认的健康检查策略</span><br><span class="line"></span><br><span class="line">frontend http-in</span><br><span class="line">    bind *:9002</span><br><span class="line">    maxconn 30000                    #定义此端口上的maxconn</span><br><span class="line">    default_backend default_servers  #请求定向至后端服务群default_servers</span><br><span class="line"></span><br><span class="line">backend default_servers    #定义后端服务群default_servers</span><br><span class="line">    balance roundrobin</span><br><span class="line">    server def.srv1 192.168.8.111:8082 maxconn 300 check</span><br><span class="line">    server def.srv2 192.168.8.112:8082 maxconn 300 check</span><br></pre></td></tr></table></figure><h3 id="L4模式下的会话保持"><a href="#L4模式下的会话保持" class="headerlink" title="L4模式下的会话保持"></a>L4模式下的会话保持</h3><p>虽然TCP模式下的HAProxy无法通过HTTP Cookie实现会话保持，但可以很方便的实现基于客户端IP的会话保持。只需将</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance roundrobin</span><br></pre></td></tr></table></figure><p>改为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">balance source</span><br></pre></td></tr></table></figure><p>此外，HAProxy提供了强大的stick-table功能，HAProxy可以从传输层的数据包中采样出大量的属性，并将这些属性作为会话保持的策略写入stick-table中。<br>本文中不对stick-table进行深入探讨，如需要了解，可参考官方文档<a href="https://link.jianshu.com?t=http://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4-stick-table" target="_blank" rel="noopener">configuration.html#4-stick-table</a></p><h1 id="HAProxy关键配置详解"><a href="#HAProxy关键配置详解" class="headerlink" title="HAProxy关键配置详解"></a>HAProxy关键配置详解</h1><h3 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h3><p>HAProxy的配置文件共有5个域</p><ul><li>global：用于配置全局参数</li><li>default：用于配置所有frontend和backend的默认属性</li><li>frontend：用于配置前端服务（即HAProxy自身提供的服务）实例</li><li>backend：用于配置后端服务（即HAProxy后面接的服务）实例组</li><li>listen：frontend+backend的组合配置，可以理解成更简洁的配置方法</li></ul><h4 id="global域的关键配置"><a href="#global域的关键配置" class="headerlink" title="global域的关键配置"></a>global域的关键配置</h4><ul><li>daemon：指定HAProxy以后台模式运行，通常情况下都应该使用这一配置</li><li>user [username] ：指定HAProxy进程所属的用户</li><li>group [groupname] ：指定HAProxy进程所属的用户组</li><li>log [address] [device] [maxlevel] [minlevel]：日志输出配置，如log 127.0.0.1 local0 info warning，即向本机rsyslog或syslog的local0输出info到warning级别的日志。其中[minlevel]可以省略。HAProxy的日志共有8个级别，从高到低为emerg/alert/crit/err/warning/notice/info/debug</li><li>pidfile ：指定记录HAProxy进程号的文件绝对路径。主要用于HAProxy进程的停止和重启动作。</li><li>maxconn ：HAProxy进程同时处理的连接数，当连接数达到这一数值时，HAProxy将停止接收连接请求</li></ul><h4 id="frontend域的关键配置"><a href="#frontend域的关键配置" class="headerlink" title="frontend域的关键配置"></a>frontend域的关键配置</h4><ul><li>acl [name] [criterion] [flags] [operator] [value]：定义一条ACL，ACL是根据数据包的指定属性以指定表达式计算出的true/false值。如”acl url_ms1 path_beg -i /ms1/“定义了名为url_ms1的ACL，该ACL在请求uri以/ms1/开头（忽略大小写）时为true</li><li>bind [ip]:[port]：frontend服务监听的端口</li><li>default_backend [name]：frontend对应的默认backend</li><li>disabled：禁用此frontend</li><li>http-request [operation] [condition]：对所有到达此frontend的HTTP请求应用的策略，例如可以拒绝、要求认证、添加header、替换header、定义ACL等等。</li><li>http-response [operation] [condition]：对所有从此frontend返回的HTTP响应应用的策略，大体同上</li><li>log：同global域的log配置，仅应用于此frontend。如果要沿用global域的log配置，则此处配置为log global</li><li>maxconn：同global域的maxconn，仅应用于此frontend</li><li>mode：此frontend的工作模式，主要有http和tcp两种，对应L7和L4两种负载均衡模式</li><li>option forwardfor：在请求中添加X-Forwarded-For Header，记录客户端ip</li><li>option http-keep-alive：以KeepAlive模式提供服务</li><li>option httpclose：与http-keep-alive对应，关闭KeepAlive模式，如果HAProxy主要提供的是接口类型的服务，可以考虑采用httpclose模式，以节省连接数资源。但如果这样做了，接口的调用端将不能使用HTTP连接池</li><li>option httplog：开启httplog，HAProxy将会以类似Apache HTTP或Nginx的格式来记录请求日志</li><li>option tcplog：开启tcplog，HAProxy将会在日志中记录数据包在传输层的更多属性</li><li>stats uri [uri]：在此frontend上开启监控页面，通过[uri]访问</li><li>stats refresh [time]：监控数据刷新周期</li><li>stats auth [user]:[password]：监控页面的认证用户名密码</li><li>timeout client [time]：指连接创建后，客户端持续不发送数据的超时时间</li><li>timeout http-request [time]：指连接创建后，客户端没能发送完整HTTP请求的超时时间，主要用于防止DoS类攻击，即创建连接后，以非常缓慢的速度发送请求包，导致HAProxy连接被长时间占用</li><li>use_backend [backend] if|unless [acl]：与ACL搭配使用，在满足/不满足ACL时转发至指定的backend</li></ul><h4 id="backend域的关键配置"><a href="#backend域的关键配置" class="headerlink" title="backend域的关键配置"></a>backend域的关键配置</h4><ul><li>acl：同frontend域</li><li>balance [algorithm]：在此backend下所有server间的负载均衡算法，常用的有roundrobin和source，完整的算法说明见官方文档<a href="https://link.jianshu.com?t=http://cbonte.github.io/haproxy-dconv/1.7/configuration.html#4.2-balance" target="_blank" rel="noopener">configuration.html#4.2-balance</a></li><li>cookie：在backend server间启用基于cookie的会话保持策略，最常用的是insert方式，如cookie HA_STICKY_ms1 insert indirect nocache，指HAProxy将在响应中插入名为HA_STICKY_ms1的cookie，其值为对应的server定义中指定的值，并根据请求中此cookie的值决定转发至哪个server。indirect代表如果请求中已经带有合法的HA_STICK_ms1 cookie，则HAProxy不会在响应中再次插入此cookie，nocache则代表禁止链路上的所有网关和缓存服务器缓存带有Set-Cookie头的响应。</li><li>default-server：用于指定此backend下所有server的默认设置。具体见下面的server配置。</li><li>disabled：禁用此backend</li><li>http-request/http-response：同frontend域</li><li>log：同frontend域</li><li>mode：同frontend域</li><li>option forwardfor：同frontend域</li><li>option http-keep-alive：同frontend域</li><li>option httpclose：同frontend域</li><li>option httpchk [METHOD] [URL] [VERSION]：定义以http方式进行的健康检查策略。如option httpchk GET /healthCheck.html HTTP/1.1</li><li>option httplog：同frontend域</li><li>option tcplog：同frontend域</li><li>server [name] [ip]:[port] [params]：定义backend中的一个后端server，[params]用于指定这个server的参数，常用的包括有：</li></ul><blockquote><p>check：指定此参数时，HAProxy将会对此server执行健康检查，检查方法在option httpchk中配置。同时还可以在check后指定inter, rise, fall三个参数，分别代表健康检查的周期、连续几次成功认为server UP，连续几次失败认为server DOWN，默认值是inter 2000ms rise 2 fall 3<br>cookie [value]：用于配合基于cookie的会话保持，如cookie ms1.srv1代表交由此server处理的请求会在响应中写入值为ms1.srv1的cookie（具体的cookie名则在backend域中的cookie设置中指定）<br>maxconn：指HAProxy最多同时向此server发起的连接数，当连接数到达maxconn后，向此server发起的新连接会进入等待队列。默认为0，即无限<br>maxqueue：等待队列的长度，当队列已满后，后续请求将会发至此backend下的其他server，默认为0，即无限<br>weight：server的权重，0-256，权重越大，分给这个server的请求就越多。weight为0的server将不会被分配任何新的连接。所有server默认weight为1</p></blockquote><ul><li>timeout connect [time]：指HAProxy尝试与backend server创建连接的超时时间</li><li>timeout check [time]：默认情况下，健康检查的连接+响应超时时间为server命令中指定的inter值，如果配置了timeout check，HAProxy会以inter作为健康检查请求的连接超时时间，并以timeout check的值作为健康检查请求的响应超时时间</li><li>timeout server [time]：指backend server响应HAProxy请求的超时时间</li></ul><h3 id="default域"><a href="#default域" class="headerlink" title="default域"></a>default域</h3><p>上文所属的frontend和backend域关键配置中，除acl、bind、http-request、http-response、use_backend外，其余的均可以配置在default域中。default域中配置了的项目，如果在frontend或backend域中没有配置，将会使用default域中的配置。</p><h3 id="listen域"><a href="#listen域" class="headerlink" title="listen域"></a>listen域</h3><p>listen域是frontend域和backend域的组合，frontend域和backend域中所有的配置都可以配置在listen域下</p><h3 id="官方配置文档"><a href="#官方配置文档" class="headerlink" title="官方配置文档"></a>官方配置文档</h3><p>HAProxy的配置项非常多，支持非常丰富的功能，上文只列出了作为L7负载均衡器使用HAProxy时的一些关键参数。完整的参数说明请参见官方文档 <a href="https://link.jianshu.com?t=http://cbonte.github.io/haproxy-dconv/1.7/configuration.html" target="_blank" rel="noopener">configuration.html</a></p><h1 id="使用Keepalived实现HAProxy高可用"><a href="#使用Keepalived实现HAProxy高可用" class="headerlink" title="使用Keepalived实现HAProxy高可用"></a>使用Keepalived实现HAProxy高可用</h1><p>尽管HAProxy非常稳定，但仍然无法规避操作系统故障、主机硬件故障、网络故障甚至断电带来的风险。所以必须对HAProxy实施高可用方案。</p><p>下文将介绍利用Keepalived实现的HAProxy热备方案。即两台主机上的两个HAProxy实例同时在线，其中权重较高的实例为MASTER，MASTER出现问题时，另一台实例自动接管所有流量。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>在两台HAProxy的主机上分别运行着一个Keepalived实例，这两个Keepalived争抢同一个虚IP地址，两个HAProxy也尝试去绑定这同一个虚IP地址上的端口。<br>显然，同时只能有一个Keepalived抢到这个虚IP，抢到了这个虚IP的Keepalived主机上的HAProxy便是当前的MASTER。<br>Keepalived内部维护一个权重值，权重值最高的Keepalived实例能够抢到虚IP。同时Keepalived会定期check本主机上的HAProxy状态，状态OK时权重值增加。</p><h3 id="搭建HAProxy主备集群"><a href="#搭建HAProxy主备集群" class="headerlink" title="搭建HAProxy主备集群"></a>搭建HAProxy主备集群</h3><ol><li>环境准备</li></ol><p>在两台物理机上安装并配置HAProxy，本例中，将在192.168.8.110和192.168.8.111两台主机上上安装两套完全一样的HAProxy，具体步骤省略，请参考“<strong>使用HAProxy搭建L7负载均衡器</strong>”一节。</p><ol><li>安装Keepalived</li></ol><p>下载，解压，编译，安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wget http://www.keepalived.org/software/keepalived-1.2.19.tar.gz</span><br><span class="line">tar -xzf keepalived-1.2.19.tar.gz</span><br><span class="line">./configure --prefix=/usr/local/keepalived</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>注册为系统服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/keepalived/sbin/keepalived /usr/sbin/</span><br><span class="line">cp /usr/local/keepalived/etc/sysconfig/keepalived /etc/sysconfig/</span><br><span class="line">cp /usr/local/keepalived/etc/rc.d/init.d/keepalived /etc/init.d/</span><br><span class="line">chmod +x /etc/init.d/keepalived</span><br></pre></td></tr></table></figure><p>注意：Keepalived需要使用root用户进行安装和配置</p><ol><li>配置Keepalived</li></ol><p>创建并编辑配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/keepalived/</span><br><span class="line">cp /usr/local/keepalived/etc/keepalived/keepalived.conf /etc/keepalived/</span><br><span class="line">vi /etc/keepalived/keepalived.conf</span><br></pre></td></tr></table></figure><p>配置文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">global_defs &#123;</span><br><span class="line">    router_id LVS_DEVEL  #虚拟路由名称</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>HAProxy健康检查配置</span><br><span class="line">vrrp_script chk_haproxy &#123;</span><br><span class="line">    script "killall -0 haproxy"  #使用killall -0检查haproxy实例是否存在，性能高于ps命令</span><br><span class="line">    interval 2   #脚本运行周期</span><br><span class="line">    weight 2   #每次检查的加权权重值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>虚拟路由配置</span><br><span class="line">vrrp_instance VI_1 &#123;</span><br><span class="line">    state MASTER           #本机实例状态，MASTER/BACKUP，备机配置文件中请写BACKUP</span><br><span class="line">    interface enp0s25      #本机网卡名称，使用ifconfig命令查看</span><br><span class="line">    virtual_router_id 51   #虚拟路由编号，主备机保持一致</span><br><span class="line">    priority 101           #本机初始权重，备机请填写小于主机的值（例如100）</span><br><span class="line">    advert_int 1           #争抢虚地址的周期，秒</span><br><span class="line">    virtual_ipaddress &#123;</span><br><span class="line">        192.168.8.201      #虚地址IP，主备机保持一致</span><br><span class="line">    &#125;</span><br><span class="line">    track_script &#123;</span><br><span class="line">        chk_haproxy        #对应的健康检查配置</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果主机没有killall命令，则需要安装psmisc包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum intall psmisc</span><br></pre></td></tr></table></figure><ol><li>分别启动两个Keepalived</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service keepalived start</span><br></pre></td></tr></table></figure><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>启动后，先分别在两台主机查看虚IP 192.168.8.201由谁持有，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ip addr sh enp0s25   （将enp0s25替换成主机的网卡名）</span><br></pre></td></tr></table></figure><p>持有虚IP的主机输出会是这样的：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/3fd5c089dabe4e47de42a077ec9a3689.png" alt=""></p><p>另一台主机输出则是这样的：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/14110af3d561f9b0f656d8c04dae0ffc.png" alt=""></p><p>如果你先启动备机的Keepalived，那么很有可能虚IP会被备机抢到，因为备机的权重配置只比主机低1，只要执行一次健康检查就能把权重提高到102，高于主机的101。</p><p>此时访问<a href="https://link.jianshu.com?t=http://192.168.8.201:9001/ms1/demo.html" target="_blank" rel="noopener">http://192.168.8.201:9001/ms1/demo.html</a> ，可以看到我们先前部署的网页。</p><p>此时，检查/var/log/haproxy.log，能看到此请求落在了抢到了虚IP的主机上。</p><p>接下来，我们停掉当前MASTER主机的HAProxy实例（或者Keepalive实例，效果一样）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service haproxy stop</span><br></pre></td></tr></table></figure><p>再次访问<a href="https://link.jianshu.com?t=http://192.168.8.201:9001/ms1/demo.html" target="_blank" rel="noopener">http://192.168.8.201:9001/ms1/demo.html</a> ，并查看备机的/var/log/haproxy.log，会看到此请求落在了备机上，主备自动切换成功。</p><p>也可以再次执行ip addr sh enp0s25命令，会看到虚IP被备机抢去了。</p><p>在/var/log/message中，也能够看到keepalived输出的切换日志：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/40b39ae2f0687efd84d88b8b706d90b2.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;HAProxy是什么&quot;&gt;&lt;a href=&quot;#HAProxy是什么&quot; class=&quot;headerlink&quot; title=&quot;HAProxy是什么&quot;&gt;&lt;/a&gt;HAProxy是什么&lt;/h2&gt;&lt;p&gt;HAProxy是一个免费的负载均衡软件，可以运行于大部分主流的Linux操作系统上。&lt;/p&gt;&lt;p&gt;HAProxy提供了L4(TCP)和L7(HTTP)两种负载均衡能力，具备丰富的功能。HAProxy的社区非常活跃，版本更新快速。最关键的是，HAProxy具备媲美商用负载均衡器的性能和稳定性。&lt;/p&gt;&lt;p&gt;因为HAProxy的上述优点，它当前不仅仅是免费负载均衡软件的首选，更几乎成为了唯一选择。&lt;/p&gt;&lt;h2 id=&quot;HAProxy的核心能力和关键特性&quot;&gt;&lt;a href=&quot;#HAProxy的核心能力和关键特性&quot; class=&quot;headerlink&quot; title=&quot;HAProxy的核心能力和关键特性&quot;&gt;&lt;/a&gt;HAProxy的核心能力和关键特性&lt;/h2&gt;&lt;h3 id=&quot;HAProxy的核心功能&quot;&gt;&lt;a href=&quot;#HAProxy的核心功能&quot; class=&quot;headerlink&quot; title=&quot;HAProxy的核心功能&quot;&gt;&lt;/a&gt;HAProxy的核心功能&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;负载均衡：L4和L7两种模式，支持RR/静态RR/LC/IP Hash/URI Hash/URL_PARAM Hash/HTTP_HEADER Hash等丰富的负载均衡算法&lt;/li&gt;&lt;li&gt;健康检查：支持TCP和HTTP两种健康检查模式&lt;/li&gt;&lt;li&gt;会话保持：对于未实现会话共享的应用集群，可通过Insert Cookie/Rewrite Cookie/Prefix Cookie，以及上述的多种Hash方式实现会话保持&lt;/li&gt;&lt;li&gt;SSL：HAProxy可以解析HTTPS协议，并能够将请求解密为HTTP后向后端传输&lt;/li&gt;&lt;li&gt;HTTP请求重写与重定向&lt;/li&gt;&lt;li&gt;监控与统计：HAProxy提供了基于Web的统计信息页面，展现健康状态和流量数据。基于此功能，使用者可以开发监控程序来监控HAProxy的状态&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Web" scheme="http://windylee.cn/categories/Web/"/>
    
    
      <category term="HAProxy" scheme="http://windylee.cn/tags/HAProxy/"/>
    
  </entry>
  
  <entry>
    <title>Python中的itertools模块</title>
    <link href="http://windylee.cn/posts/4f4399bb/"/>
    <id>http://windylee.cn/posts/4f4399bb/</id>
    <published>2018-04-16T01:45:12.000Z</published>
    <updated>2018-04-16T01:48:29.638Z</updated>
    
    <content type="html"><![CDATA[<h4 id="无限迭代器"><a href="#无限迭代器" class="headerlink" title="无限迭代器"></a><strong>无限迭代器</strong></h4><ul><li><p>count(firstval=0, step=1)</p><p>创建一个从firstval（默认值为0）开始，以step（默认值为1）为步长的无限整数迭代器。此迭代器不支持长整数，如果超出了sys.maxint，计数器将溢出并继续从-sys.maxint-1开始计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> zip(count(<span class="number">1</span>), [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]):</span><br><span class="line">    print(x, y)</span><br><span class="line">输出:</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br></pre></td></tr></table></figure></li><li><p>cycle(iterable)</p><p>对iterable中的元素反复执行循环，返回生成的迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">index = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> cycle(<span class="string">'abcd'</span>):</span><br><span class="line">    index += <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> index == <span class="number">10</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    print(value)</span><br><span class="line">输出：</span><br><span class="line">a b c d a b c d a</span><br></pre></td></tr></table></figure></li><li><p>repeat(object, [,items])</p><p>返回一个迭代器，反复生成object，如果给定times，则重复次数为items，否则为无限</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> repeat(<span class="string">'windylee'</span>, <span class="number">5</span>):</span><br><span class="line">    print(value, end=<span class="string">' '</span>)</span><br><span class="line">输出：</span><br><span class="line">windylee windylee windylee windylee windylee</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h4 id="有限迭代器"><a href="#有限迭代器" class="headerlink" title="有限迭代器**"></a>有限迭代器**</h4><ul><li><p>chain(iterable1, iterable2, iterable3, …)</p><p>chain接收多个可迭代对象作为参数，将他们连接起来，作为一个新的迭代器返回</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> chain([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]):</span><br><span class="line">    print(value, end=<span class="string">' '</span>)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> a b c</span><br></pre></td></tr></table></figure></li><li><p>compress(data, selectors)</p><p>compress可用于对数据进行筛选，当selectors的元素为true时，则保留data对应位置的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> compress([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="keyword">True</span>, <span class="keyword">False</span>, <span class="keyword">False</span>, <span class="keyword">True</span>, <span class="keyword">True</span>]):</span><br><span class="line">    print(value, end=<span class="string">' '</span>)</span><br><span class="line">输出:</span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>dropwhile(predicate, iterable)</p><p>创建一个迭代器，只要函数predicate(item)为True，就丢弃iterable中的项，如果predicate返回False，就会生成iterable中的项和所有后续项。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> item &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> dropwhile(predict, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">    print(value, end=<span class="string">' '</span>)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></li><li><p>takewhile(predicate, iterable)</p><p>创建一个迭代器，只要函数predite(item)为True，就保留iterable中的项，如果predicate返回False，就会丢弃iterable中的项和所有的后续项。相当于<code>dropwhile</code>的反操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> item &lt; <span class="number">3</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> takewhile(predict, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]):</span><br><span class="line">    print(value, end=<span class="string">' '</span>)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>groupby(iterable[, keyfunc])</p><p>返回一个产生按照keyfunc的返回值进行分组的值集合的迭代器。iterable是一个可迭代对象，keyfunc是分组函数，用于对iterable的<strong>连续项</strong>进行分组。如果不指定，则默认将iterable中连续相同的项作为一组，否则将keyfunc返回值相同的连续项作为一组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">predict</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> item &lt; <span class="number">3</span> <span class="keyword">or</span> item &gt; <span class="number">7</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key, value <span class="keyword">in</span> groupby([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>], predict):</span><br><span class="line">    print(key, list(value))</span><br><span class="line">输出：</span><br><span class="line"><span class="keyword">True</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">False</span> [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line"><span class="keyword">True</span> [<span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li><li><p>starmap(function, iterable)</p><p>创建一个迭代器，对于iterable中每一项item生成值<code>func(*item)</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> starmap(<span class="keyword">lambda</span> x, y: x * y, [(<span class="number">0</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">6</span>), (<span class="number">2</span>, <span class="number">7</span>), (<span class="number">3</span>, <span class="number">8</span>), (<span class="number">4</span>, <span class="number">9</span>)]):</span><br><span class="line">    print(value, end=<span class="string">' '</span>)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">0</span> <span class="number">6</span> <span class="number">14</span> <span class="number">24</span> <span class="number">36</span></span><br></pre></td></tr></table></figure></li><li><p>tee(iterable, [, n])</p><p>用于从iterable创建n个独立的迭代器，以元组的形式返回，n的默认值是2。由于生成的项会被缓存，并在所有新创建的迭代器中使用，所以一定要注意不要再调用<code>tee()</code>之后使用原始迭代器iterable，否则缓存机制可能无法正常工作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">iter1, iter2 = tee([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">for</span> v1 <span class="keyword">in</span> iter1:</span><br><span class="line">    print(v1, end=<span class="string">' '</span>)</span><br><span class="line">print()</span><br><span class="line"><span class="keyword">for</span> v2 <span class="keyword">in</span> iter2:</span><br><span class="line">    print(v2, end=<span class="string">' '</span>)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>zip_longest(*iterables, fillvalue=None)</p><p>类似于内置函数zip，只不过迭代完最长的序列为止，短序列默认用None补齐。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> v1, v2 <span class="keyword">in</span> zip_longest([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]):</span><br><span class="line">    print(v1, v2)</span><br><span class="line">输出：</span><br><span class="line"><span class="number">1</span> a</span><br><span class="line"><span class="number">2</span> b</span><br><span class="line"><span class="number">3</span> c</span><br><span class="line"><span class="keyword">None</span> d</span><br></pre></td></tr></table></figure></li><li><p>accumulate(iterable, [,func])</p><p>创建一个迭代器，返回从第一项到当前项的子列表执行reduce函数的值。func是一个二元函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(itertools.accumulate([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], func=operator.add))</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">10</span>]</span><br></pre></td></tr></table></figure></li></ul><h4 id="组合生成器"><a href="#组合生成器" class="headerlink" title="组合生成器"></a><strong>组合生成器</strong></h4><ul><li><p>product(*iterables [,repeat=1])</p><p>创建一个迭代器，生成多个可迭代对象的笛卡尔积，跟嵌套for循环等价，repeat用于指定重复生成序列的次数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> accumulate([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]):</span><br><span class="line">    print(value)</span><br><span class="line">输出：</span><br><span class="line">a</span><br><span class="line">ab</span><br><span class="line">abc</span><br></pre></td></tr></table></figure></li><li><p>permutations(iterable, [, r]])</p><p>创建一个迭代器，生成iterable中元素的排列，r用于指定生成排列的长度，如果省略r，生成的序列长度与iterable长度相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> permutations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]):</span><br><span class="line">    print(list(value))</span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p>combinations(iterable, r)</p><p>创建一个迭代器，生成iterable中所有长度为r的序列。序列中元素的排列顺序和iterable中元素顺序相同，序列中元素不重复</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> combinations([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>):</span><br><span class="line">    print(list(value))</span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li><li><p>combinations_with_replacement(iterable, [, r])</p><p>功能和<code>combinations</code>类似，不过该函数生成的序列中允许元素重复。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> combinations_with_replacement([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="number">2</span>):</span><br><span class="line">    print(list(value))</span><br><span class="line">输出：</span><br><span class="line">[<span class="number">1</span>, <span class="number">1</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">2</span>]</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">3</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>​</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;无限迭代器&quot;&gt;&lt;a href=&quot;#无限迭代器&quot; class=&quot;headerlink&quot; title=&quot;无限迭代器&quot;&gt;&lt;/a&gt;&lt;strong&gt;无限迭代器&lt;/strong&gt;&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;&lt;p&gt;count(firstval=0, step=1)&lt;/p&gt;&lt;p&gt;创建一个从firstval（默认值为0）开始，以step（默认值为1）为步长的无限整数迭代器。此迭代器不支持长整数，如果超出了sys.maxint，计数器将溢出并继续从-sys.maxint-1开始计算。&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; x, y &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; zip(count(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;), [&lt;span class=&quot;string&quot;&gt;&#39;a&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;b&#39;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&#39;c&#39;&lt;/span&gt;]):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(x, y)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; a&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; c&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;cycle(iterable)&lt;/p&gt;&lt;p&gt;对iterable中的元素反复执行循环，返回生成的迭代器&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;index = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; value &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; cycle(&lt;span class=&quot;string&quot;&gt;&#39;abcd&#39;&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    index += &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; index == &lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;break&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(value)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a b c d a b c d a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;repeat(object, [,items])&lt;/p&gt;&lt;p&gt;返回一个迭代器，反复生成object，如果给定times，则重复次数为items，否则为无限&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; value &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; repeat(&lt;span class=&quot;string&quot;&gt;&#39;windylee&#39;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(value, end=&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;windylee windylee windylee windylee windylee&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Python" scheme="http://windylee.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://windylee.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>String源码解析</title>
    <link href="http://windylee.cn/posts/827303fc/"/>
    <id>http://windylee.cn/posts/827303fc/</id>
    <published>2018-04-04T15:14:05.000Z</published>
    <updated>2018-04-04T15:16:17.771Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>先看一下文档中的注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Strings are constant; their values cannot be changed after they</span></span><br><span class="line"><span class="comment"> * are created. String buffers support mutable strings.</span></span><br><span class="line"><span class="comment"> * Because String objects are immutable they can be shared.</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p>String对象是常量，创建之后就不能被修改，所以该对象可以被多线程共享。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> hash; <span class="comment">// Default to 0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6849794470754667710L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ObjectStreamField[] serialPersistentFields =</span><br><span class="line">        <span class="keyword">new</span> ObjectStreamField[<span class="number">0</span>];</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从源码中可以看出，String是被final修饰的，说明该类不能被继承。并且实现了<code>CharSequence</code>, <code>Comparable</code>, <code>Serializable</code>接口。<code>Serializable</code>接口用于实现String的序列化和反序列化操作；<code>Comparable</code>接口用于实现字符串的比较操作；<code>CharSequence</code>是字符串类的父接口，StringBuffer和StringBuilder都继承自该接口。</p><ol><li>value字段是实现String类的底层数组，用于存储字符串内容。final修饰基本数据类型，那么在运行期间其内容不可变，如果修饰的是引用类型，那么引用的对象(包括数组)运行期地址不可变，但是对象的内容是可以改变的。</li><li>hash字段用于缓存String对象的hash值，防止多次计算hash造成的时间损耗。</li><li>因为String实现了<code>Serializable</code>接口，所以需要serialVersionUID字段用来在String反序列化时，通过对比字节流中的serialVersionUID和本地实体类中的serialVersionUID是否一致，如果相同就可以进行反序列化，否则就会抛出<code>InvalidCastException</code>异常。</li></ol><a id="more"></a><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h4 id="空参构造方法"><a href="#空参构造方法" class="headerlink" title="空参构造方法"></a>空参构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = <span class="string">""</span>.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该构造方法会创建一个空的字符序列，因为字符串的不可变对象，之后对象的赋值会指向新的字符串，因此使用这种构造方法会多创建一个无用对象。</p><h4 id="使用字符串类型的对象初始化"><a href="#使用字符串类型的对象初始化" class="headerlink" title="使用字符串类型的对象初始化"></a>使用字符串类型的对象初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = original.value;</span><br><span class="line">    <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将源String中的value和hash两个属性直接赋值给目标String。因为String一旦定义之后就不可改变，所以也就不用担心源String的值会影响到目标String的值。</p><h4 id="使用字符数组初始化"><a href="#使用字符数组初始化" class="headerlink" title="使用字符数组初始化"></a>使用字符数组初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为char数组，通过java.utils包中的Arrays.copyOf复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(value, value.length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用字符数组的一部分初始化，通过Arrays.copyOfRange复制</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span> value[], <span class="keyword">int</span> offset, <span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 异常检测</span></span><br><span class="line">  ......</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOfRange(value, offset, offset+count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="使用字节数组初始化"><a href="#使用字节数组初始化" class="headerlink" title="使用字节数组初始化"></a>使用字节数组初始化</h4><p>在Java中，String实例保存有一个char[]字符数组，char[]字符数组是以Unicode编码方式存储的，String和char为内存形式，byte是网络传输或存储的序列化形式，所以在很多传输和存储过程中需要将byte[]数组和String进行相互转化。字节和字符自检的转化需要指定编码，不然很可能会出现乱码。String提供了多种字节数组的重载构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, String charsetName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length, Charset charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], String charsetName)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], Charset charset)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[], <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span> bytes[])</span></span></span><br></pre></td></tr></table></figure><p>如果我们在使用 byte[] 构造 String 的时候，如果指定了<code>charsetName</code>或者<code>charset</code>参数的话，那么就会使用 <code>StringCoding.decode</code> 方法进行解码，使用的解码的字符集就是我们指定的 <code>charsetName</code> 或者 <code>charset</code>。如果没有指定解码使用的字符集的话，那么<code>StringCoding</code>的<code>decode</code>方法首先会使用系统的默认编码格式(ISO-8859-1)。</p><h4 id="使用StringBuffer和StringBuilder初始化"><a href="#使用StringBuffer和StringBuilder初始化" class="headerlink" title="使用StringBuffer和StringBuilder初始化"></a>使用StringBuffer和StringBuilder初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuffer buffer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(buffer) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = Arrays.copyOf(buffer.getValue(), buffer.length());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(StringBuilder builder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = Arrays.copyOf(builder.getValue(), builder.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为StringBuilder不是线程安全的，所以在初始化时不需要加锁；而StringBuilder则需要加锁。我们一般使用StringBuffer和StringBuilder的<code>toString</code>方法来获取String，而很少使用String的这两种构造方法。</p><h4 id="特殊的构造方法"><a href="#特殊的构造方法" class="headerlink" title="特殊的构造方法"></a>特殊的构造方法</h4><p>String除了提供了很多共有的构造方法，还提供了一个保护类型的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String(<span class="keyword">char</span>[] value, <span class="keyword">boolean</span> share) &#123;</span><br><span class="line">    <span class="comment">// assert share : "unshared not supported";</span></span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法和<code>String(char[] value)</code>有两点区别：</p><ul><li>该方法多了一个参数：boolean share，但该参数在函数中并没有使用。因此加入该参数的目的只是为了区分<code>String(char[] value)</code>方法，只有参数不同才能被重载。</li><li>该方法直接修改了value数组的引用，也就是说共享char[] value数组。而<code>String(char[] value)</code>通过<code>Arrays.copyOf</code>将参数数组内容复制到String中。</li></ul><p>使用这种方式的的优点很明显：</p><ul><li><p>性能好，直接修改指针，避免了逐一拷贝。</p></li><li><p>节约内存，底层共享同一字符数组。</p><p>当然这种方式也存在缺点，如果外部修改了传进来的字符数组的内容，由于他们引用的是同一个数组，因此外部对数组的修改相当于修改了字符串。为了保证字符串对象的不变性，将其访问权限设置成了default，其他类无法通过该构造方法初始化字符串对象。这样一来，无论源字符串还是新字符串，其value数组本身都是String对象的私有属性，从外部无法访问，保证了String的安全性。该函数只能用在不能缩短String长度的函数中，如<code>concat(str1, str2)</code>，如果用在缩短String长度的函数如<code>subString</code>中会造成内存泄漏。</p></li></ul><h3 id="经典方法技巧"><a href="#经典方法技巧" class="headerlink" title="经典方法技巧"></a>经典方法技巧</h3><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        String anotherString = (String)anObject;</span><br><span class="line">        <span class="keyword">int</span> n = value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="keyword">char</span> v1[] = value;</span><br><span class="line">            <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>先判断两个对象的地址是否相等</li><li>在判断是否是String类型</li><li>如果都是String类型，就先比较长度是否相等，然后再逐一比较值。值的比较采取了短路操作，发现不一样的就返回false</li></ol><h4 id="compareTo方法"><a href="#compareTo方法" class="headerlink" title="compareTo方法"></a>compareTo方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len1 = value.length;</span><br><span class="line">    <span class="keyword">int</span> len2 = anotherString.value.length;</span><br><span class="line">    <span class="keyword">int</span> lim = Math.min(len1, len2);</span><br><span class="line">    <span class="keyword">char</span> v1[] = value;</span><br><span class="line">    <span class="keyword">char</span> v2[] = anotherString.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (k &lt; lim) &#123;</span><br><span class="line">        <span class="keyword">char</span> c1 = v1[k];</span><br><span class="line">        <span class="keyword">char</span> c2 = v2[k];</span><br><span class="line">        <span class="keyword">if</span> (c1 != c2) &#123;</span><br><span class="line">            <span class="keyword">return</span> c1 - c2;</span><br><span class="line">        &#125;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> len1 - len2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从0开始逐一判断字符是否相等，若不相等则做差运算，巧妙的避免了三种判断情况。若字符都相等，接直接返回长度差值。所以在判断两个字符串大小时，使用是否为正数/负数/0，而不是通过1//-1/0判断。</p><h4 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>若第一次调用<code>hashCode</code>方法且value数组长度大于0，则通过算法<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>计算hash值。hash值很多时候用来判断两个对象的值是否相等，所以需要尽可能的避免冲突。选择31是因为31是一个素数，且<code>i * 31</code>可以通过<code>(i &lt;&lt; 5) - 1</code>来提高运算速度，现在很多虚拟机都有做相关优化。 <strong>hashCode可以保证相同的字符串的hash值肯定相同，但是，hash值相同并不一定是value值就相同。</strong></li><li>返回缓存的hash值。</li></ol><h4 id="replaceFirst、replaceAll，replace区别"><a href="#replaceFirst、replaceAll，replace区别" class="headerlink" title="replaceFirst、replaceAll，replace区别"></a>replaceFirst、replaceAll，replace区别</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">replaceFirst</span><span class="params">(String regex, String replacement)</span></span></span><br><span class="line"><span class="function">String <span class="title">replaceAll</span><span class="params">(String regex, String replacement)</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(Char Sequencetarget, Char Sequencereplacement)</span></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(CharSequence target, CharSequence replacement)</span></span></span><br></pre></td></tr></table></figure><ol><li><code>replace</code>的参数是char和CharSequence，既可以支持字符的替换，也支持字符串的替换</li><li><code>replaceFirst</code>和<code>replaceAll</code>的参数是regex，基于正则表达式替换</li><li><code>replace</code>和<code>replaceAll</code>方法会替换字符串中的全部字符或字符串，<code>replaceFirst</code>只替换第一次出现的字符或字符串</li></ol><h4 id="copyValueOf和valueOf"><a href="#copyValueOf和valueOf" class="headerlink" title="copyValueOf和valueOf"></a>copyValueOf和valueOf</h4><p>String的底层是通过char[]实现的，早期的String构造器的实现并不会拷贝数组。为了防止char[]数组被外部修改，提供了<code>copyValueOf</code>方法，每次都拷贝成新的字符数组来构造新的String对象。但是现在的String在构造器中就通过拷贝新数组实现，所以这两个方法在本质上已经没区别了。</p><p><code>valueOf()</code>有很多种重载形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">boolean</span> b)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> b ? <span class="string">"true"</span> : <span class="string">"false"</span>;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">char</span> data[] = &#123;c&#125;;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> String(data, <span class="keyword">true</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Integer.toString(i);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">long</span> l)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Long.toString(l);</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">float</span> f)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> Float.toString(f);</span><br><span class="line"> &#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">valueOf</span><span class="params">(<span class="keyword">double</span> d)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> Double.toString(d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层调用了基本数据类型的<code>toString()</code>方法。</p><h4 id="intern方法"><a href="#intern方法" class="headerlink" title="intern方法"></a>intern方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">intern</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p><code>intern</code>方法是Native调用，它的作用是每当定义一个字符字面量，字面量进行字符串连接或final的String字面量初始化的变量的连接，都会检查常量池中是否有对应的字符串，如果有就不创建新的字符串，而是返回指向常量池对应字符串的引用。所有通过<code>new String(str)</code>方式创建的对象都会保存在堆中，而不是常量区。普通变量的连接，由于不能在编译期确定下来，所以不会储存在常量区。</p><h3 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="comment">//返回字符串长度</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> <span class="comment">//返回字符串是否为空</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">charAt</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="comment">//返回字符串中第（index+1）个字符</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>[] <span class="title">toCharArray</span><span class="params">()</span> <span class="comment">//转化成字符数组</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">trim</span><span class="params">()</span> <span class="comment">//去掉两端空格</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">toUpperCase</span><span class="params">()</span> <span class="comment">//转化为大写</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">toLowerCase</span><span class="params">()</span> <span class="comment">//转化为小写</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">concat</span><span class="params">(String str)</span> <span class="comment">//拼接字符串</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String <span class="title">replace</span><span class="params">(<span class="keyword">char</span> oldChar, <span class="keyword">char</span> newChar)</span> <span class="comment">//将字符串中的oldChar字符换成newChar字符</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//以上两个方法都使用了String(char[] value, boolean share)；</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(String regex)</span> <span class="comment">//判断字符串是否匹配给定的regex正则表达式</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(CharSequence s)</span> <span class="comment">//判断字符串是否包含字符序列s</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex, <span class="keyword">int</span> limit)</span> <span class="comment">//按照字符regex将字符串分成limit份。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">String[] <span class="title">split</span><span class="params">(String regex)</span> <span class="comment">//按照regex表达式切分字符串</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span> <span class="comment">//比较对象</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(String Buffersb)</span> <span class="comment">//与字符串比较内容</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">contentEquals</span><span class="params">(Char Sequencecs)</span> <span class="comment">//与字符比较内容</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span> <span class="comment">//忽略大小写比较字符串对象</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(String anotherString)</span> <span class="comment">//比较字符串</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compareToIgnoreCase</span><span class="params">(String str)</span> <span class="comment">//忽略大小写比较字符串</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> <span class="comment">//局部匹配</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">regionMatches</span><span class="params">(<span class="keyword">boolean</span> ignoreCase, <span class="keyword">int</span> toffset, String other, <span class="keyword">int</span> ooffset, <span class="keyword">int</span> len)</span> <span class="comment">//可忽略大小写局部匹配</span></span></span><br></pre></td></tr></table></figure><h3 id="String对“-”的重载"><a href="#String对“-”的重载" class="headerlink" title="String对“+”的重载"></a>String对“+”的重载</h3><p>Java不支持运算符重载，但是String可以通过<code>+</code>来连接两个字符串。那么java是如何实现对<code>+</code>的重载的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String str1 = <span class="string">"windy"</span>;</span><br><span class="line">    string str2 = str1 + <span class="string">"lee"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译Main.java，执行命令<code>javap -c Main</code>，输出结果：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/Screenshot%20from%202018-04-04%2011-08-16.png" alt=""></p><p>我们看到了StringBuilder，还有windy和lee，以及调用了StringBuilder的<code>append</code>和<code>toString</code>方法。既然编译器已经在底层为我们进行了优化，那么为什么还要提倡我们用StringBuilder呢？</p><p>我们注意到在第3行代码，new了一个StringBuilder对象，如果实在一个循环里面，我们使用”+”号就会创建多个StringBuilder的对象。但是编译器事先不知道我们StringBuilder的长度，并不能事先分配好缓冲区，会加大内存的开销，而且使用重载的时候根据java的内存分配也会创建多个对象。</p><h3 id="switch对字符串支持的实现"><a href="#switch对字符串支持的实现" class="headerlink" title="switch对字符串支持的实现"></a>switch对字符串支持的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         String str = <span class="string">"world"</span>;</span><br><span class="line">         <span class="keyword">switch</span> (str) &#123;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"hello"</span>: </span><br><span class="line">              System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">case</span> <span class="string">"world"</span>:</span><br><span class="line">             System.out.println(<span class="string">"world"</span>);</span><br><span class="line">             <span class="keyword">break</span>;</span><br><span class="line">         <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译之后得到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">       String str = <span class="string">"world"</span>;</span><br><span class="line">       String s;</span><br><span class="line">       <span class="keyword">switch</span>((s = str).hashCode()) &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">99162322</span>:</span><br><span class="line">               <span class="keyword">if</span>(s.equals(<span class="string">"hello"</span>))</span><br><span class="line">                   System.out.println(<span class="string">"hello"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">case</span> <span class="number">113318802</span>:</span><br><span class="line">               <span class="keyword">if</span>(s.equals(<span class="string">"world"</span>))</span><br><span class="line">                   System.out.println(<span class="string">"world"</span>);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>: <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ol><li>首先调用String的<code>hashCode</code>方法，拿到相应的Code，通过这个code然后给每个case唯一的标识</li><li>判断时先获取对象的hashCode，进入对应的case分支</li><li>通过<code>equals</code>方法进行安全检查，这个检查是必要的，因为哈希可能会发生冲突</li></ol><blockquote><p>switch只支持整型，其他数据类型都是转换成整型之后在使用switch的</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p>String被final修饰，一旦被创建，无法修改</p><ul><li>final保证value不会指向其他的数组，但不保证数组内容不可修改</li><li>private属性保证不可在类外访问数组，也就不能改变其内容</li><li>String内部没有改变value内容的函数，保证String不可变</li><li>String声明为final杜绝了通过集成的方法添加新的函数</li><li>基于数组的构造方法，会拷贝数组元素，避免了通过外部引用修改value的情况</li><li>用String构造其他可变对象时，返回的数组的拷贝</li></ul><blockquote><p>final只在编译期有效，在运行期间无效，因此可以通过反射改变value引用的对象。反射虽然改变了s的内容，并没有创建新的对象。而且由于String缓存了hash值，所以通过反射改变字符数组内容，<code>hashCode</code>返回值不会自动更新。</p></blockquote></li><li><p>String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。</p></li><li><p>如果你需要一个可修改的字符串，应该使用StringBuilder或者 StringBuffer。</p></li><li><p>如果你只需要创建一个字符串，你可以使用双引号的方式，如果你需要在堆中创建一个新的对象，你可以选择构造函数的方式。</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;/a&gt;定义&lt;/h3&gt;&lt;p&gt;先看一下文档中的注释&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;/**&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Strings are constant; their values cannot be changed after they&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * are created. String buffers support mutable strings.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; * Because String objects are immutable they can be shared.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt; */&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;String对象是常量，创建之后就不能被修改，所以该对象可以被多线程共享。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;java&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;io&lt;/span&gt;.&lt;span class=&quot;title&quot;&gt;Serializable&lt;/span&gt;, &lt;span class=&quot;title&quot;&gt;Comparable&lt;/span&gt;&amp;lt;&lt;span class=&quot;title&quot;&gt;String&lt;/span&gt;&amp;gt;, &lt;span class=&quot;title&quot;&gt;CharSequence&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;char&lt;/span&gt; value[];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; hash; &lt;span class=&quot;comment&quot;&gt;// Default to 0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;long&lt;/span&gt; serialVersionUID = -&lt;span class=&quot;number&quot;&gt;6849794470754667710L&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;final&lt;/span&gt; ObjectStreamField[] serialPersistentFields =&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ObjectStreamField[&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ......&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;从源码中可以看出，String是被final修饰的，说明该类不能被继承。并且实现了&lt;code&gt;CharSequence&lt;/code&gt;, &lt;code&gt;Comparable&lt;/code&gt;, &lt;code&gt;Serializable&lt;/code&gt;接口。&lt;code&gt;Serializable&lt;/code&gt;接口用于实现String的序列化和反序列化操作；&lt;code&gt;Comparable&lt;/code&gt;接口用于实现字符串的比较操作；&lt;code&gt;CharSequence&lt;/code&gt;是字符串类的父接口，StringBuffer和StringBuilder都继承自该接口。&lt;/p&gt;&lt;ol&gt;&lt;li&gt;value字段是实现String类的底层数组，用于存储字符串内容。final修饰基本数据类型，那么在运行期间其内容不可变，如果修饰的是引用类型，那么引用的对象(包括数组)运行期地址不可变，但是对象的内容是可以改变的。&lt;/li&gt;&lt;li&gt;hash字段用于缓存String对象的hash值，防止多次计算hash造成的时间损耗。&lt;/li&gt;&lt;li&gt;因为String实现了&lt;code&gt;Serializable&lt;/code&gt;接口，所以需要serialVersionUID字段用来在String反序列化时，通过对比字节流中的serialVersionUID和本地实体类中的serialVersionUID是否一致，如果相同就可以进行反序列化，否则就会抛出&lt;code&gt;InvalidCastException&lt;/code&gt;异常。&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="Java" scheme="http://windylee.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://windylee.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal深度解析</title>
    <link href="http://windylee.cn/posts/cadd278f/"/>
    <id>http://windylee.cn/posts/cadd278f/</id>
    <published>2018-03-22T02:20:26.000Z</published>
    <updated>2018-04-03T15:30:07.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ThreadLocal解决什么问题"><a href="#ThreadLocal解决什么问题" class="headerlink" title="ThreadLocal解决什么问题"></a>ThreadLocal解决什么问题</h3><p><code>ThreadLocal</code>不是用来解决共享对象的多线程访问问题的，不同的<code>Thread</code>通过<code>ThreadLocal</code>获取到的是不同的副本（实际是不同的实例）。线程内部的副本是其他线程不需要访问也是访问不到的。当某一个类不是线程安全，同时该类的实例需要在多个方法中被使用且每个线程需要自己独立的实例时，可以使用<code>ThreadLocal</code>来解决这一问题。</p><h3 id="ThreadLocal实现原理"><a href="#ThreadLocal实现原理" class="headerlink" title="ThreadLocal实现原理"></a>ThreadLocal实现原理</h3><h4 id="错误方式"><a href="#错误方式" class="headerlink" title="错误方式"></a>错误方式</h4><p>既然每个Thread通过<code>ThreadLocal.get()</code>获得的都是自己的一个副本，一个通常的实现方法是<code>ThreadLocal</code>自己维护一个Map，key是Thread，value是该线程中的副本。线程通过<code>get()</code>获取实例时，可以以线程（通过<code>Thread.currentThread()获取当前线程</code>）为key，从Map中找出对应的实例即可。但是该实现方式存在以下问题：</p><ul><li>Map作为全局变量，增加或减少线程均需要写Map，需要通过加锁来确保Map的线程安全性</li><li>线程结束时，需要从该线程访问过的所有ThreadLocal中删除副本，否则可能会引起内存泄露</li></ul><h4 id="正确方式"><a href="#正确方式" class="headerlink" title="正确方式"></a>正确方式</h4><p>为了提高ThreadLocal效率，需要去掉锁机制。如果Thread维护一个自己的Map，该Map存储所有用到的本地副本，这样每个Thread只需要访问自己的Map，不存在写冲突，也就不需要锁了。</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/2184951-13b6596868c2dacd.png" alt="184951-13b6596868c2dac"></p><p>该方案虽然没有锁的问题，但是在每个线程内部都保存了该线程用到的本地副本。如果不删除这些引用，会导致这些副本无法被垃圾回收，造成内存泄露。</p><a id="more"></a><h3 id="ThreadLocal在JDK8中的实现"><a href="#ThreadLocal在JDK8中的实现" class="headerlink" title="ThreadLocal在JDK8中的实现"></a>ThreadLocal在JDK8中的实现</h3><h3 id="ThreadLocalMap类"><a href="#ThreadLocalMap类" class="headerlink" title="ThreadLocalMap类"></a>ThreadLocalMap类</h3><p>ThreadLocalMap是ThreadLocal的静态内部类，对ThreadLocal进行的get、set操作最后都将委托给该类。同时每个Thread内部都有一个ThreadLocalMap变量，用于保存本线程用到的副本。它的结构如下：</p><p><img src="http://7xs0vv.com1.z0.glb.clouddn.com/20180321162514.png" alt="018032116251"></p><p>可以看到ThreadLocalMap有一个常量和三个成员变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The initial capacity -- MUST be a power of two.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">       * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> Entry[] table;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The number of entries in the table.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The next size value at which to resize.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">int</span> threshold; <span class="comment">// Default to 0</span></span><br></pre></td></tr></table></figure><p>其中INITIAL_CAPACITY代表了这个Map的初始容量，即table的初始大小；table是一个Entry类型的数组，用于存储数据；size代表table中的存储数目；threshold代表需要扩容是对应size的阀值，默认为容量的2/3。</p><h4 id="Entry类"><a href="#Entry类" class="headerlink" title="Entry类"></a>Entry类</h4><p>Entry类是ThreadLocalMap的静态内部类，是线程本地副本真正保存的位置，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见Entry继承自<code>WeakReference&lt;ThreadLocal&lt;?&gt;&gt;</code>，即每个Entry对象都有一个ThreadLocal的弱引用。这样当线程结束，没有引用指向线程内部的ThreadLocalMap变量时，table数组可以被垃圾回收，如此便可以防止内存泄露。Object类型的成员变量value，指向Thread用到的ThreadLocal中的本地副本。</p><h4 id="ThreadLocal-set-方法"><a href="#ThreadLocal-set-方法" class="headerlink" title="ThreadLocal.set()方法"></a>ThreadLocal.set()方法</h4><p>设置实例的方法如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程首先通过<code>getMap(thread)</code>方法获取自身的ThreadLocalMap。因为ThreadLocalMap是线程私有的，只有该线程才能访问，其他线程访问不到，所有不用考虑线程安全问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从getMap源码中可见，该ThreadLocalMap的实例是Thread类的一个字段，即由ThreadLocal对象与具体实例的映射，这一点与上文分析一致。</p><p>获取到ThreadLocalMap后，若map为null，调用<code>createMap</code>方法来创建一个ThreadLocalMap，在createMap中调用ThreadLocalMap的构造函数，返回设置了首元素的ThreadLocalMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>firstKey</code>为当前调用的ThreadLocal，firstValue为<code>set(T value)</code>中的value。在构造函数中注意一个细节，计算下标i的时候采用了<code>hashcode &amp; (size - 1)</code>的算法，这相当于取模运算<code>hashCode % size</code>的一个更高效的实现。同时因为采用了该算法，size必须是2的指数，这可以使得hash发生冲突的次数减小。</p><p>若map不为null，则调用ThreadLocalMap的<code>set(ThreadLocal, Ojbect)</code>方法将实例设置到table数组中。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">         e != <span class="keyword">null</span>;</span><br><span class="line">         e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先计算该元素的hash值，如果冲突了，通过<code>nextIndex</code>方法再次计算hash值。<code>nextIndex</code>实际上获取数组的下一个下标，若已到数组最后一个元素则返回0，即返回到数组第一个元素。因此ThreadLocalMap解决冲突的方法是线性探测法。如果table中已经存在，则仅仅是更新Entry中的value值。如果entry里对应的key为null的话，表明该entry为<code>staled entry</code>，则调用<code>replaceStaleEntry</code>函数用于替换原有的key和value并进行一些清理操作(清理其他key为null的Entry防止内存泄露)，有兴趣的同学可以查看源码具体实现。若是经历了上面步骤没有命中hash，也没有发现无用的Entry，<code>set</code>方法就会创建一个新的Entry，并会进行<strong>启发式的垃圾清理</strong>，用于清理无用的Entry。主要通过<code>cleanSomeSlots</code>方法惊醒清理（清理时机通常为添加新元素或另一个无用的元素被回收时）。只要没有清理任何的stale entries并且size达到阀值的时候，就会触发<code>rehash</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use lower threshold for doubling to avoid hysteresis</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>rehash</code>会先调用<code>expungeStaleEntries</code>函数，执行一次全表扫描，用于删除无用的entry。清理之后的size仍大于等于threshold的3/4时进行<code>resize</code>扩容（长度增加一倍）。通过<code>replaceStaleEntry</code>和<code>rehash</code>这两个方法会即时将table中无效的entry设置为null，从而使得entry可被回收，有效的防止了内存泄露。</p><h4 id="ThreadLocal-get-方法"><a href="#ThreadLocal-get-方法" class="headerlink" title="ThreadLocal.get()方法"></a>ThreadLocal.get()方法</h4><p>获取实例的方法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同<code>set</code>方法，首先通过getMap方法获取线程内部的ThreadLocalMap对象。若map和entry都不为null，说明线程内部存在对应副本，直接返回即可。若不存在，调用<code>setInitialValue</code>方法获取该ThreadLocal变量在该线程中对应的具体实例的初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法为private方法，无法被重载。但是在方法中首先调用了<code>initialValue</code>方法来获取初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initialValue</code>方法是protected的，说明是用来被继承的。所以在使用ThreadLocal时通常会重载该方法。拿到该线程对应的ThreadLocalMap对象，如该对象不为null，则直接将该ThreadLocal对象与对应实例初始值的映射set到该map中，否则创建该map并将其添加其中。</p><p>若map存在，<code>get</code>操作最终会调用ThreadLocalMap的<code>getEntry</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hash以后如果是ThreadLocal对应的Entry就返回，否则调用<code>getEntryAfterMiss</code>方法，根据线性探测法继续查找，直到找到或对应entry为<code>null</code>，并返回。</p><h3 id="ThreadLocal-remove-方法"><a href="#ThreadLocal-remove-方法" class="headerlink" title="ThreadLocal.remove()方法"></a>ThreadLocal.remove()方法</h3><p>删除实例的方法如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ThreadLOcalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)&#123;</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理，<code>remove</code>方法也是先获取Thread中的ThreadLocalMap实例。若map不为null，这调用map的<code>remove</code>方法，从table中将entry删除。</p><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>ThreadLocal适用如下场景</p><ul><li>每个线程需要有自己单独的实例</li><li>实例需要在多个方法中共享</li></ul><h3 id="应用案例"><a href="#应用案例" class="headerlink" title="应用案例"></a>应用案例</h3><p>在Web中，通常使用Session在各个页面中传递信息。每个客户端对应于Web中的一个线程，需要保证线程有自己单独的Session实例；而线程内部的各方法又需要共享Session。如不使用ThreadLocal，其实现方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Web</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Session</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> string username;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        ....</span><br><span class="line">        <span class="comment">// get/set方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Session <span class="title">createSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Session();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> string <span class="title">getUsername</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> session.getUsername();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">(Session session)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> session.getAge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Entry会被清理的场景：</p><ul><li>Thread结束之后被垃圾回收处理</li><li>set一个变量时，发现staled entry。进行替换并清理</li><li>set一个变量时，<code>size</code>大于阀值时，调用<code>rehash</code>方法清理并扩容</li><li>调用<code>remove</code>方法时，删除该entry并清理发现的staled entry</li></ul><p>尽管采用了弱引用的ThreadLocalMap不会造成内存泄露，但是并不能保证staled entry被及时清理。因此我们在使用完ThreadLocal后最好还是<code>remove</code>一下（使用线程池时一定要即时<code>remove</code>，线程使用后归还给了线程池，并没有销毁），保证即时回收无用的Entry。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ThreadLocal解决什么问题&quot;&gt;&lt;a href=&quot;#ThreadLocal解决什么问题&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal解决什么问题&quot;&gt;&lt;/a&gt;ThreadLocal解决什么问题&lt;/h3&gt;&lt;p&gt;&lt;code&gt;ThreadLocal&lt;/code&gt;不是用来解决共享对象的多线程访问问题的，不同的&lt;code&gt;Thread&lt;/code&gt;通过&lt;code&gt;ThreadLocal&lt;/code&gt;获取到的是不同的副本（实际是不同的实例）。线程内部的副本是其他线程不需要访问也是访问不到的。当某一个类不是线程安全，同时该类的实例需要在多个方法中被使用且每个线程需要自己独立的实例时，可以使用&lt;code&gt;ThreadLocal&lt;/code&gt;来解决这一问题。&lt;/p&gt;&lt;h3 id=&quot;ThreadLocal实现原理&quot;&gt;&lt;a href=&quot;#ThreadLocal实现原理&quot; class=&quot;headerlink&quot; title=&quot;ThreadLocal实现原理&quot;&gt;&lt;/a&gt;ThreadLocal实现原理&lt;/h3&gt;&lt;h4 id=&quot;错误方式&quot;&gt;&lt;a href=&quot;#错误方式&quot; class=&quot;headerlink&quot; title=&quot;错误方式&quot;&gt;&lt;/a&gt;错误方式&lt;/h4&gt;&lt;p&gt;既然每个Thread通过&lt;code&gt;ThreadLocal.get()&lt;/code&gt;获得的都是自己的一个副本，一个通常的实现方法是&lt;code&gt;ThreadLocal&lt;/code&gt;自己维护一个Map，key是Thread，value是该线程中的副本。线程通过&lt;code&gt;get()&lt;/code&gt;获取实例时，可以以线程（通过&lt;code&gt;Thread.currentThread()获取当前线程&lt;/code&gt;）为key，从Map中找出对应的实例即可。但是该实现方式存在以下问题：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Map作为全局变量，增加或减少线程均需要写Map，需要通过加锁来确保Map的线程安全性&lt;/li&gt;&lt;li&gt;线程结束时，需要从该线程访问过的所有ThreadLocal中删除副本，否则可能会引起内存泄露&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;正确方式&quot;&gt;&lt;a href=&quot;#正确方式&quot; class=&quot;headerlink&quot; title=&quot;正确方式&quot;&gt;&lt;/a&gt;正确方式&lt;/h4&gt;&lt;p&gt;为了提高ThreadLocal效率，需要去掉锁机制。如果Thread维护一个自己的Map，该Map存储所有用到的本地副本，这样每个Thread只需要访问自己的Map，不存在写冲突，也就不需要锁了。&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;http://7xs0vv.com1.z0.glb.clouddn.com/2184951-13b6596868c2dacd.png&quot; alt=&quot;184951-13b6596868c2dac&quot;&gt;&lt;/p&gt;&lt;p&gt;该方案虽然没有锁的问题，但是在每个线程内部都保存了该线程用到的本地副本。如果不删除这些引用，会导致这些副本无法被垃圾回收，造成内存泄露。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://windylee.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://windylee.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python中的functools模块</title>
    <link href="http://windylee.cn/posts/f6b0a560/"/>
    <id>http://windylee.cn/posts/f6b0a560/</id>
    <published>2018-03-22T01:22:20.000Z</published>
    <updated>2018-03-22T02:12:59.294Z</updated>
    
    <content type="html"><![CDATA[<h3 id="functools-partial-func-args-keywords"><a href="#functools-partial-func-args-keywords" class="headerlink" title="functools.partial(func[, *args][, **keywords])"></a><strong>functools.partial(func[, *args][, **keywords])</strong></h3><p>该函数通过包装手法，允许我们”重新定义”函数。返回用args和keywords填充了func指定位置参数后的函数，调用该函数只需传入原函数未填充的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">basetwo = partial(int, base=<span class="number">2</span>)</span><br><span class="line">basetwo(<span class="string">'10010'</span>)</span><br></pre></td></tr></table></figure><p>basetwo(‘10010’)实际上等价于调用int(‘10010’, base=2)</p><h3 id="functools-singledispatch"><a href="#functools-singledispatch" class="headerlink" title="@functools.singledispatch"></a>@functools.singledispatch</h3><p>使用过面向对象语言的同学，肯定熟悉各种方法的重载。虽然Python不支持方法重载的，但是我们可以添加@functools.singledispatch注解来动态指定相应的方法所接收的参数类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> singledispatch</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestClass</span><span class="params">(object)</span>:</span></span><br><span class="line"><span class="meta">  @singledispatch</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">test_method</span><span class="params">(arg, verbose=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> verbose:</span><br><span class="line">      print(<span class="string">'Let me just say,'</span>, end=<span class="string">' '</span>)</span><br><span class="line">    print(arg)</span><br><span class="line"><span class="meta">  @test_method.register(int)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'Strength in numbers, eh?'</span>, end=<span class="string">' '</span>)</span><br><span class="line"><span class="meta">  @test_method.register(list)</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_</span><span class="params">(arg)</span>:</span></span><br><span class="line">    print(<span class="string">'Enumerate this:'</span>)</span><br></pre></td></tr></table></figure><p>通过@test_method.register(int)和@test_method.register(list)指定当test_method的第一个参数为int或者list的时候，分别调用不同的方法来进行处理。</p><h3 id="functools-update-wrapper-wrapper-wrapped"><a href="#functools-update-wrapper-wrapper-wrapped" class="headerlink" title="functools.update_wrapper(**wrapper, wrapped)"></a><strong>functools.update_wrapper(**wrapper, wrapped)</strong></h3><p>默认partial对象没有<code>__name__</code>和<code>__doc__</code>，这种情况下，对于装饰器函数非常难以debug。使用该函数可以将被封装函数的这些属性复制到封装函数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">    print(<span class="string">'print in wrapper'</span>)</span><br><span class="line">    <span class="keyword">return</span> f(*args, **kwds)</span><br><span class="line">  <span class="keyword">return</span> update_wrapper(wrapper, f)</span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'print in example'</span>)</span><br></pre></td></tr></table></figure><h3 id="functools-wraps"><a href="#functools-wraps" class="headerlink" title="@functools.wraps"></a>@functools.wraps</h3><p>该注释内部调用了<code>functools.update_wrapper()</code>函数，简化编码复杂度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> warps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_decorator</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @warps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwds)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'print in wrapper'</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwds)</span><br><span class="line">   <span class="keyword">return</span> wrapper</span><br><span class="line"><span class="meta">@my_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">example</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'print in example'</span></span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="functools-lru-cache-maxsize-None-typed-False"><a href="#functools-lru-cache-maxsize-None-typed-False" class="headerlink" title="@functools.lru_cache(maxsize=None, typed=False)"></a>@functools.lru_cache(maxsize=None, typed=False)</h3><p>@lru_cache用于缓存函数返回的结果，对于重复的调用直接从缓存中获取返回值。如果maxsize设置为None，则缓存没有上界。如果typed设置为true，则对于不同的参数类型会区别缓存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"><span class="meta">@luc_cache(None)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    print(<span class="string">'calculating: %s + %s'</span> % (x, y))</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(add(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line">print(add(<span class="number">2</span>, <span class="number">3</span>))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">calculating: <span class="number">1</span> + <span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line">calculating: <span class="number">2</span> + <span class="number">3</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure><h3 id="functools-total-ordering"><a href="#functools-total-ordering" class="headerlink" title="@functools.total_ordering"></a>@functools.total_ordering</h3><p>这是一个类装饰器，用于自动实现类的比较运算。若自定义类中实现了<code>__eq__</code>和<code>__lt__</code>、<code>__gt__</code>、<code>__ne__</code>、<code>__le__</code>、<code>__ge__</code>中的一个，带有@total_ordering装饰的类会自动实现剩下的函数 。</p><h4 id="functools-cmp-to-key-func"><a href="#functools-cmp-to-key-func" class="headerlink" title="functools.cmp_to_key(func)"></a><strong>functools.cmp_to_key(func)</strong></h4><p>该函数用于将旧式的比较函数转化为key(关键值)函数并应用于接受key function的工具类中(sorted(), min(), max(), heapq.nsamllest(), heapq.nlargest(), itertools,groupby())</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> cmp_to_key</span><br><span class="line">sorted(iterable, key=cmp_to_key(cmp_func))</span><br></pre></td></tr></table></figure><h3 id="functools-reduce-func-iterable-initializer"><a href="#functools-reduce-func-iterable-initializer" class="headerlink" title="functools.reduce(func, iterable, [, initializer])"></a><strong>functools.reduce(func, iterable, [, initializer])</strong></h3><p>与python2中的内建函数reduce等价</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;functools-partial-func-args-keywords&quot;&gt;&lt;a href=&quot;#functools-partial-func-args-keywords&quot; class=&quot;headerlink&quot; title=&quot;functools.partial(func[, *args][, **keywords])&quot;&gt;&lt;/a&gt;&lt;strong&gt;functools.partial(func[, *args][, **keywords])&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;该函数通过包装手法，允许我们”重新定义”函数。返回用args和keywords填充了func指定位置参数后的函数，调用该函数只需传入原函数未填充的参数。&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; partial&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;basetwo = partial(int, base=&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;basetwo(&lt;span class=&quot;string&quot;&gt;&#39;10010&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;basetwo(‘10010’)实际上等价于调用int(‘10010’, base=2)&lt;/p&gt;&lt;h3 id=&quot;functools-singledispatch&quot;&gt;&lt;a href=&quot;#functools-singledispatch&quot; class=&quot;headerlink&quot; title=&quot;@functools.singledispatch&quot;&gt;&lt;/a&gt;@functools.singledispatch&lt;/h3&gt;&lt;p&gt;使用过面向对象语言的同学，肯定熟悉各种方法的重载。虽然Python不支持方法重载的，但是我们可以添加@functools.singledispatch注解来动态指定相应的方法所接收的参数类型。&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; singledispatch&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;TestClass&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;  @singledispatch&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;test_method&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg, verbose=False)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; verbose:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      print(&lt;span class=&quot;string&quot;&gt;&#39;Let me just say,&#39;&lt;/span&gt;, end=&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(arg)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;  @test_method.register(int)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Strength in numbers, eh?&#39;&lt;/span&gt;, end=&lt;span class=&quot;string&quot;&gt;&#39; &#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;  @test_method.register(list)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(arg)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;Enumerate this:&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;通过@test_method.register(int)和@test_method.register(list)指定当test_method的第一个参数为int或者list的时候，分别调用不同的方法来进行处理。&lt;/p&gt;&lt;h3 id=&quot;functools-update-wrapper-wrapper-wrapped&quot;&gt;&lt;a href=&quot;#functools-update-wrapper-wrapper-wrapped&quot; class=&quot;headerlink&quot; title=&quot;functools.update_wrapper(**wrapper, wrapped)&quot;&gt;&lt;/a&gt;&lt;strong&gt;functools.update_wrapper(**wrapper, wrapped)&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;默认partial对象没有&lt;code&gt;__name__&lt;/code&gt;和&lt;code&gt;__doc__&lt;/code&gt;，这种情况下，对于装饰器函数非常难以debug。使用该函数可以将被封装函数的这些属性复制到封装函数中。&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;my_decorator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(f)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(*args, **kwds)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;print in wrapper&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f(*args, **kwds)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; update_wrapper(wrapper, f)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@my_decorator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&#39;print in example&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h3 id=&quot;functools-wraps&quot;&gt;&lt;a href=&quot;#functools-wraps&quot; class=&quot;headerlink&quot; title=&quot;@functools.wraps&quot;&gt;&lt;/a&gt;@functools.wraps&lt;/h3&gt;&lt;p&gt;该注释内部调用了&lt;code&gt;functools.update_wrapper()&lt;/code&gt;函数，简化编码复杂度。&lt;/p&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; functools &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; warps&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;my_decorator&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(f)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @warps(f)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(*args, **kwds)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;print in wrapper&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; f(*args, **kwds)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   	&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; wrapper&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;@my_decorator&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;example&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&#39;print in example&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Python" scheme="http://windylee.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://windylee.cn/tags/Python/"/>
    
      <category term="标准库" scheme="http://windylee.cn/tags/%E6%A0%87%E5%87%86%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Git简明教程</title>
    <link href="http://windylee.cn/posts/6326f1e4/"/>
    <id>http://windylee.cn/posts/6326f1e4/</id>
    <published>2018-03-10T14:29:11.000Z</published>
    <updated>2018-03-10T14:32:23.577Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h3><p>Git是目前世界上最先进的分布式版本控制系统。在Git出现之前，版本控制系统主要是集中式占据着绝对的统治地位，以CVS和SVN为代表。集中式版本控制系统中版本库集中存放在中央服务器，写代码的时候我们要先从中央服务器拉取最新版本，开发完成之后再讲版本推送到中央服务器，这就意味着必须联网才能工作，也存在代码丢失的风险。分布式版本控制系统去掉了中央服务器的概念，每个开发人员本地都有一份完整的版本库，在没有网络时也能进行开发工作。虽然分布式版本控制系统中去掉了中央服务器，但是为了协同开发人员之间的工作，通常会有一台充当“中央服务器”的电脑。如果不想搭建自己的gitlab服务器，可以选择第三方代码仓库，如github、coding.net、git.oschina等。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>因为Git是分布式版本控制系统，在将代码push到远程仓库时，需要告诉仓库提交者的身份。所以在安装完Git之后需要进一步配置，在命令行输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git config --global user.name "Your Name"</span><br><span class="line"><span class="meta">$</span> git config --global user.email "email@example.com"</span><br></pre></td></tr></table></figure><p>注意<code>git config</code>命令的<code>--global</code>参数表示本机中的所有Git仓库都会使用这个配置，若想只针对当前仓库进行配置可以去掉<code>--global</code>参数。</p><a id="more"></a><h3 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a>版本库</h3><h4 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h4><p>版本库又叫仓库，可以简单的理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除Git都能跟踪，以便在将来的某个时候将文件还原回之前的版本。创建版本库时，首先将路径切换到目标目录，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git init</span><br><span class="line">Initialized empty Git repository in C:/Users/windylee/Desktop/repository/.git/</span><br></pre></td></tr></table></figure><p>这时该目录就会成为Git的一个本地仓库。这是在当前目录下就会多一个<code>.git</code>的目录，这个目录就是Git用来跟踪管理版本库的，千万不要手动修改这个目录里面的文件。</p><h4 id="将文件添加到版本库"><a href="#将文件添加到版本库" class="headerlink" title="将文件添加到版本库"></a>将文件添加到版本库</h4><p>Git只能跟踪文本文件的改动，比如txt、网页、程序代码等等，二进制文件虽然也能有Git管理，但是不能跟踪文件的变化。进入我们的本地仓库，创建一个<code>readme.txt</code>文件，在里面随便写点内容保存。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git add readme.txt</span><br></pre></td></tr></table></figure><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git commit -m "write a readme.txt file"</span><br><span class="line">[master (root-commit) 096895b] write a readme.txt file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br></pre></td></tr></table></figure><p><code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，但最好可以描述本次修改的内容，引文输入说明对自己对别人阅读都很重要。<code>commit</code>命令输出：第一行给出了本次commit的hash值，剩下的内容描述本次修改的内容（修改了1个文件，在该文件中插入了两行）。</p><p>如果本次修改文件过多，不想一个个add文件，可以通过命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git add --all</span><br></pre></td></tr></table></figure><p>这条命令会将所有修改的文件一次全部添加到仓库。</p><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><h4 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use "git add &lt;file&gt;..." to update what will be committed)</span><br><span class="line">  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">        modified:   readme.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use "git add" and/or "git commit -a")</span><br></pre></td></tr></table></figure><p>通过<code>git status</code>命令我们可以时刻掌握仓库的当前状态，上面的命令告诉我们readme.txt文件被修改过了，但是还没有添加到仓库。在每次执行Git命令前运行该命令是一个较好的习惯。</p><p>如果修改内容过多，时间长了我们就不知道修改了文件的哪些内容。这是可以通过<code>git diff</code>命令来查看文件修改的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git diff readme.txt</span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index 8f6e0fc..9468d46 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line"> Git is a version control system</span><br><span class="line">+happy coding.</span><br></pre></td></tr></table></figure><p>显示的内容是本地文件与版本库中文件的difference，显示的格式正是Unix通用的diff格式。</p><h4 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log</span><br><span class="line">commit 3703210c919521c63f457341419b6daa3f38083f</span><br><span class="line">Author: windylee &lt;liwangadd@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 12 13:52:29 2018 +0800</span><br><span class="line"></span><br><span class="line">    add happy coding line</span><br><span class="line"></span><br><span class="line">commit 096895bbf40546221e12c16a4ea1a77d6565b16e</span><br><span class="line">Author: windylee &lt;liwangadd@gmail.com&gt;</span><br><span class="line">Date:   Fri Jan 12 13:32:28 2018 +0800</span><br><span class="line"></span><br><span class="line">    write a readme.txt file</span><br></pre></td></tr></table></figure><p><code>git log</code>命令显示从最近到最远的提交日志，可以看到我们总共有两次提交。如果嫌输出信息太多，可以加上<code>--pretty=oneline</code>参数，一次提交日志就会在一行显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git log --pretty=oneline</span><br><span class="line">3703210c919521c63f457341419b6daa3f38083f add happy coding line</span><br><span class="line">096895bbf40546221e12c16a4ea1a77d6565b16e write a readme.txt file</span><br></pre></td></tr></table></figure><p>如果我们想返回上一个版本，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>若要返回上一个版本，首先要先知道当前版本是哪个版本。在Git中，用<code>HEAD</code>表示当前版本，上一个版本就是<code>HEAD^</code>，上上个版本就是<code>HEAD^^</code>。如果要返回上100各版本怎么办，由于每次commit都会产生一个hash值作为本次提交的唯一标识，可以将<code>HEAD^</code>换成会返回版本的hash值(取前7位即可)。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard 3703210</span><br></pre></td></tr></table></figure><h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a>暂存区</h4><p>创建仓库之后，目录中会多出<code>.git</code>目录。该目录就是Git的版本库，其中包括成为stage的暂存区，还有自动创建的master分支以及指向master的HEAD指针。在执行<code>git add</code>命令时，是将文件修改添加到暂存区，执行<code>git commit</code>命令则是将暂存区中的内容提交到当前分支并将暂存区清空。</p><h4 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout --readme.txt</span><br></pre></td></tr></table></figure><p>命令<code>git checkout -- filename</code>会把文件在工作区的修改全部撤销，若文件修改后还没有添加到暂存区，撤销修改就回到和版本库一样的状态；若文件已经添加到暂存区，之后又做了修改，撤销修改就回到添加到暂存区后的状态。</p><p>若文件修改已添加到暂存区，而要删除暂存区中的文件修改内容。可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git reset HEAD readme.txt</span><br></pre></td></tr></table></figure><p>该命令可以把暂存区的修改撤销掉，重新放回工作区。</p><h4 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h4><p>在Git中，删除也是一种修改操作。可以直接在文件管理器中将文件删除，这时工作区和版本库就不一致了。可以选择从版本库中删除该文件，使用<code>git rm</code>将文件从版本库删除掉，并且<code>git commit</code>。或者是误删，这是可以将文件从版本库中回复到最新版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- readme.txt</span><br></pre></td></tr></table></figure><p><code>git checkout</code>是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p><h3 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h3><h4 id="添加远程仓库"><a href="#添加远程仓库" class="headerlink" title="添加远程仓库"></a>添加远程仓库</h4><p>在我们开发时，通常将代码托管到github上。这样，github上的仓库既可以作为备份，又可以让其他人通过该仓库来协作。在github上创建一个新仓库之后，在本地仓库下运行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git remote add origin git@github.com:liwangadd/repository.git</span><br></pre></td></tr></table></figure><p>这是本地仓库就将github上的相应仓库作为托管平台。下一步就可以把本地库的所有内容推送到远程库上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git push -u origin master</span><br></pre></td></tr></table></figure><p>由于远程仓库是空的，我们第一次推送master分支时，加上<code>-u</code>参数。Git不但会把本地的master分支内容推送到远程新的master分支，还会把本地的master分支和远程的master分支关联起来。</p><h4 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h4><p>进入到我们想要克隆到本地的项目主页，获取到仓库地址。使用如下命令将远程仓库clone到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git clone https://github.com/yaochenkun/aiop-notice.git</span><br></pre></td></tr></table></figure><p>如果有多个人协作开发，那么每个人各自从远程clone一份就可以了。</p><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><h4 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h4><p>创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git checkout -b dev</span><br><span class="line">Switched to a new branch 'dev'</span><br></pre></td></tr></table></figure><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换分支，相当于以下两条命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch dev</span><br><span class="line"><span class="meta">$</span> git checkout dev</span><br><span class="line">Switched to a new branch 'dev'</span><br></pre></td></tr></table></figure><p>然后就可以用<code>git branch</code>命令查看当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号</p><p><code>git merge</code>命令用于合并指定分支到当前分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git merge dev</span><br><span class="line">Updating d17efd8..fec145a</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt |    1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是”快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交。但是在这种模式下，删除分之后，会丢掉分支信息。如果强制禁用<code>Fast-forward</code>模式，Git就会在merge时生成一个新的commit，这样从分支历史上就可以看出分支信息。强制禁用<code>Fast-forward</code>模式，可以使用<code>--no-off</code>参数，因为合并会创建一个新的commit，所有加上<code>-m</code>参数，把commit描述写进去。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git merge --no-ff -m "merge with no-ff" dev</span><br></pre></td></tr></table></figure><p>分支合并完成后，如果dev分支不需要了，可以将该分支删除:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><p>因为创建、合并和删除分支非常快，所以当我们要完成某个任务时，可以先创建分支，在新的分支上开发完成再合并到主分支。</p><h4 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h4><p>若当前正在dev分支上进行工作，需要切换到其他分支工作，而dev分支上的任务还没有完成，不能提交到暂存区。这时可以使用<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git stash</span><br><span class="line">Saved working directory and index state WIP on dev: 3703210 add happy coding line</span><br><span class="line">HEAD is now at 3703210 add happy coding line</span><br></pre></td></tr></table></figure><p>这是就可以切换到其他分支进行工作了，工作完成回到该分支，可以使用<code>git stash list</code>命令查看工作现场。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: 3703210 add happy coding line</span><br></pre></td></tr></table></figure><p>可以看到，工作现场还在。Git把stash内容存在了某个地方了，若要将stash的内容恢复到工作区，有两个办法：</p><ul><li>用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，需要用<code>git stash drop</code>来删除</li><li>用<code>git stash pop</code>，恢复的同时把stash内容删了</li></ul><p>若执行了多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure><h4 id="强行删除分支"><a href="#强行删除分支" class="headerlink" title="强行删除分支"></a>强行删除分支</h4><p>如分支没有合并，使用<code>git branch -d dev</code>命令会提示分支没有合并，删除失败。如果要强行删除，需要使用命令<code>git branch -D dev</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git branch -D dev</span><br><span class="line">Deleted branch dev (was 3703210).</span><br></pre></td></tr></table></figure><h4 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013760174128707b935b0be6fc4fc6ace66c4f15618f8d000" target="_blank" rel="noopener">多人协作</a></h4><h3 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h3><p>发布一个版本时，我们通常现在版本库中打一个标签，这样唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以标签也是版本库的一个快照，其实就是指向某个commit的指针。由于commit给出的是一个hash值，不好记忆，所以才引入了标签这个概念。</p><h4 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h4><p>使用<code>git tag &lt;name&gt;</code>命令可以打一个标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> git tag v1.0</span><br></pre></td></tr></table></figure><p>可以用命令<code>git tag</code>查看所有标签。默认标签是打在最新提交的commit上的，若想打在之前某个commit上面，就需要根据历史提交的commit id打标签：</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Git简介&quot;&gt;&lt;a href=&quot;#Git简介&quot; class=&quot;headerlink&quot; title=&quot;Git简介&quot;&gt;&lt;/a&gt;Git简介&lt;/h3&gt;&lt;p&gt;Git是目前世界上最先进的分布式版本控制系统。在Git出现之前，版本控制系统主要是集中式占据着绝对的统治地位，以CVS和SVN为代表。集中式版本控制系统中版本库集中存放在中央服务器，写代码的时候我们要先从中央服务器拉取最新版本，开发完成之后再讲版本推送到中央服务器，这就意味着必须联网才能工作，也存在代码丢失的风险。分布式版本控制系统去掉了中央服务器的概念，每个开发人员本地都有一份完整的版本库，在没有网络时也能进行开发工作。虽然分布式版本控制系统中去掉了中央服务器，但是为了协同开发人员之间的工作，通常会有一台充当“中央服务器”的电脑。如果不想搭建自己的gitlab服务器，可以选择第三方代码仓库，如github、coding.net、git.oschina等。&lt;/p&gt;&lt;h3 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h3&gt;&lt;p&gt;因为Git是分布式版本控制系统，在将代码push到远程仓库时，需要告诉仓库提交者的身份。所以在安装完Git之后需要进一步配置，在命令行输入：&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; git config --global user.name &quot;Your Name&quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;$&lt;/span&gt; git config --global user.email &quot;email@example.com&quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;注意&lt;code&gt;git config&lt;/code&gt;命令的&lt;code&gt;--global&lt;/code&gt;参数表示本机中的所有Git仓库都会使用这个配置，若想只针对当前仓库进行配置可以去掉&lt;code&gt;--global&lt;/code&gt;参数。&lt;/p&gt;
    
    </summary>
    
      <category term="Tools" scheme="http://windylee.cn/categories/Tools/"/>
    
    
      <category term="Tools" scheme="http://windylee.cn/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>Nginx入门教程</title>
    <link href="http://windylee.cn/posts/750751bd/"/>
    <id>http://windylee.cn/posts/750751bd/</id>
    <published>2018-02-20T14:58:46.000Z</published>
    <updated>2018-02-21T16:28:25.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Nginx是一个开源、高性能的HTTP服务器和反向代理服务器，还可以用来作为IMAP/POP3的代理服务器，其处理静态文件、索引文件的效率非常高。相比于apache的多进程多线程的并发模型，Nginx是基于事件的异步IO的并发模型，支持epoll/kqueue等网络IO模型。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装Nginx主要有两种方式，通过仓库中的二级制包安装和源码安装。在Ubuntu系统中可以通过<code>sudo apt-get install nginx</code>从官方仓库中安装，这种安装方式可以满足用户的基本需求。但如果对Nginx的精简度和性能有非常高的要求，就需要通过源码的方式安装，分为以下三步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>如果要对Nginx进行定制，就需要在第一步制定需求，主要参数如下：</p><ul><li>–conf-path 指定配置文件的位置，默认为/etc/nginx/nginx.conf</li><li>–error-log-path 指定错误日志文件所在位置，默认为/var/log/nginx/error.log,安装完成后可在配置文件中进行配置</li><li>–http-log-path 指定http连接日志文件所在位置，默认为/var/log/nginx/access.log</li><li>–with-模块名称 该模块会被编译</li><li>–without-模块名称 编译时将该模块排除在外</li></ul><a id="more"></a><p>源码安装完成之后，默认Nginx服务已经启动。若想手动启动Nginx服务可以通过<code>sudo service nginx start</code>,同理关闭或者重启可以通过<code>sudo service nginx stop/restart</code>。 虽然Nginx重启速度很快，但是每次修改配置文件后，仅仅想让配置文件生效可以通过<code>sudo nginx -s reload</code> 命令，而不用重启服务</p><h4 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h4><p>Nginx是模块化的系统，整个系统被分成一个个的模块，每个模块负责不同的功能。例如http_gzip_static_module是负责压缩的，http_ssl_module是负责加密的。如果想使用某个模块需要在编译时将其加入其中，使用被编译的模块需要通过指令，整个配置文件就是通过指令组成的。默认的配置文件位于<code>/etc/nginx/nginx.conf</code>，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes 1;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections 768;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">  sendfile on;</span><br><span class="line">  tcp_nopush on;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">  include /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">  access_log /var/log/nginx/access.log;</span><br><span class="line">  error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">  gzip on;</span><br><span class="line">  gzip_disable "msie6";</span><br><span class="line"></span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">  include /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，配置文件主要由两个block组成。Nginx是存在三个顶级block的，分别是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">&#125;</span><br><span class="line">mail&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从配置文件中可以看出：events模块中包含nginx中所有处理连接的设置，可以通过worker_connections指定每个工作进程可以同时接受的最大连接数；http模块主要是用来配置web服务，可以用于指定是否启用压缩，是否支持发送文件等；mail模块用来配置IMAP/POP3代理。我们主要关注http模块，如果Nginx的配置文件过大，将全部配置写在同一文件中将难以维护，此时可以将不同用途的配置写在不同的配置文件中，通过include指令加载进来。</p><p>如果想要部署一个网站，就需要在http模块中添加一个server块。下面看一个例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen80;</span><br><span class="line">  server_name example.org www.example.org;</span><br><span class="line">  root/usr/nginx/www;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">        indexindex.html index.php;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  location ^~ /images/ &#123;</span><br><span class="line">        index icon.html;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(gif|jpg|png)$ &#123;</span><br><span class="line">        expires 30d;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  error_page 500 502 503 /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在电脑中的hosts文件中，加入一行<code>127.0.0.1 www.example.org</code>，在浏览器中输入<a href="http://www.example.org就可以访问了。该配置中通过listen表明监听80端口，通过server_name指定网站的域名，通过root指定网站的根目录，最下面的error_page说明当服务器发生500、502、503错误时，将网站根目录下的50x.html返回给用户。" target="_blank" rel="noopener">www.example.org就可以访问了。该配置中通过listen表明监听80端口，通过server_name指定网站的域名，通过root指定网站的根目录，最下面的error_page说明当服务器发生500、502、503错误时，将网站根目录下的50x.html返回给用户。</a></p><p>下面我们主要关注location指令，location用于URL模式设置，可以看到在匹配的URL开头有一些特殊符号，不同的符号用于限定在匹配时采用的特殊规则：</p><ul><li>=开头表示精确匹配，与指定字符串有任何区别将不能匹配成功</li><li>^~开头表示匹配以指定字符串开头的URL，不适用正则</li><li>~开头表示区分大小写的正则匹配</li><li>~*开头表示不区分大小写的正则匹配</li><li>/通用匹配，如果所有匹配都失败，则返回该默认匹配</li></ul><p>各种匹配的优先级为：(=) &gt; (完整路径) &gt; (^~) &gt; (~, ~*) &gt; (location 部分起始路径) &gt; (/)。</p><p>在上面的配置文件中的<code>$</code>符号是正则表达式中的结束标志。在最后一个location中有expires指令，该指令的作用是让Nginx缓存请求返回的信息(这里是图片静态文件)，缓存的有效期的30天。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>代理可以分问正向代理和反向代理。正向代理的步骤是：用户要访问服务器C，而用户的请求会先到达代理服务器B，然后B再将用户请求转发到服务器C，此时代理服务器B才是真正访问服务器C的，代理服务器B再将得到的结果转发给用户。在这个过程中用户就像直接访问服务器C一样，过程中不知道代理服务器的存在。而反响代理的步骤是：用户只知道代理服务器的地址，通过该地址直接访问代理服务器B，代理服务器B将请求转发给真正的服务提供者C，得到结果后再返回给用户。用户根本不知道服务提供者的地址或者完全不能访问到，整个过程用户是直接与代理服务器B交互的。反向代理可以用来隐藏和保护原始服务器，实现负载均衡，加密和SSL加速等。</p><p>Nginx的反向代理是通过ngx_http_proxy_module这个模块实现的，nginx可以代理的协议有http(s)、fastcgi、uswgi、memcached等。下面是实现的一个简单代理服务器的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">http&#123;</span><br><span class="line">  ....</span><br><span class="line">  upstream java_demo&#123;</span><br><span class="line">      # 实际服务器的地址</span><br><span class="line">      server 127.0.0.1:8080;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line">    listen       443;</span><br><span class="line">    proxy_connect_timeout 180; # nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">    proxy_send_timeout 180; </span><br><span class="line">    proxy_read_timeout 180; # 连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Forwarder-For $remote_addr;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">      # 将请求转发到实际服务提供者</span><br><span class="line">      proxy_pass http://java_demo;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h4><p>当css文件和js文件过大时，可以通过压缩的机制提高网站的加载速度。Nginx通过ngx_http_gzip_module模块实现对文件的压缩操作，启用压缩要在配置文件中指定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">http &#123;</span><br><span class="line">        gzip on;</span><br><span class="line">        gzip_disable "msie6";</span><br><span class="line">        # gzip_vary on;</span><br><span class="line">        # gzip_proxied any;</span><br><span class="line">        # gzip_comp_level 6;</span><br><span class="line">        # gzip_buffers 16 8k;</span><br><span class="line">        # gzip_http_version 1.1;</span><br><span class="line">        gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">        server &#123;</span><br><span class="line">                location ~ ^/assets/ &#123;</span><br><span class="line">                   gzip_static on;</span><br><span class="line">                   expires max;</span><br><span class="line">                   add_header Cache-Control public;</span><br><span class="line">                &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gzip指令来启用gzip压缩功能，使用gzip_types限制了要压缩的文件类型。这两个属性时必须配置的，其他属性根据需要进行配置。同时需要在要启用压缩的location块中加入配置文件中的那三行。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>听说过nginx的人肯定都知道其在负载均衡中的重要角色，几乎成熟的网站都会使用nginx作为负载均衡服务器。同时nginx也在不断发展，在1.9版本之前其只能作为http的负载均衡，而在1.9之后其也实现了对tcp进行负载均衡。nginx负载均衡模块实现了如下4种调度方式：</p><ol><li><p>round-robin：Nginx默认的轮询算法，每个请求按时间顺序逐一分配到不同的后端服务器。可以通过weight指定轮询权值，权值越大表明被访问到的可能性越大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  server 127.0.0.1:8080 weight=2;</span><br><span class="line">  server 127.0.0.1:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>least_conn：请求会被发送到活跃连接数最少的服务器上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  least_conn;</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>ip_hash：根据访问用户ip的hash结果分配请求，相同的ip总是会被分配到同一台应用服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>hash：相比于ip_hash方式，这是一个粒度更小的控制，ip_hash默认是用户ip的hash值。而该方式根据指定字段的hash值进行分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  hash $request_uri; # 根据请求地址分配</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx对负载均衡提供了很好的支持，相对于反向代理，我们只需在upstream块中添加多个server地址和指定负载均衡算法，nginx就可以根据我们指定的负载均衡算法分发用户请求。</p><p>在配置负载均衡时，upstream块中的server可以有如下配置参数</p><ul><li>down。加入该字段的server将暂时不参与负载均衡，对该服务器的请求会自动发送到下一个服务器。</li><li>backup。预留的备份服务器，当其他所有的非backup都出现故障或者忙的时候，才会将请求发送到该服务器。</li><li>weight。指定该服务器被访问到的概率，值越大被访问到的概率越高，默认weight的权值为1。</li><li>max_fails。表示请求失败的次数，若某一服务器对同一请求失败超过max_fails次，则将该请求发送到下一服务器。</li><li>max_timeout。表示请求失败的超时时间，在设定的时间内没有成功，就作为失败处理。</li></ul></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Nginx是一个开源、高性能的HTTP服务器和反向代理服务器，还可以用来作为IMAP/POP3的代理服务器，其处理静态文件、索引文件的效率非常高。相比于apache的多进程多线程的并发模型，Nginx是基于事件的异步IO的并发模型，支持epoll/kqueue等网络IO模型。&lt;/p&gt;&lt;h3 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h3&gt;&lt;p&gt;安装Nginx主要有两种方式，通过仓库中的二级制包安装和源码安装。在Ubuntu系统中可以通过&lt;code&gt;sudo apt-get install nginx&lt;/code&gt;从官方仓库中安装，这种安装方式可以满足用户的基本需求。但如果对Nginx的精简度和性能有非常高的要求，就需要通过源码的方式安装，分为以下三步：&lt;/p&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;./configure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;make&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo make install&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;如果要对Nginx进行定制，就需要在第一步制定需求，主要参数如下：&lt;/p&gt;&lt;ul&gt;&lt;li&gt;–conf-path 指定配置文件的位置，默认为/etc/nginx/nginx.conf&lt;/li&gt;&lt;li&gt;–error-log-path 指定错误日志文件所在位置，默认为/var/log/nginx/error.log,安装完成后可在配置文件中进行配置&lt;/li&gt;&lt;li&gt;–http-log-path 指定http连接日志文件所在位置，默认为/var/log/nginx/access.log&lt;/li&gt;&lt;li&gt;–with-模块名称 该模块会被编译&lt;/li&gt;&lt;li&gt;–without-模块名称 编译时将该模块排除在外&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://windylee.cn/categories/Java-Web/"/>
    
    
      <category term="nginx" scheme="http://windylee.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>Spring定时任务</title>
    <link href="http://windylee.cn/posts/4016a806/"/>
    <id>http://windylee.cn/posts/4016a806/</id>
    <published>2018-02-20T14:53:46.000Z</published>
    <updated>2018-02-21T16:28:25.430Z</updated>
    
    <content type="html"><![CDATA[<p>关于spring的定时任务，我们在spring3.0之前一般会使用Quartz，这是一个功能相当强大的调度器，可以让你的程序在指定时间执行，也可以按照某个频度执行，但是配置起来稍显复杂。Spring3.0以后自带task，可以将它看成一个轻量级的Quartz，使用起来比Quartz简单许多，不需要额外的包，而且支持注解和配置文件两种形式。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h5><p>首先需要在配置文件中引入task命名空间<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span></span></span><br><span class="line"><span class="tag">    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span>/<span class="attr">spring-task.xsd</span>"&gt;</span></span><br></pre></td></tr></table></figure><p></p><p>然后配置需要定时执行的任务<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring定时器注解开关，注册之后可以再java类中使用task命名空间的注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--内部使用的线程池，配置线程池，指定线程池的大小--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">   &lt;!--配置定时任务，指定需要定时执行的类和方法，并配置调度方式--&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">   &lt;task:scheduled-task scheduler="</span><span class="attr">myScheduler</span>"&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"scheduledTaskManager"</span> <span class="attr">method</span>=<span class="string">"autoCardCalculate"</span> <span class="attr">cron</span>=<span class="string">"0 5 * * * *"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">task:scheduled-task</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h5 id="注解形式"><a href="#注解形式" class="headerlink" title="注解形式"></a>注解形式</h5><p>首先我们看一下源码中注解的定义<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Schedules.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled &#123;</span><br><span class="line">    <span class="function">String <span class="title">cron</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">zone</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fixedDelay</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">fixedDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fixedRate</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">fixedRateString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">initialDelay</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">initialDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们可以看到该注解有八个参数，分别表示的意思是：<br>cron：指定cron表达式<br>zone：指定时区<br>fixedRate：从上一个任务开始到下一个任务开始的间隔，单位是毫秒<br>fixedDelay：从上一个任务完成到下一个任务开始的间隔，单位是毫秒<br>initialDelay：任务第一次执行前需要延迟的毫秒数<br>这些配置参数都可以在xml配置文件中使用，效果是一样的</p><h5 id="执行任务的POJO类"><a href="#执行任务的POJO类" class="headerlink" title="执行任务的POJO类"></a>执行任务的POJO类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTaskManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每日凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 2 * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoCardCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳更新，启动时执行一次，之后每隔一分钟执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heartbeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动后一秒钟之后执行一次，之后每次执行完间隔2分钟执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, initialDelay = <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组合多个Scheduled"><a href="#组合多个Scheduled" class="headerlink" title="组合多个Scheduled"></a>组合多个Scheduled</h5><p>@Scheduled可以让我们很方便的配置定时任务，但是有的定时任务不是一个表达式就能表达完全的，比如说我既想在周三10:10又想在周四17:40执行某项任务。这时候我们很难用一个表示式，或者根本行不通，这时候我们就要组合多个@Scheduled表达式。<br>@Schedules注解里面只有一个参数Scheduled数组，意味着我们可以将多个@Scheduled压入数组，组合使用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔18秒执行一次，并且每天的4:00执行一次</span></span><br><span class="line"><span class="meta">@Schedules</span>(&#123;<span class="meta">@Scheduled</span>(cron = <span class="string">"* * 4 * * *"</span>),<span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span>*<span class="number">18</span>)&#125;)</span><br></pre></td></tr></table></figure><p></p><h4 id="cronExpression的配置说明"><a href="#cronExpression的配置说明" class="headerlink" title="cronExpression的配置说明"></a>cronExpression的配置说明</h4><h5 id="各字段意义"><a href="#各字段意义" class="headerlink" title="各字段意义"></a>各字段意义</h5><table><thead><tr><th>字段</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日期</td><td>1-31</td><td>, - * /</td></tr><tr><td>月份</td><td>1-12或JAN-DEC</td><td>, - * /</td></tr><tr><td>星期</td><td>1-7或SUN-SAT</td><td>, - * /</td></tr><tr><td>年（可选）</td><td>留空，1970-2099</td><td>, - * /</td></tr></tbody></table><p><code>-</code> 指定区间<br><code>*</code> 通配符<br><code>?</code> 你不想设置那个值<br><code>/</code> 没多少执行一次</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><table><thead><tr><th>CRON表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>0 0 12 * * ?</code></td><td>每天中午12点触发</td></tr><tr><td><code>0 15 10 ? * *</code></td><td>每天上午10:15触发</td></tr><tr><td><code>0 15 10 * * ?</code></td><td>每天上午10:15触发</td></tr><tr><td><code>0 15 10 * * ? *</code></td><td>每天上午10:15触发</td></tr><tr><td><code>0 15 10 * * ? 2015</code></td><td>2015年的每天上午10:15触发</td></tr><tr><td><code>0 * 14 * * ?</code></td><td>每天下午14:00到14：59每分钟触发一次</td></tr><tr><td><code>0 0/5 14 * * ?</code></td><td>每天下午14:00到14:55没5分钟触发一次</td></tr><tr><td><code>0 0/5 14,18 * * ?</code></td><td>每天14:00到14:55和18:00到18:55每5分钟触发一次</td></tr><tr><td><code>0 0-5 14 * * ?</code></td><td>每天14:00前五分钟每分钟触发一次</td></tr><tr><td><code>0 10,44 14 ? 3 WED</code></td><td>3月每周三14:10和14:44触发</td></tr><tr><td><code>0 15 10 ? * MON-FRI</code></td><td>周一到周五的10:15触发</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关于spring的定时任务，我们在spring3.0之前一般会使用Quartz，这是一个功能相当强大的调度器，可以让你的程序在指定时间执行，也可以按照某个频度执行，但是配置起来稍显复杂。Spring3.0以后自带task，可以将它看成一个轻量级的Quartz，使用起来比Quartz简单许多，不需要额外的包，而且支持注解和配置文件两种形式。&lt;/p&gt;&lt;h4 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h4&gt;&lt;h5 id=&quot;配置文件方式&quot;&gt;&lt;a href=&quot;#配置文件方式&quot; class=&quot;headerlink&quot; title=&quot;配置文件方式&quot;&gt;&lt;/a&gt;配置文件方式&lt;/h5&gt;&lt;p&gt;首先需要在配置文件中引入task命名空间&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;	&lt;span class=&quot;attr&quot;&gt;xmlns:task&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/task&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;http:&lt;/span&gt;//&lt;span class=&quot;attr&quot;&gt;www.springframework.org&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;schema&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;task&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;    &lt;span class=&quot;attr&quot;&gt;http:&lt;/span&gt;//&lt;span class=&quot;attr&quot;&gt;www.springframework.org&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;schema&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;task&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;spring-task.xsd&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;然后配置需要定时执行的任务&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--Spring定时器注解开关，注册之后可以再java类中使用task命名空间的注解--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;task:annotation-driven&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;scheduler&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myScheduler&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;comment&quot;&gt;&amp;lt;!--内部使用的线程池，配置线程池，指定线程池的大小--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;task:scheduler&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;myScheduler&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;pool-size&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;10&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;string&quot;&gt;   &amp;lt;!--配置定时任务，指定需要定时执行的类和方法，并配置调度方式--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;span class=&quot;string&quot;&gt;   &amp;lt;task:scheduled-task scheduler=&quot;&lt;/span&gt;&lt;span class=&quot;attr&quot;&gt;myScheduler&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   	&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;task:scheduled&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;ref&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;scheduledTaskManager&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;method&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;autoCardCalculate&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;cron&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;0 5 * * * *&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;task:scheduled-task&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://windylee.cn/categories/Java-Web/"/>
    
    
      <category term="Spring" scheme="http://windylee.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring异步任务</title>
    <link href="http://windylee.cn/posts/c0ceddf6/"/>
    <id>http://windylee.cn/posts/c0ceddf6/</id>
    <published>2018-02-20T14:51:49.000Z</published>
    <updated>2018-02-21T16:28:25.431Z</updated>
    
    <content type="html"><![CDATA[<p>在Spring3.0之前如果我们想要异步执行某项任务，需要我们自己编写线程池来实现。在Spring3.X新增了注解@Async，可以标记方法或者类中的所有方法都可以异步执行，而调用他的方法会在原来的线程中执行。这样可以避免阻塞，保证任务的实时性。适用于处理log，发送邮件等</p><p>#### 配置</p><p>##### 配置文件</p><p>同Spring自己实现的定时任务一样，我们需要在配置文件中引入task命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">...</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span>/<span class="attr">spring-task.xsd</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure><p>然后配置相关的线程池和缺省的异步调度器</p><p>\</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置executor，一个应用中可以有多个executor--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"mailExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> <span class="attr">keep-alive</span>=<span class="string">"100"</span> <span class="attr">queue-capacity</span>=<span class="string">"5"</span> <span class="attr">rejection-policy</span>=<span class="string">"ABORT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"logExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定一个缺省的executor给@Async使用，当@Async没有指定使用哪个executor将默认使用该executor--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"mailExecutor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure><p></p><a id="more"></a><p>##### 配置参数</p><p>- id: 当配置多个executor时，被@Async(“id”)指定使用，也可以作为线程名的前缀</p><p>- pool-size 指定线程池的大小</p><p>- queue-capacity：当最小的线程数已经被占用满后，新的任务会被放进queue里面，当这个queue的capacity也被占满之后，pool里面会创建新线程处理这个任务，直到总线程数达到了max size，这是系统会拒绝这个任务并抛出TaskRejectedException异常(可以通过rejection-policy来决定如何处理这种情况)，缺省值为Integer.MAX_VALUE</p><p>- keey-alive：超过core size的那些线程，任务完成后，经过这个时长就会被结束掉</p><p>- rejection-policy：当pool已经达到max size的时候，如何处理新任务</p><p>ABORT（缺省）：抛出TaskRejectedException异常，然后不执行</p><p>DISCARD：不执行，也不抛出异常</p><p>DISCARD_OLDEST：丢弃queue中最旧的那个任务</p><p>CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</p><p>#### 注解</p><p>##### 注解源码</p><p>\</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Async &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure><p></p><p>通过@Async的源码我们可以知道，该注解可以用在方法上也可以用在类上，注解在方法上表明该方法是一部执行的，注解在类上表明该类中的所有方法都是一步执行的</p><p>##### 方法返回值</p><p>如果我们不想从异步线程中获取返回值，那么我们可以将返回值声明为void。如果我们想要从线程中获取数据，可以使用Future作为返回值。通过future.get()得到需要返回的对象，也可以使用future,get(time,unit)，在制定时间内获取返回值，如果超过设置的时间则抛出异常</p><p>\</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Async</span>(<span class="string">"logExecutor"</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务开始执行"</span>);</span><br><span class="line"></span><br><span class="line">​        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务执行结束"</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     \* 没有指定调度器将使用缺省值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     \* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     \* <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     */</span>[^]</span><br><span class="line"></span><br><span class="line">​    <span class="meta">@Async</span></span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">business2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务开始执行"</span>);</span><br><span class="line"></span><br><span class="line">​        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务执行结束"</span>);</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;String&gt;(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Spring3.0之前如果我们想要异步执行某项任务，需要我们自己编写线程池来实现。在Spring3.X新增了注解@Async，可以标记方法或者类中的所有方法都可以异步执行，而调用他的方法会在原来的线程中执行。这样可以避免阻塞，保证任务的实时性。适用于处理log，发送邮件等&lt;/p&gt;&lt;p&gt;#### 配置&lt;/p&gt;&lt;p&gt;##### 配置文件&lt;/p&gt;&lt;p&gt;同Spring自己实现的定时任务一样，我们需要在配置文件中引入task命名空间&lt;/p&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;beans&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;xmlns&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;​    &lt;span class=&quot;attr&quot;&gt;xmlns:task&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;http://www.springframework.org/schema/task&quot;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;​    &lt;span class=&quot;attr&quot;&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;​    &lt;span class=&quot;attr&quot;&gt;http:&lt;/span&gt;//&lt;span class=&quot;attr&quot;&gt;www.springframework.org&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;schema&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;task&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;​    &lt;span class=&quot;attr&quot;&gt;http:&lt;/span&gt;//&lt;span class=&quot;attr&quot;&gt;www.springframework.org&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;schema&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;task&lt;/span&gt;/&lt;span class=&quot;attr&quot;&gt;spring-task.xsd&lt;/span&gt;&quot;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;然后配置相关的线程池和缺省的异步调度器&lt;/p&gt;&lt;p&gt;\&lt;/p&gt;&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--配置executor，一个应用中可以有多个executor--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;task:executor&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;mailExecutor&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;pool-size&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;10&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;keep-alive&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;100&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;queue-capacity&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;5&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;rejection-policy&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;ABORT&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;task:executor&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;logExecutor&quot;&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;pool-size&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;10&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;&amp;lt;!--指定一个缺省的executor给@Async使用，当@Async没有指定使用哪个executor将默认使用该executor--&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;&lt;span class=&quot;name&quot;&gt;task:annotation-driven&lt;/span&gt; &lt;span class=&quot;attr&quot;&gt;executor&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&quot;mailExecutor&quot;&lt;/span&gt;/&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;\&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://windylee.cn/categories/Java-Web/"/>
    
    
      <category term="Spring" scheme="http://windylee.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring拦截器</title>
    <link href="http://windylee.cn/posts/2b6e765e/"/>
    <id>http://windylee.cn/posts/2b6e765e/</id>
    <published>2015-10-25T05:17:25.000Z</published>
    <updated>2018-02-21T16:28:25.428Z</updated>
    
    <content type="html"><![CDATA[<h4 id="处理器拦截器简介"><a href="#处理器拦截器简介" class="headerlink" title="处理器拦截器简介"></a>处理器拦截器简介</h4><p>Spring MVC的处理器拦截器类型于Servlet开发中的Filter，用于对处理器进行预处理和后处理</p><h5 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h5><ul><li>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等</li><li>权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面</li><li>性能监控：通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间</li><li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。</li><li>OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。</li></ul><p>本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。</p><h4 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h4><p>SpringMVC 中的<code>Interceptor</code>拦截请求是通过<code>HandlerInterceptor</code>来实现的。在SpringMVC中定义一个<code>Interceptor</code>非常简单，主要有两种方式，第一种方式是要定义的<code>Interceptor</code>类要实现了Spring 的<code>HandlerInterceptor</code>接口，或者是这个类继承实现了<code>HandlerInterceptor</code>接口的类，比如Spring 已经提供的实现了<code>HandlerInterceptor</code>接口的抽象类<code>HandlerInterceptorAdapte</code>；第二种方式是实现Spring的<code>WebRequestInterceptor</code>接口，或者是继承实现了<code>WebRequestInterceptor</code>的类。</p><h5 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a><code>HandlerInterceptor</code>接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response,   </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler)</span>   </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">           HttpServletRequest request, HttpServletResponse response,   </span></span></span><br><span class="line"><span class="function"><span class="params">           Object handler, ModelAndView modelAndView)</span>   </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response,   </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler, Exception ex)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>有接口的定义我们可以看出<code>HandlerInterceptor</code>中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。</p><ul><li><code>preHandle</code>实现处理器的预处理，第三个参数为响应处理器（一般为Controller）。返回true表示继续流程；返回false表示中断流程，不会继续调用其他的拦截器和处理器，这时候我们需要通过<code>response</code>来产生响应。我们可以在该方法中进行一些前置初始化操作或者是对当前请求的一个预处理。</li><li><code>postHandle</code>实现处理器的后处理，但是在<code>DispatcherServlet</code>渲染页面之前调用，我们可以调用modelAndView进行模型数据进行处理或对视图进行处理</li><li><code>afterCompleting</code>视图渲染完毕后回调该方法，该方法主要用于数据清理</li></ul><p><img src="/images/Spring拦截器1.jpg" alt=""><br><img src="/images/Spring拦截器2.jpg" alt=""><br>如果我们继承自HandlerInterceptor接口，那么我们每次都需要重写三个方法。但是大多数时候我们只需要重写其中一两个方法，这时候我们可以继承HandlerInterceptorAdapter类，选择性的重写其中的方法。<br>下面给出一个计算请求处理时间的例子<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatchHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NamedThreadLocal&lt;Clock&gt;  startTimeThreadLocal =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;Clock&gt;(<span class="string">"StopWatch-StartTime"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cloxk start = Clock.now()<span class="comment">//1、开始时间</span></span><br><span class="line">        startTimeThreadLocal.set(beginTime);<span class="comment">//线程绑定变量（该数据只有当前请求的线程可见）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续流程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Clock end = Clock.now();<span class="comment">//2、结束时间  </span></span><br><span class="line">        Clock start = startTimeThreadLocal.get();<span class="comment">//得到线程绑定的局部变量（开始时间）</span></span><br><span class="line">        <span class="keyword">long</span> consumeTime = Duration.betwen(start, end).toMillis()<span class="comment">//3、消耗的时间</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"%s consume %d millis"</span>, request.getRequestURI(), consumeTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h5 id="WebRequestInterceptor接口"><a href="#WebRequestInterceptor接口" class="headerlink" title="WebRequestInterceptor接口"></a><code>WebRequestInterceptor</code>接口</h5><p>该接口中也定义了三个方法，我们也可以通过这三个方法来实现拦截，这三个方法都传递了同一个参数<code>WebRequest</code>，三个方法的调用时机同<code>HanlderInterceptor</code>。<code>WebRequest</code>是Spring中定义的一个接口，方法基本和<code>HttpServletRequest</code>一样，对<code>WebRequest</code>做的任何操作都会同步到<code>HttpServletRequest</code>，然后在当前请求中一直传递</p><ul><li><p><code>preHandle(WebRequest request)</code>由于没有返回值，无法控制请求流程。我们一般在该方法中进行资源的准备工作。比如我们在使用Hibernate的时候可以在这个方法中准备一个Hibernate的Session对象，然后利用WebRequest的<code>setAttribute(name, value, scope)</code>把它放到WebRequest 的属性中。这里可以说说这个setAttribute 方法的第三个参数scope：</p><ul><li><code>SCOPE_REQUEST</code> ：它的值是0 ，代表只有在request 中可以访问。</li><li><code>SCOPE_SESSION</code> ：它的值是1 ，如果环境允许的话它代表的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。</li><li><code>SCOPE_GLOBAL_SESSION</code> ：它的值是2 ，如果环境允许的话，它代表的是一个全局共享的session，否则就代表普通的session，并且在该session 范围内可以访问。</li></ul></li><li><p><code>postHandle(WebRequest request, ModelMap model)</code>ModelMap 就是Controller 处理之后返回的Model 对象，我们可以通过改变它的属性来改变返回的Model 模型。</p></li><li><code>afterCompletion(WebRequest request, Exception ex)</code>可以在该方法中进行资源的释放操作，Exception 参数表示的是当前请求的异常对象，如果在Controller 中抛出的异常已经被Spring 的异常处理器给处理了的话，那么这个异常对象就是是null 。</li></ul><h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.windylee.interceptor.AllInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定拦截器的拦截路径--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/interceptor/**"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定拦截器的实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.windylee.interceptor.StopWatchHandlerInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mvc:interceptors</code>标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，在mvc:interceptors标签下声明interceptor主要有两种方式：</p><ul><li>直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。例子中的<code>AllInterceptor</code>会拦截所有请求</li><li>使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。</li></ul><h4 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h4><p>推荐能使用servlet规范中的过滤器Filter实现的功能就用Filter实现，因为HandlerInteceptor只有在Spring Web MVC环境下才能使用，因此Filter是最通用的、最先应该使用的。如登录这种拦截器最好使用Filter来实现。</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;处理器拦截器简介&quot;&gt;&lt;a href=&quot;#处理器拦截器简介&quot; class=&quot;headerlink&quot; title=&quot;处理器拦截器简介&quot;&gt;&lt;/a&gt;处理器拦截器简介&lt;/h4&gt;&lt;p&gt;Spring MVC的处理器拦截器类型于Servlet开发中的Filter，用于对处理器进行预处理和后处理&lt;/p&gt;&lt;h5 id=&quot;常见应用场景&quot;&gt;&lt;a href=&quot;#常见应用场景&quot; class=&quot;headerlink&quot; title=&quot;常见应用场景&quot;&gt;&lt;/a&gt;常见应用场景&lt;/h5&gt;&lt;ul&gt;&lt;li&gt;日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等&lt;/li&gt;&lt;li&gt;权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面&lt;/li&gt;&lt;li&gt;性能监控：通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间&lt;/li&gt;&lt;li&gt;通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。&lt;/li&gt;&lt;li&gt;OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。&lt;/p&gt;&lt;h4 id=&quot;拦截器实现&quot;&gt;&lt;a href=&quot;#拦截器实现&quot; class=&quot;headerlink&quot; title=&quot;拦截器实现&quot;&gt;&lt;/a&gt;拦截器实现&lt;/h4&gt;&lt;p&gt;SpringMVC 中的&lt;code&gt;Interceptor&lt;/code&gt;拦截请求是通过&lt;code&gt;HandlerInterceptor&lt;/code&gt;来实现的。在SpringMVC中定义一个&lt;code&gt;Interceptor&lt;/code&gt;非常简单，主要有两种方式，第一种方式是要定义的&lt;code&gt;Interceptor&lt;/code&gt;类要实现了Spring 的&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口，或者是这个类继承实现了&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口的类，比如Spring 已经提供的实现了&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口的抽象类&lt;code&gt;HandlerInterceptorAdapte&lt;/code&gt;；第二种方式是实现Spring的&lt;code&gt;WebRequestInterceptor&lt;/code&gt;接口，或者是继承实现了&lt;code&gt;WebRequestInterceptor&lt;/code&gt;的类。&lt;/p&gt;&lt;h5 id=&quot;HandlerInterceptor接口&quot;&gt;&lt;a href=&quot;#HandlerInterceptor接口&quot; class=&quot;headerlink&quot; title=&quot;HandlerInterceptor接口&quot;&gt;&lt;/a&gt;&lt;code&gt;HandlerInterceptor&lt;/code&gt;接口&lt;/h5&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;HandlerInterceptor&lt;/span&gt; &lt;/span&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;boolean&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;preHandle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;            HttpServletRequest request, HttpServletResponse response,   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;            Object handler)&lt;/span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;postHandle&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;           HttpServletRequest request, HttpServletResponse response,   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;           Object handler, ModelAndView modelAndView)&lt;/span&gt;   &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;           &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;afterCompletion&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(  &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;	            HttpServletRequest request, HttpServletResponse response,   &lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;params&quot;&gt;            Object handler, Exception ex)&lt;/span&gt;  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;throws&lt;/span&gt; Exception&lt;/span&gt;;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://windylee.cn/categories/Java-Web/"/>
    
    
      <category term="Spring" scheme="http://windylee.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java8新的时间日期库</title>
    <link href="http://windylee.cn/posts/b5a2dc36/"/>
    <id>http://windylee.cn/posts/b5a2dc36/</id>
    <published>2015-10-24T03:28:41.000Z</published>
    <updated>2018-02-21T16:28:25.429Z</updated>
    
    <content type="html"><![CDATA[<h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><h5 id="时间API分类概述"><a href="#时间API分类概述" class="headerlink" title="时间API分类概述"></a>时间API分类概述</h5><p>新的API： java.time，由5个包组成</p><ul><li><code>java.time</code>- 包含值对象的基础包</li><li><code>java.time.chrono</code> - 提供对不同的日历系统的访问</li><li><code>java.time.format</code> - 格式化和解析时间和日期</li><li><code>java.time.temporal</code> - 包括底层框架和扩展特性</li><li><code>java.time.zone</code> - 包含市区支持的类</li></ul><p>我们平时只会用到基础和format包，也可能用到temporal包，因此虽然新的API提供了多达68个新的公开类型，但是我们一般只会用到其中的三分之一</p><h5 id="关键日期-时间概述"><a href="#关键日期-时间概述" class="headerlink" title="关键日期/时间概述"></a>关键日期/时间概述</h5><ul><li>不可变性。借鉴于java.util.Calendar的前车之鉴，设计这个API的时候着重考虑了原有方法的不可变性，不允许任何更改，如果必须改变的话就会返回一个新的实例，所以我们必须捕获该方法的返回值</li><li>瞬间性。表示时间上的某个精确的时刻，使用从epoch开始计算的毫秒表示</li></ul><h4 id="关键API使用"><a href="#关键API使用" class="headerlink" title="关键API使用"></a>关键API使用</h4><h5 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h5><p>他可以通过时区来获取当前的instant，日期和时间。Clock类可以用来代替<code>System.currentTimeMillis()</code>和<code>TimeZone.getDefault()</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clock clock=Clock.systemUTC();<span class="comment">//获取格林尼治时间</span></span><br><span class="line">System.out.println(clock.instant());<span class="comment">//获取Instant类型数据，后面会讲到</span></span><br><span class="line">System.out.println(clock.millis());<span class="comment">//获取标准毫秒数</span></span><br></pre></td></tr></table></figure><p></p><a id="more"></a><h5 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h5><p>所谓的Instant累代表的是某个时间（有点类似与java.util.Date），他是精确到纳秒的，而Date是精确到毫秒的。instant表示的是时间线上的一点，而不需要任何上下文信息，例如：时区。概念上讲他只是简单的表示自1970年1月1日0是0分0秒开始的秒数。下面给去确定一个方法的运行时间长度的代码<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instant start = Instant.now();</span><br><span class="line">doSomeThing();</span><br><span class="line">Instant end = Instant.now();</span><br><span class="line">Duration duration = Duration.between(start, end);</span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();<span class="comment">//秒表示</span></span><br><span class="line"><span class="keyword">long</span> millis = duration.toMillis();<span class="comment">//毫秒表示</span></span><br><span class="line"><span class="keyword">boolean</span> isAfter = end.isAfter(start);<span class="comment">//时间点end是否在start之后[^]</span></span><br></pre></td></tr></table></figure><p></p><p>常用函数</p><ul><li><code>now()</code> 静态函数，获取当前时间戳</li><li><code>isAfter()/isBefore()</code> 判断两个时间点的先后顺序</li><li><code>plusXXX()</code> 在该时间点加上某段时间</li><li><code>minusXXX()</code> 在该时间点上减去某段时间</li></ul><p>Instant用在当你需要记录事件的发生时间，额如需要记录任何有关时区信息时。Instant只能包含秒数和毫秒数，例如如下代码就会抛出异常<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instant.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">instant.plus(<span class="number">6</span>, ChronoUnit.YEARS);</span><br></pre></td></tr></table></figure><p></p><h5 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h5><p><code>LocalDate</code>表示日期的不可变类型，不包含时间和时区。LocalDate和下面要讲的LocalTime都被设计成值类型的，这意味着我们不能用<code>==</code>来判断两个LocalDate是不是相等而是应该通过<code>equals()</code>。下面给出一个获取当前年月日的例子<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now(); </span><br><span class="line"><span class="keyword">int</span> year = today.getYear(); </span><br><span class="line"><span class="keyword">int</span> month = today.getMonthValue(); </span><br><span class="line"><span class="keyword">int</span> day = today.getDayOfMonth(); </span><br><span class="line">System.out.printf(<span class="string">"Year : %d Month : %d day : %d \t %n"</span>, year, month, day);</span><br></pre></td></tr></table></figure><p></p><p>常用函数</p><ul><li><code>now()</code>根据当前时间戳创建<code>LocalDate</code></li><li><code>of()</code>根据制定的年月日创建<code>LocalDate</code></li><li><code>parse(charqueue, DateTimeFormatter)</code>根据传入的format将字符串转化为LocalDate对象</li><li><code>ofYearDay()</code>根据指定的年和一年中的第几天创建<code>LocalDate</code></li><li><code>getXXX()</code>获取当前<code>LocalDate</code>中关于日期的信息，年月日等等</li><li><code>plusXXX()</code>在当前的<code>LocalDate</code>的基础上增加指定时间类型来创建一个新的<code>LocalDate</code></li><li><code>minusXXX()</code>在当前的<code>LocalDate</code>的基础上减去指定时间类型来创建一个新的<code>LocalDate</code></li><li><code>withXXX()</code>在当前的<code>LocalDate</code>的基础上指定某个时间类型的值来创建一个新的<code>LocalDate</code></li><li><code>isXXX()</code>判断两个<code>LocalDate</code>的大小关系，特别（<code>isLeepYear()</code>判断是否为闰年）</li><li><code>lengthOfXXX()</code>获取LocalDate代表的年或月的天数</li><li><code>with(TemporalAdjuster)</code>TemporalAdjusters提供了几个用来获取<code>TemporalAdjuster</code>的方法，用来处理比较复杂的逻辑，比如获取当月的最后一天<code>lastDayOfMonth()</code></li><li><code>atTime()</code>将<code>LocalDate</code>转化为<code>LocalDateTime</code></li></ul><h5 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h5><p><code>LocalTime</code>是值类型，且和日期，时区没有关联。当我们对时间进行加减操作时，以午夜为基准，24小时一个周期。因此，20:00加上6小时，结果是02:00。LocalTime用法和LocalDate类似<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time = LocalTime.of(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">int</span> hour = date.getHour(); <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">int</span> minute = date.getMinute(); <span class="comment">// 30</span></span><br><span class="line">time = time.withSecond(<span class="number">6</span>); <span class="comment">// 20:30:06</span></span><br><span class="line">time = time.plusMinutes(<span class="number">3</span>); <span class="comment">// 20:33:06</span></span><br></pre></td></tr></table></figure><p></p><p>常用函数</p><ul><li>和<code>LocalDate</code>基本类似，只是将对年月日的操作转换为时分秒</li><li><code>toSecondOfDay()</code>获取该时间点距离0:00的秒数</li></ul><h5 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h5><p>这个值类型只是<code>LocalDate</code>和<code>LocalTime</code>的简单组合。他表示一个和时区无关的日期和时间。LocalDateTime可以直接创建或者组合时间和日期<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2014</span>, Month.JUNE, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(date, time);</span><br><span class="line">Month month = dt1.getMonth();</span><br><span class="line"><span class="keyword">int</span> minute = dt1.getMinute();</span><br></pre></td></tr></table></figure><p></p><p>常用函数</p><ul><li>将<code>LocalDate</code>和<code>LocalTime</code>两个类的<code>plusXXX()</code>, <code>minusXXX()</code>, <code>withXXX()</code>,<code>getXXX()</code>简单相加</li><li>与<code>LocalDate</code>对象其他函数完全类似</li><li><code>isXXX()</code>与LocalDate完全一样</li><li><code>toLocalDate()/toLocalTime()</code>将<code>LocalDateTime</code>转换为<code>LocalTime</code>或者<code>LocalDate</code></li></ul><h5 id="时间长度"><a href="#时间长度" class="headerlink" title="时间长度"></a>时间长度</h5><p><code>Duration</code>表示以秒和纳秒位基准的时长；<code>Period</code>表示以年，月，日衡量的时长。他们可以作为参数，传给主要的时间/日期类的增加或减少的方法，也可以计算两个时间点之间的间隔<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Duration duration = Duration.ofDays(<span class="number">10</span>);</span><br><span class="line">LocalTime start = LocalTime.now();</span><br><span class="line">doSoneThing();</span><br><span class="line">LocalTime end = LocalTime.now();</span><br><span class="line">Duration spend = Duration.between(start, end);</span><br></pre></td></tr></table></figure><p></p><p>常用函数</p><ul><li><code>ofXXX()</code>根据参数指定的大小计算以<code>XXX</code>个单位的时间间隔</li><li><code>between(arg1, arg2)</code>计算两个参数时间点的时间间隔</li><li><code>plusXXX()/minuxXXX()</code>在当前时间间隔的基础上加上或减去指定个单位的时间</li><li><code>toXXX()</code>将时间间隔格式化位指定单位的时间，Duration一般使用该类型函数，Period一般使用<code>getXXX()</code></li><li><code>abs()</code>求时间间隔的绝对值，保证时间间隔不为负数</li><li><code>isZero()/isNegative()</code>判断时间间隔是否为0或负</li><li><code>withXXX()</code>直接指定某个单位的值</li></ul><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p><code>java.time.format</code>包是专门用来格式化输出输入时间/日期的。这个包围绕<code>DateTimeFormatter</code>类和它的辅助创建类<code>DateTimeFormatterBuilder</code>展开。静态方法<code>ofPattern(Charqueue)</code>和<code>DateTimeFormatter</code>中的常量是最通用的创建格式化器的方式</p><ul><li>常用ISO格式常量，如ISO_LOCAL_DATE</li><li>字母模式，如ofPattern(“dd/MM/uuuu”)</li><li>本地化样式，如ofLocalizedDate(FormatStyle.MEDIUM)</li></ul><p>有了格式化器，我们就可以将该实例传递给<code>parse()</code>或者<code>format()</code>作为参数，用来将字符串格式化为对象或者将对象格式化位字符串<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照内置的不同方式格式化</span></span><br><span class="line">String format = DateTimeFormatter.ISO_LOCAL_DATE.format(LocalDate.now());</span><br><span class="line">String format2 = DateTimeFormatter.ISO_LOCAL_TIME.format(LocalTime.now());</span><br><span class="line">String format3 = DateTimeFormatter.ISO_DATE.format(LocalDateTime.now());</span><br><span class="line">String format4 = DateTimeFormatter.ISO_INSTANT.format(Instant.now());</span><br><span class="line">System.out.println(format);</span><br><span class="line">System.out.println(format2);</span><br><span class="line">System.out.println(format3);</span><br><span class="line">System.out.println(format4);</span><br><span class="line">         </span><br><span class="line"><span class="comment">//按照标准格式格式化</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line">String format5 = formatter.format(LocalDateTime.now());</span><br><span class="line">System.out.println(format5);</span><br><span class="line">         </span><br><span class="line"><span class="comment">//按照指定方式格式化</span></span><br><span class="line">DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd E HH:mm:ss"</span>);</span><br><span class="line">String format6 = pattern.format(LocalDateTime.now());</span><br><span class="line">System.out.println(format6);</span><br></pre></td></tr></table></figure><p></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><code>YearMonth</code>仅仅包含年和月字段，操作也<code>LocalDate</code>类似<br><code>MonthDay</code>仅仅包含月和日字段，操作与<code>LocalDate</code>类似</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;综述&quot;&gt;&lt;a href=&quot;#综述&quot; class=&quot;headerlink&quot; title=&quot;综述&quot;&gt;&lt;/a&gt;综述&lt;/h4&gt;&lt;h5 id=&quot;时间API分类概述&quot;&gt;&lt;a href=&quot;#时间API分类概述&quot; class=&quot;headerlink&quot; title=&quot;时间API分类概述&quot;&gt;&lt;/a&gt;时间API分类概述&lt;/h5&gt;&lt;p&gt;新的API： java.time，由5个包组成&lt;/p&gt;&lt;ul&gt;&lt;li&gt;&lt;code&gt;java.time&lt;/code&gt;- 包含值对象的基础包&lt;/li&gt;&lt;li&gt;&lt;code&gt;java.time.chrono&lt;/code&gt; - 提供对不同的日历系统的访问&lt;/li&gt;&lt;li&gt;&lt;code&gt;java.time.format&lt;/code&gt; - 格式化和解析时间和日期&lt;/li&gt;&lt;li&gt;&lt;code&gt;java.time.temporal&lt;/code&gt; - 包括底层框架和扩展特性&lt;/li&gt;&lt;li&gt;&lt;code&gt;java.time.zone&lt;/code&gt; - 包含市区支持的类&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;我们平时只会用到基础和format包，也可能用到temporal包，因此虽然新的API提供了多达68个新的公开类型，但是我们一般只会用到其中的三分之一&lt;/p&gt;&lt;h5 id=&quot;关键日期-时间概述&quot;&gt;&lt;a href=&quot;#关键日期-时间概述&quot; class=&quot;headerlink&quot; title=&quot;关键日期/时间概述&quot;&gt;&lt;/a&gt;关键日期/时间概述&lt;/h5&gt;&lt;ul&gt;&lt;li&gt;不可变性。借鉴于java.util.Calendar的前车之鉴，设计这个API的时候着重考虑了原有方法的不可变性，不允许任何更改，如果必须改变的话就会返回一个新的实例，所以我们必须捕获该方法的返回值&lt;/li&gt;&lt;li&gt;瞬间性。表示时间上的某个精确的时刻，使用从epoch开始计算的毫秒表示&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;关键API使用&quot;&gt;&lt;a href=&quot;#关键API使用&quot; class=&quot;headerlink&quot; title=&quot;关键API使用&quot;&gt;&lt;/a&gt;关键API使用&lt;/h4&gt;&lt;h5 id=&quot;Clock&quot;&gt;&lt;a href=&quot;#Clock&quot; class=&quot;headerlink&quot; title=&quot;Clock&quot;&gt;&lt;/a&gt;Clock&lt;/h5&gt;&lt;p&gt;他可以通过时区来获取当前的instant，日期和时间。Clock类可以用来代替&lt;code&gt;System.currentTimeMillis()&lt;/code&gt;和&lt;code&gt;TimeZone.getDefault()&lt;/code&gt;&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Clock clock=Clock.systemUTC();&lt;span class=&quot;comment&quot;&gt;//获取格林尼治时间&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(clock.instant());&lt;span class=&quot;comment&quot;&gt;//获取Instant类型数据，后面会讲到&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;System.out.println(clock.millis());&lt;span class=&quot;comment&quot;&gt;//获取标准毫秒数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java Web" scheme="http://windylee.cn/categories/Java-Web/"/>
    
    
      <category term="Java" scheme="http://windylee.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>effictive-java读书笔记</title>
    <link href="http://windylee.cn/posts/636894a/"/>
    <id>http://windylee.cn/posts/636894a/</id>
    <published>2015-10-20T07:50:22.000Z</published>
    <updated>2018-03-22T01:26:08.134Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Effective-Java一书笔记"><a href="#Effective-Java一书笔记" class="headerlink" title="Effective Java一书笔记"></a>Effective Java一书笔记</h1><h2 id="对象的创建与销毁"><a href="#对象的创建与销毁" class="headerlink" title="对象的创建与销毁"></a>对象的创建与销毁</h2><ul><li>Item 1: 使用static工厂方法，而不是构造函数创建对象<br>仅仅是创建对象的方法，并非Factory Pattern<ul><li>优点<ul><li>命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义</li><li>Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutable的对象来说，使得用<code>==</code>判等符合语义，且更高效；</li><li>工厂方法能够返回任何返回类型的子类对象，甚至是私有实现；使得开发模块之间通过接口耦合，降低耦合度；而接口的实现也将更加灵活；接口不能有static方法，通常做法是为其再创建一个工厂方法类，如Collection与Collections；</li><li>Read More: Service Provider Framework</li></ul></li><li>缺点<ul><li>仅有static工厂方法，没有public/protected构造函数的类将无法被继承；见仁见智，这一方面也迫使开发者倾向于组合而非继承；</li><li>Javadoc中不能和其他static方法区分开，没有构造函数的集中显示优点；但可以通过公约的命名规则来改善；</li></ul></li><li>小结<br>static工厂方法和public构造函数均有其优缺点，在编码过程中，可以先考虑一下工厂方法是否合适，再进行选择。</li></ul></li><li>Item 2: 使用当构造函数的参数较多，尤其是其中还有部分是可选参数时，使用Builder模式<ul><li>以往的方法<ul><li>Telescoping constructor：针对可选参数，从0个到最多个，依次编写一个构造函数，它们按照参数数量由少到多逐层调用，最终调用到完整参数的构造函数；代码冗余，有时还得传递无意义参数，而且容易导致使用过程中出隐蔽的bug；</li><li>JavaBeans Pattern：灵活，但是缺乏安全性，有状态不一致问题，线程安全问题；</li></ul></li><li>Builder Pattern<ul><li>代码灵活简洁；具备安全性；</li><li>immutable</li><li>参数检查：最好放在要build的对象的构造函数中，而非builder的构建过程中</li><li>支持多个field以varargs的方式设置（每个函数只能有一个varargs）</li><li>一个builder可以build多个对象</li><li>Builder结合泛型，实现Abstract Factory Pattern</li><li>传统的抽象工厂模式，是用Class类实现的，然而其有缺点：newInstance调用总是去调用无参数构造函数，不能保证存在；newInstance方法会抛出所有无参数构造函数中的异常，而且不会被编译期的异常检查机制覆盖；可能会导致运行时异常，而非编译期错误；</li></ul></li><li>小结<br>Builder模式在简单地类（参数较少，例如4个以下）中，优势并不明显，但是需要予以考虑，尤其是当参数可能会变多时，有可选参数时更是如此。</li></ul></li></ul><a id="more"></a><ul><li><p>Item 3: 单例模式！<br>不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。</p><ul><li>double-check-locking<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RestAdapter sRestAdapter = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestAdapter <span class="title">provideRestAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RestProvider.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sRestAdapter = <span class="keyword">new</span> RestAdapter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sRestAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>DCL可能会失效，因为指令重排可能导致同步解除后，对象初始化不完全就被其他线程获取；使用volatile关键字修饰对象，或者使用static SingletonHolder来避免该问题（后者JLS推荐）；</p><ul><li>class的static代码：一个类只有在被使用时才会初始化，而类初始化过程是非并行的，这些都由JLS能保证</li><li>用enum实现单例</li><li>还存在反射安全性问题：利用反射，可以访问私有方法，可通过加一个控制变量，该变量在getInstance函数中设置，如果不是从getInstance调用构造函数，则抛出异常；</li></ul></li><li>Item 4: 将构造函数私有化，使得不能从类外创建实例，同时也能禁止类被继承<br>util类可能不希望被实例化，有其需求</li><li>Item 5: 避免创建不必要的对象<ul><li>提高性能：创建对象需要时间、空间，“重量级”对象尤甚；immutable的对象也应该避免重复创建，例如String；</li><li>避免auto-boxing</li><li>但是因此而故意不创建必要的对象是错误的，使用object pool通常也是没必要的</li><li>lazy initialize也不是特别必要，除非使用场景很少且很重量级</li><li>Map#keySet方法，每次调用返回的是同一个Set对象，如果修改了返回的set，其他使用的代码可能会产生bug</li><li>需要defensive copying的时候，如果没有创建一个新对象，将导致很隐藏的Bug</li></ul></li><li>Item 6: 不再使用的对象一定要解除引用，避免memory leak<ul><li>例如，用数组实现一个栈，pop的时候，如果仅仅是移动下标，没有把pop出栈的数组位置引用解除，将发生内存泄漏</li><li>程序发生错误之后，应该尽快把错误抛出，而不是以错误的状态继续运行，否则可能导致更大的问题</li><li>通过把变量（引用）置为null不是最好的实现方式，只有在极端情况下才需要这样；好的办法是通过作用域来使得变量的引用过期，所以尽量缩小变量的作用域是很好的实践；注意，在Dalvik虚拟机中，存在一个细微的bug，可能会导致内存泄漏，<a href="MemoryLeak.md">详见</a></li><li>当一个类管理了一块内存，用于保存其他对象（数据）时，例如用数组实现的栈，底层通过一个数组来管理数据，但是数组的大小不等于有效数据的大小，GC器却并不知道这件事，所以这时候，需要对其管理的数据对象进行null解引用</li><li>当一个类管理了一块内存，用于保存其他对象（数据）时，程序员应该保持高度警惕，避免出现内存泄漏，一旦数据无效之后，需要立即解除引用</li><li>实现缓存的时候也很容易导致内存泄漏，放进缓存的对象一定要有换出机制，或者通过弱引用来进行引用</li><li>listner和callback也有可能导致内存泄漏，最好使用弱引用来进行引用，使得其可以被GC</li></ul></li><li>Item 7: 不要使用finalize方法<ul><li>finalize方法不同于C++的析构函数，不是用来释放资源的好地方</li><li>finalize方法执行并不及时，其执行线程优先级很低，而当对象unreachable之后，需要执行finalize方法之后才能释放，所以会导致对象生存周期变长，甚至根本不会释放</li><li>finalize方法的执行并不保证执行成功/完成</li><li>使用finalize时，性能会严重下降</li><li>finalize存在的意义<ul><li>充当“safety net”的角色，避免对象的使用者忘记调用显式termination方法，尽管finalize方法的执行时间没有保证，但是晚释放资源好过不释放资源；此处输出log警告有利于排查bug</li><li>用于释放native peer，但是当native peer持有必须要释放的资源时，应该定义显式termination方法</li></ul></li><li>子类finalize方法并不会自动调用父类finalize方法（和构造函数不同），为了避免子类不手动调用父类的finalize方法导致父类的资源未被释放，当需要使用finalize时，使用finalizer guardian比较好：<ul><li>定义一个私有的匿名Object子类对象，重写其finalize方法，在其中进行父类要做的工作</li><li>因为当父类对象被回收时，finalizer guardian也会被回收，它的finalize方法就一定会被触发</li></ul></li></ul></li></ul><!--more--><p>##Object的方法<br>尽管Object不是抽象类，但是其定义的非final方法设计的时候都是希望被重写的，finalize除外。</p><ul><li>Item 8: 当重写equals方法时，遵循其语义<ul><li>能不重写equals时就不要重写<ul><li>当对象表达的不是值，而是可变的状态时</li><li>对象不需要使用判等时</li><li>父类已重写，且满足子类语义</li></ul></li><li>当需要判等，且继承实现无法满足语义时，需要重写（通常是“value class”，或immutable对象）</li><li>当用作map的key时</li><li>重写equals时需要遵循的语义<ul><li>Reflexive（自反性）: x.equals(x)必须返回true（x不为null）</li><li>Symmetric（对称性）: x.equals(y) == y.equals(x)</li><li>Transitive（传递性）: x.equals(y) &amp;&amp; y.equals(z) ==&gt; x.equals(z)</li><li>Consistent（一致性）: 当对象未发生改变时，多次调用应该返回同一结果</li><li>x.equals(null)必须返回false</li></ul></li><li>实现建议<ul><li>先用==检查是否引用同一对象，提高性能</li><li>用instanceof再检查是否同一类型</li><li>再强制转换为正确的类型</li><li>再对各个域进行equals检查，遵循同样的规则</li><li>确认其语义正确，编写测例</li><li>重写equals时，同时也重写hashCode</li><li>！重写equals方法，传入的参数是Object</li></ul></li></ul></li><li>Item 9: 重写equals时也重写hashCode函数<ul><li>避免在基于hash的集合中使用时出错</li><li>语义<ul><li>一致性</li><li>当两个对象equals返回true时，hashCode方法的返回值也要相同</li></ul></li><li>hashCode的计算方式<ul><li>要求：equals的两个对象hashCode一样，但是不equals的对象hashCode不一样</li><li>取一个素数，例如17，result = 17</li><li>对每一个关心的field（在equals中参与判断的field），记为f，将其转换为一个int，记为c</li><li>boolean: f ? 1 : 0</li><li>byte/char/short/int: (int) f</li><li>long: (int) (f ^ (f &gt;&gt; 32))</li><li>float: Float.floatToIntBits(f)</li><li>double: Double.doubleToLongBits(f)，再按照long处理</li><li>Object: f == null ? 0 : f.hashCode()</li><li>array: 先计算每个元素的hashCode，再按照int处理</li><li>对每个field计算的c，result = 31 * result + c</li><li>返回result</li><li>编写测例</li></ul></li><li>计算hashCode时，不重要的field（未参与equals判断）不要参与计算</li></ul></li><li>Item 10: 重写toString()方法<ul><li>增加可读性，简洁、可读、具有信息量</li></ul></li><li>Item 11: 慎重重写clone方法<ul><li>Cloneable接口是一个mixin interface，用于表明一个对象可以被clone</li><li>Contract<ul><li>x.clone() != x</li><li>x.clone().getClass() == x.getClass()：要求太弱，当一个非final类重写clone方法的时候，创建的对象一定要通过super.clone()来获得，所有父类都遵循同样的原则，如此最终通过Object.clone()创建对象，能保证创建的是正确的类实例。而这一点很难保证。</li><li>x.clone().equals(x)</li><li>不调用构造函数：要求太强，一般都会在clone函数里面调用</li></ul></li><li>对于成员变量都是primitive type的类，直接调用super.clone()，然后cast为自己的类型即可（重写时允许返回被重写类返回类型的子类，便于使用方，不必每次cast）</li><li>成员变量包含对象（包括primitive type数组），可以通过递归调用成员的clone方法并赋值来实现</li><li>然而上述方式违背了final的使用协议，final成员不允许再次赋值，然而clone方法里面必须要对其赋值，则无法使用final保证不可变性了</li><li>递归调用成员的clone方法也会存在性能问题，对HashTable递归调用深拷贝也可能导致StackOverFlow（可以通过遍历添加来避免）</li><li>优雅的方式是通过super.clone()创建对象，然后为成员变量设置相同的值，而不是简单地递归调用成员的clone方法</li><li>和构造函数一样，在clone的过程中，不能调用non final的方法，如果调用虚函数，那么该函数会优先执行，而此时被clone的对象状态还未完成clone/construct，会导致corruption。因此上一条中提及的“设置相同的值”所调用的方法，要是final或者private。</li><li>重载类的clone方法可以省略异常表的定义，如果重写时把可见性改为public，则应该省略，便于使用；如果设计为应该被继承，则应该重写得和Object的一样，且不应该实现Cloneable接口；多线程问题也需要考虑；</li><li>要实现clone方法的类，都应该实现Cloneable接口，同时把clone方法可见性设为public，返回类型为自己，应该调用super.clone()来创建对象，然后手动设置每个域的值</li><li>clone方法太过复杂，如果不实现Cloneable接口，也可以通过别的方式实现copy功能，或者不提供copy功能，immutable提供copy功能是无意义的</li><li>提供拷贝构造函数，或者拷贝工厂方法，而且此种方法更加推荐，但也有其不足</li><li>设计用来被继承的类时，如果不实现一个正确高效的clone重写，那么其子类也将无法实现正确高效的clone功能</li></ul></li><li>Item 12: 当对象自然有序时，实现Comparable接口<ul><li>实现Comparable接口可以利用其有序性特点，提高集合使用/搜索/排序的性能</li><li>Contact<ul><li>sgn(x.compareTo(y)) == - sgn(y.compareTo(x))，当类型不对时，应该抛出ClassCastException，抛出异常的行为应该是一致的</li><li>transitive: x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 ==&gt; x.compareTo(z) &gt; 0</li><li>x.compareTo(y) == 0 ==&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z))</li><li>建议，但非必须：与equals保持一致，即 x.compareTo(y) == 0 ==&gt; x.equals(y)，如果不一致，需要在文档中明确指出</li></ul></li><li>TreeSet, TreeMap等使用的就是有序保存，而HashSet, HashMap则是通过equals + hashCode保存</li><li>当要为一个实现了Comparable接口的类增加成员变量时，不要通过继承来实现，而是使用组合，并提供原有对象的访问方法，以保持对Contract的遵循</li><li>实现细节<ul><li>优先比较重要的域</li><li>谨慎使用返回差值的方式，有可能会溢出</li></ul></li></ul></li></ul><p>##Classes and Interfaces</p><ul><li>Item 13: 最小化类、成员的可见性<ul><li>封装（隐藏）：公开的接口需要暴露，而接口的实现则需要隐藏，使得接口与实现解耦，降低模块耦合度，增加可测试性、稳定性、可维护性、可优化性、可修改性</li><li>如果一个类只对一个类可见，则应该将其定义为私有的内部类，而没必要public的类都应该定义为package private</li><li>为了便于测试，可以适当放松可见性，但也只应该改为package private，不能更高</li><li>成员不能是非private的，尤其是可变的对象。一旦外部可访问，将失去对其内容的控制能力，而且会有多线程问题</li><li>暴露的常量也不能是可变的对象，否则public static final也将失去其意义，final成员无法改变其指向，但其指向的对象却是可变的（immutable的对象除外），长度非0的数组同样也是有问题的，可以考虑每次访问时创建拷贝，或者使用<code>Collections.unmodifiableList(Arrays.asList(arr))</code></li></ul></li><li>Item 14: public class中，使用accessor method而非public field<ul><li>后者外部可以直接访问，失去了安全性</li><li>package private或者private则可以不必这样</li><li>把immutable的field置为public勉强可以接受，mutable的成员一定不能置为public</li></ul></li><li>Item 15: 最小化可变性<ul><li>不提供可以改变本对象状态的方法</li><li>保证类不可被继承</li><li>使用final field</li><li>使用private field</li><li>在构造函数、accessor中，对mutable field使用defensive copy</li><li>实现建议<ul><li>操作函数，例如BigInteger的add方法，不是static的，但也不能改变本对象的状态，则使用functional的方式，返回一个新的对象，其状态是本对象修改之后的状态</li><li>如此实现的immutable对象生来就是线程安全的，无需同步操作，但应该鼓励共用实例，避免创建过多重复的对象</li><li>正确实现的immutable对象也不需要clone, copy方法；可以适当引入Object cache；</li></ul></li><li>劣势<ul><li>每一个值都需要一个对象，调用改变状态的方法而创建一个新的对象，尤其是它是重量级的，开销会变大；连续调用这样的方法，影响更大；</li><li>为常用的多次操作组合提供一个方法</li></ul></li><li>其他<ul><li>保证class无法被继承，除了声明为final外，还可以将默认构造函数声明为private或package private，然后提供public static工厂方法</li><li>使用public static工厂方法，具体实现类可以有多个，还能进行object cache</li><li>当实现Serializable接口是，一定要实现readObject/readResolve方法，或者使用ObjectOutputStream.writeUnshared/ObjectInputStream.readUnshared</li></ul></li><li>小结<ul><li>除非有很好的理由让一个Class mutable，否则应该使其immutable</li><li>如果非要mutable，也应尽可能限制其可变性</li></ul></li></ul></li><li>Item 16: Favor composition (and forwarding) over inheritance<ul><li>跨包继承、继承不是被设计为应该被继承的实现类，是一件很危险的事情，继承接口、继承抽象类，当然是没问题的</li><li>如果子类的功能依赖于父类的实现细节，那么一旦父类发生变化，子类将有可能出现Bug，即便代码都没有修改；而设计为应被继承的类，在修改后，是应该有文档说明的，子类开发者既可以得知，也可以知道如何修改</li><li>例子：统计HashSet添加元素的次数<ul><li>用继承方式，重写add，addAll，在其中计数，这就不对，因为HashSet内部的addAll是通过调用add实现的</li><li>但是通过不重写addAll也只不对的，以后有可能HashSet的实现就变了</li><li>在重写中重新实现一遍父类的逻辑也是行不通的，因为这可能会导致性能问题、bug等，而且有些功能不访问私有成员也是无法实现的</li><li>还有一个原因就是父类的实现中，可能会增加方法，改变其行为，而这一点，在子类中是无法控制的</li></ul></li><li>而通过组合的方式，将不会有这些问题，把另一个类的对象声明为私有成员，外部将无法访问它，自己也能在转发（forwarding）过程中执行拦截操作，也不必依赖其实现细节，这种组合、转发的实现被称为wrapper，或者Decorator pattern，或者delegation（严格来说不是代理，代理一般wrapper对象都需要把自己传入到被wrap的对象方法中？）</li><li>缺点<ul><li>不适用于callback frameworks？</li></ul></li><li>继承应该在is-a的场景中使用</li><li>继承除了会继承父类的API功能，也会继承父类的设计缺陷，而组合则可以隐藏成员类的设计缺陷</li></ul></li><li>Item 17: Design and document for inheritance or else prohibit it<ul><li>一个类必须在文档中说明，每个可重写的方法，在该类的实现中的哪些地方会被调用（the class must document its self-use of overridable methods）。调用时机、顺序、结果产生的影响，包括多线程、初始化等情况。</li><li>被继承类应该通过谨慎选择protected的方法或成员，来提供一些hook，用于改变其内部的行为，例如java.util.AbstractList::removeRange。</li><li>The only way to test a class designed for inheritance is to write subclasses. 用于判断是否需要增加或者减少protected成员/方法，通常写3个子类就差不多了。</li><li>You must test your class by writing subclasses before you release it.</li><li>Constructors must not invoke overridable methods. 父类的构造函数比子类的构造函数先执行，而如果父类构造函数中调用了可重写的方法，那么就会导致子类的重写方法比子类的构造函数先执行，会导致corruption。</li><li>如果实现了Serializable/Cloneable接口，neither clone nor readObject may invoke an overridable method, directly or indirectly. 重写方法会在deserialized/fix the clone’s state之前执行。</li><li>如果实现了Serializable接口，readResolve/writeReplace必须是protected，而非private</li><li>designing a class for inheritance places substantial limitations on the class.</li><li>The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed. 声明为final class或者把构造函数私有化（提供public static工厂方法）。</li><li>如果确实想要允许继承，就应该为每个被自己使用的可重写方法都写好文档</li></ul></li><li>Item 18: Prefer interfaces to abstract classes<ul><li>Java类只允许单继承，接口可以多继承，使用接口定义类型，使得class hierarchy更加灵活</li><li>定义mixin（optional functionality to be “mixed in”）时使用interface是很方便的，需要增加此功能的类只需要implement该接口即可，而如果使用抽象类，则无法增加一个extends语句</li><li>接口允许构建没有hierarchy的类型系统</li><li>使用接口定义类型，可以使得item 16中提到的wrapper模式更加安全、强大，</li><li>skeletal implementation：该类为abstract，把必须由client实现的方法设为abstract，可以有默认实现的则提供默认实现</li><li>simulated multiple inheritance：通过实现定义的接口，同时在内部实现一个匿名的skeletal implementation，将对对该接口的调用转发到匿名类中，起到“多继承”的效果</li><li>simple implementation：提供一个非抽象的接口实现类，提供一个最简单、能work的实现，也允许被继承</li><li>使用接口定义类型的缺点：不便于演进，一旦接口发布，如果想要增加功能（增加方法），则client将无法编译；而使用abstract class，则没有此问题，只需要提供默认实现即可</li><li>小结<ul><li>通过接口定义类型，可以允许多实现（多继承）</li><li>但是演进需求大于灵活性、功能性时，抽象类更合适</li><li>提供接口时，提供一个skeletal implementation，同时审慎考虑接口设计</li></ul></li></ul></li><li>Item 19: 仅仅用interface去定义一个类型，该接口应该有实现类，使用者通过接口引用，去调用接口的方法<ul><li>避免用接口去定义常量，应该用noninstantiable utility class去定义常量</li><li>相关常量的命名，通过公共前缀来实现分组</li></ul></li><li>Item 20: Prefer class hierarchies to tagged classes<ul><li>tagged class: 在内部定义一个tag变量，由其控制功能的转换</li><li>tag classes are verbose, error-prone, and inefficient</li><li>而class hierarchy，不同功能由不同子类实现，公共部分抽象为一个基类，也能反映出各个子类之间的关系</li></ul></li><li>Item 21: Use function objects to represent strategies<ul><li>只提供一个功能函数的类实例，没有成员变量，只需一个对象（单例），为其功能定义一个接口，则可以实现策略模式，把具体策略传入相应函数中，使用策略</li><li>具体的策略实例通常使用匿名类定义，调用使用该策略的方法时才予以创建/预先创建好之后每次将其传入</li></ul></li><li>Item 22: Favor static member classes over nonstatic<ul><li>有4种nested class：non-static member class; static member class(inner class); anonymous class; local class</li><li>static member class<ul><li>经常作为helper class，和外部类一起使用</li><li>如果nested class的生命周期独立于外部类存在，则必须定义为static member class，否则可能造成内存泄漏</li><li>private static member class用处一：表示（封装）外部类的一些成员，例如Map的Entry内部类。</li></ul></li><li>non-static member class<ul><li>将持有外部类实例的强引用，可以直接引用外部类的成员和方法</li><li>用处一：定义一个Adapter，使得外部内的实例，可以作为和外部类语义不同的实例来查看（访问），例如Collection的Iterator。</li><li>如果nested class不需要引用外部类的成员和方法，则一定要将其定义为static，避免空间/时间开销，避免内存泄漏</li></ul></li><li>anonymous class<ul><li>当在非static代码块内定义时，会持有外部类的引用，否则不会持有</li><li>限制</li><li>只能在被声明的地方进行实例化</li><li>无法进行instanceof测试</li><li>不能用匿名类实现多个接口</li><li>不能用匿名类继承一个类的同时实现接口</li><li>匿名类中新添加的方法无法在匿名类外部访问</li><li>不能有static成员</li><li>应该尽量保持简短</li><li>用处一：创建function object</li><li>用处二：创建process object，例如：Runnable, Thread, TimberTask</li><li>用处三：用于public static工厂方法，例如Collections类里面的一些工厂方法，很多是返回一个匿名的内部实现</li></ul></li><li>local class<ul><li>比较少用</li><li>是否static取决于其定义的上下文</li><li>可以在作用域内重复使用</li><li>不能有static成员</li><li>也应尽量保持简短</li></ul></li><li>小结<ul><li>四种nested class</li><li>如果nested class在整个外部类内都需要可见，或者定义代码太长，应使用member class</li><li>能static就一定要static，即便需要对外部类进行引用，对于生命周期独立于外部类的，也应该通过WeakReference进行引用，避免内存泄漏；至于生命周期和外部类一致的，则不必这样</li></ul></li></ul></li></ul><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><ul><li><p>Item 23: Don’t use raw types in new code</p><ul><li>Java泛型，例如<code>List&lt;E&gt;</code>，真正使用的时候都是<code>List&lt;String&gt;</code>等，把E替换为实际的类型</li><li>Java泛型从1.5引入，为了保持兼容性，实现的是伪泛型，类型参数信息在编译完成之后都会被擦除，其在运行时的类型都是raw type，类型参数保存的都是Object类型，<code>List&lt;E&gt;</code>的raw type就是<code>List</code></li><li>编译器在编译期通过类型参数，为读操作自动进行了类型强制转换，同时在写操作时自动进行了类型检查</li><li>如果使用raw type，那编译器就不会在写操作时进行类型检查了，写入错误的类型也不会报编译错误，那么在后续读操作进行强制类型转换时，将会导致转换失败，抛出异常</li><li>一旦错误发生，应该让它尽早被知道（抛出/捕获），编译期显然优于运行期</li><li><p><code>List</code>与<code>List&lt;Object&gt;</code>的区别</p><ul><li>前者不具备类型安全性，后者具备，例如以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uses raw type (List) - fails at runtime!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  unsafeAdd(strings, <span class="keyword">new</span> Integer(<span class="number">42</span>));</span><br><span class="line">  String s = strings.get(<span class="number">0</span>); <span class="comment">// Compiler-generated cast</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unsafeAdd</span><span class="params">(List list, Object o)</span> </span>&#123;</span><br><span class="line">  list.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>不会报编译错误，但会给一个编译警告：<code>Test.java:10: warning: unchecked call to add(E) in raw type List list.add(o);</code>，而运行时则会发生错误。</p><ul><li>但如果使用<code>List&lt;Object&gt;</code>，即<code>unsageAdd</code>参数改为<code>List&lt;Object&gt; list, Object o</code>，则会报编译错误：<code>Test.java:5: unsafeAdd(List&lt;Object&gt;,Object) cannot be applied to (List&lt;String&gt;,Integer) unsafeAdd(strings, new Integer(42));</code></li><li>因为<code>List&lt;String&gt;</code>是<code>List</code>的子类，但却不是<code>List&lt;Object&gt;</code>的子类。</li><li>并不是说这个场景应该使用<code>List&lt;Object&gt;</code>，这个场景应该使用<code>List&lt;String&gt;</code>，这里只是为了说明<code>List</code>和<code>List&lt;Object&gt;</code>是有区别的。</li></ul></li><li><p><code>List</code> v.s. <code>List&lt;?&gt;</code>（unbounded wildcard types），当不确定类型参数，或者说类型参数不重要时，也不应该使用raw type，而应该使用<code>List&lt;?&gt;</code></p><ul><li><p>任何参数化的List均是<code>List&lt;?&gt;</code>的子类，可以作为参数传入接受<code>List&lt;?&gt;</code>的函数，例如以下代码均是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="keyword">new</span> List&lt;Object&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;Integer&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;String&gt;());</span><br></pre></td></tr></table></figure></li><li><p>持有<code>List&lt;?&gt;</code>的引用后，并不能向其中加入任何元素，读取出来的元素也是<code>Object</code>类型，而不会被自动强转为任何类型。</p></li><li>如果<code>List&lt;?&gt;</code>的行为不能满足需求，可以考虑使用模板方法，或者<code>List&lt;E extends XXX&gt;</code>（bounded wildcard types）</li></ul></li><li>You must use raw types in class literals.<ul><li><code>List.class</code>, <code>String[].class</code>, and <code>int.class</code> are all legal, but <code>List&lt;String&gt;.class</code> and <code>List&lt;?&gt;.class</code> are not.</li></ul></li><li><p><code>instanceof</code>不支持泛型，以下用法是推荐的，但不应该将<code>o</code>强转为<code>List</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Legitimate use of raw type - instanceof operator</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123; <span class="comment">// Raw type</span></span><br><span class="line">  Set&lt;?&gt; m = (Set&lt;?&gt;) o; <span class="comment">// Wildcard type</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相关术语汇总<br><img src="assets/java_generic_terms.png" alt="java_generic_terms.png"></p></li></ul></li><li>Item 24: Eliminate unchecked warnings<ul><li>当出现类型不安全的强制转换时（一般都是涉及泛型，raw type），编译器会给出警告，首先要做的是尽量消除不安全的转换，消除警告</li><li>实在无法消除/确定不会导致运行时的<code>ClassCastException</code>，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>消除警告，但不要直接忽略该警告</li><li>使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>时，应该在注视内证明确实不存在运行时的<code>ClassCastException</code>；同时应该尽量减小其作用的范围，通常是应该为一个赋值语句添加注解</li></ul></li><li><p>Item 25: Prefer lists to arrays</p><ul><li>arrays are covariant(协变): 如果<code>Sub</code>是<code>Super</code>的子类，那么<code>Sub[]</code>也是<code>Super[]</code>的子类</li><li>generics are invariant(不变): 任意两个不同的类<code>Type1</code>和<code>Type2</code>，<code>List&lt;Type1&gt;</code>和<code>List&lt;Type2&gt;</code>之间没有任何继承关系</li><li><p>考虑以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fails at runtime!</span></span><br><span class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">"I don't fit in"</span>; <span class="comment">// Throws ArrayStoreException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Won't compile!</span></span><br><span class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// Incompatible types</span></span><br><span class="line">ol.add(<span class="string">"I don't fit in"</span>);</span><br></pre></td></tr></table></figure></li><li><p>arrays are reified(具体化): array在运行时能知道且强制要求元素的类型</p></li><li>generics are implemented by erasure(non-reifiable): 仅仅在编译时知道元素的类型</li><li>数组和泛型同时使用时会受到很大限制<ul><li>以下语句均不能通过编译：<code>new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]</code>；但是声明是可以的，例如<code>List&lt;String&gt;[] stringLists</code></li></ul></li><li>non-reifiable type: 例如<code>E, List&lt;E&gt;, List&lt;String&gt;</code>，这些类型在运行时的信息比编译时的信息更少</li><li>只有unbounded wildcard type才是reifiable的，如：<code>List&lt;?&gt;, Map&lt;?, ?&gt;</code></li><li>常规来说，不能返回泛型元素的数组，因为会报编译错误：<code>generic array creation errors</code></li><li>当泛型和<code>varargs</code>一起使用时，也会导致编译警告</li><li>有时为了类型安全，不得不做些妥协，牺牲性能和简洁，使用List而不是数组</li><li>把数组强转为non-reifiable类型是非常危险的，仅应在非常确定类型安全的情况下使用</li></ul></li><li>Item 26: Favor generic types<ul><li>当需要一个类成员的数据类型具备一般性时，应该用泛型，这也正是泛型的设计场景之一，不应该用Object类</li><li>但使用泛型有时也不得不进行cast，例如当泛型遇上数组</li><li>总的来说把suppress数组类型强转的unchecked warning比suppress一个标量类型强转的unchecked warning风险更大，但有时出于代码简洁性考虑，也不得不做出妥协</li><li>有时看似与item 25矛盾，实属无奈，Java原生没有List，ArrayList不得不基于数组实现，HashMap也是基于数组实现的</li><li>泛型比使用者进行cast更加安全，而且由于Java泛型的擦除实现，也可以和未做泛型的老代码无缝兼容</li></ul></li><li><p>Item 27: Favor generic methods</p><ul><li><p>泛型方法的类型参数在函数修饰符（可见性/static/final等）和返回值之间，例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>recursive type bound</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using a recursive type bound to express mutual comparability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型方法要比方法使用者进行cast更加安全</p></li></ul></li><li><p>Item 28: Use bounded wildcards to increase API flexibility</p><ul><li>考虑以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Iterable&lt;Integer&gt; integers = ... ;</span><br><span class="line">numberStack.pushAll(integers);</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = ... ;</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></li></ul><p>pushAll和popAll的调用均无法通过编译，因为尽管<code>Integer</code>是<code>Number</code>的子类，但<code>Iterable&lt;Integer&gt;</code>不是<code>Iterable&lt;Number&gt;</code>的子类，这是由泛型的invariant特性导致的，所以<code>Iterable&lt;Integer&gt;</code>不能传入接受<code>Iterable&lt;Number&gt;</code>参数的函数，popAll的使用同理</p><ul><li>bounded wildcards: <code>&lt;? extends E&gt;</code>, <code>&lt;? super E&gt;</code>, PECS stands for producer-extends, consumer-super. 如果传入的参数是要输入给该类型数据的，则应该使用extends，如果是要容纳该类型数据的输出，则应该使用super</li><li>这很好理解，作为输入是要赋值给E类型的，当然应该是E的子类（这里的extends包括E类型本身）；而容纳输出是要把E赋值给传入参数的，当然应该是E的父类（同样包括E本身）</li><li>返回值类型不要使用bounded wildcards，否则使用者也需要使用，这将会给使用者造成麻烦</li><li>代码对于bounded wildcards的使用在使用者那边应该是透明的，即他们不会感知到bounded wildcards的存在，如果他们也需要考虑bounded wildcards的问题，则说明对bounded wildcards的使用有问题了</li><li><p>有时候编译器的类型推导在遇到bounded wildcards会无法完成，这时就需要显示指定类型信息，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span></span>;</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; integers = ... ;</span><br><span class="line">Set&lt;Double&gt; doubles = ... ;</span><br><span class="line"><span class="comment">//Set&lt;Number&gt; numbers = union(integers, doubles); //compile error</span></span><br><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);  <span class="comment">//compile pass</span></span><br></pre></td></tr></table></figure></li><li><p>Comparables are always consumers, so you should always use <code>Comparable&lt;? super T&gt;</code> in preference to <code>Comparable&lt;T&gt;</code>. The same is true of comparators, so you should always use <code>Comparator&lt;? super T&gt;</code> in preference to <code>Comparator&lt;T&gt;</code>.</p></li><li>unbounded type parameter(<code>&lt;E&gt; ... List&lt;E&gt;</code>) v.s. unbounded wildcard(<code>List&lt;?&gt;</code>)：if a type parameter appears only once in a method declaration, replace it with a wildcard.</li></ul></li><li><p>Item 29: Consider typesafe heterogeneous containers</p><ul><li>使用泛型时，类型参数是有限个的，例如<code>List&lt;T&gt;</code>，<code>Map&lt;K, V&gt;</code>，但有时可能需要一个容器，能放入任意类型的对象，但需要具备类型安全性，例如数据库的一行，它的每一列都可能是任意类型的数据</li><li><p>由于<code>Class</code>类从1.5就被泛型化了，所以使得这种需求可以实现，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - API</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通常这样使用的<code>Class</code>对象被称为type token，它传入函数，用来表述编译时和运行时的类型信息</p></li><li><p><code>Favorites</code>的实现也是很简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - implementation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</span><br><span class="line">        favorites.put(type, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意，这里的unbound wildcard并不是应用于Map的，而是应用于Class的类型参数，因此Map可以put key进去，而且key可以是任意类型参数的Class对象</p></li><li>另外，Map的value类型是Object，一旦put到Map中去，其编译期类型信息就丢失了，将通过get方法的动态类型转换（cast）来重新获得其类型信息</li><li>cast方法将检查类型信息，如果是该类型（或其子类），转换将成功，并返回引用，否则将抛出ClassCastException</li><li><p>这一heterogeneous container实现有两个不足</p><ul><li>通过为put方法传入Class的raw type，使用者可以很轻易地破坏类型安全性，解决方案也很简单，在put时也进行一下cast：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Achieving runtime type safety with a dynamic cast</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样做的效果是使得想要破坏类型安全性的put使用者产生异常，而使用get的使用者则不会因为恶意put使用者产生异常。这种做法也被<code>java.util.Collections</code>包中的一些方法使用，例如命名为checkedSet, checkedList, checkedMap的类。</p><ul><li>这个容器内不能放入non-reifiable的类型，例如<code>List&lt;String&gt;</code>，因为<code>List&lt;String&gt;.class</code>是有语法错误的，<code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code>都只有同一个class对象：<code>List.class</code>；另外<code>String[].class</code>是合法的。</li></ul></li><li><code>Favorites</code>使用的类型参数是unbounded的，可以put任意类型，也可以使用bounded type token，使用bounded时可能需要把<code>Class&lt;?&gt;</code>转换为<code>Class&lt;? extends Annotation&gt;</code>，直接用<code>class.cast</code>将会导致unchecked warning，可以通过<code>class.asSubclass</code>来进行转换，例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of asSubclass to safely cast to a bounded type token</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Annotation <span class="title">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = <span class="keyword">null</span>; <span class="comment">// Unbounded type token</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element.getAnnotation(annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>##Enums and Annotations</p><ul><li><p>Item 30: Use enums instead of int constants</p><ul><li>类型安全</li><li>可以为常量提供数据和方法的绑定</li><li>可以遍历</li><li><p>实现建议</p><ul><li>如果是通用的，应该定义为top level enum，否则应定义为内部类</li><li><p>constant-specific method implementations</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific method implementations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS   &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x + y;&#125; &#125;,</span><br><span class="line">    MINUS  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x - y;&#125; &#125;,</span><br><span class="line">    TIMES  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x * y;&#125; &#125;,</span><br><span class="line">    DIVIDE &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x / y;&#125; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结合constant-specific data</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific class bodies and data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS(<span class="string">"+"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    Operation(String symbol) &#123; <span class="keyword">this</span>.symbol = symbol; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> symbol; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If switch statements on enums are not a good choice for implementing con- stant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting external enum types with constant-specific behavior.</p></li></ul></li><li>A minor performance disadvantage of enums over int constants is that there is a space and time cost to load and initialize enum types.</li><li>所以，在安卓设备（手机、平板）上，应该避免使用enum，减小空间和时间的开销</li></ul></li><li>Item 31: Use instance fields instead of ordinals<ul><li>每个enum的常量都有一个<code>ordinal()</code>方法获取其在该enum类型中的位置，但该方法只应该在实现<code>EnumSet</code>, <code>EnumMap</code>等类型的时候被使用，其他情形都不应该被使用</li><li>如果需要为每一个常量绑定一个数据，可以使用instance field实现，如果需要绑定方法，则可以用constant-specific method implementations，参考上一个item</li></ul></li><li>Item 32: Use EnumSet instead of bit fields<ul><li>bit fields的方式不优雅、容易出错、没有类型安全性</li><li>EnumSet则没有这些缺点，而且对于大多数enum类型来说，其性能都和bit field相当</li><li>通用建议：声明变量时，不要用实现类型，应该用接口类型，例如，应该用<code>List&lt;Integer&gt;</code>而不是<code>ArrayList&lt;Integer&gt;</code></li><li>EnumSet并非immutable的，可以通过<code>Conllections.unmodifiableSet</code>来封装为immutable，但是代码简洁性与性能都将受到影响</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Effective-Java一书笔记&quot;&gt;&lt;a href=&quot;#Effective-Java一书笔记&quot; class=&quot;headerlink&quot; title=&quot;Effective Java一书笔记&quot;&gt;&lt;/a&gt;Effective Java一书笔记&lt;/h1&gt;&lt;h2 id=&quot;对象的创建与销毁&quot;&gt;&lt;a href=&quot;#对象的创建与销毁&quot; class=&quot;headerlink&quot; title=&quot;对象的创建与销毁&quot;&gt;&lt;/a&gt;对象的创建与销毁&lt;/h2&gt;&lt;ul&gt;&lt;li&gt;Item 1: 使用static工厂方法，而不是构造函数创建对象&lt;br&gt;仅仅是创建对象的方法，并非Factory Pattern&lt;ul&gt;&lt;li&gt;优点&lt;ul&gt;&lt;li&gt;命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义&lt;/li&gt;&lt;li&gt;Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutable的对象来说，使得用&lt;code&gt;==&lt;/code&gt;判等符合语义，且更高效；&lt;/li&gt;&lt;li&gt;工厂方法能够返回任何返回类型的子类对象，甚至是私有实现；使得开发模块之间通过接口耦合，降低耦合度；而接口的实现也将更加灵活；接口不能有static方法，通常做法是为其再创建一个工厂方法类，如Collection与Collections；&lt;/li&gt;&lt;li&gt;Read More: Service Provider Framework&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;缺点&lt;ul&gt;&lt;li&gt;仅有static工厂方法，没有public/protected构造函数的类将无法被继承；见仁见智，这一方面也迫使开发者倾向于组合而非继承；&lt;/li&gt;&lt;li&gt;Javadoc中不能和其他static方法区分开，没有构造函数的集中显示优点；但可以通过公约的命名规则来改善；&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;小结&lt;br&gt;static工厂方法和public构造函数均有其优缺点，在编码过程中，可以先考虑一下工厂方法是否合适，再进行选择。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Item 2: 使用当构造函数的参数较多，尤其是其中还有部分是可选参数时，使用Builder模式&lt;ul&gt;&lt;li&gt;以往的方法&lt;ul&gt;&lt;li&gt;Telescoping constructor：针对可选参数，从0个到最多个，依次编写一个构造函数，它们按照参数数量由少到多逐层调用，最终调用到完整参数的构造函数；代码冗余，有时还得传递无意义参数，而且容易导致使用过程中出隐蔽的bug；&lt;/li&gt;&lt;li&gt;JavaBeans Pattern：灵活，但是缺乏安全性，有状态不一致问题，线程安全问题；&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;Builder Pattern&lt;ul&gt;&lt;li&gt;代码灵活简洁；具备安全性；&lt;/li&gt;&lt;li&gt;immutable&lt;/li&gt;&lt;li&gt;参数检查：最好放在要build的对象的构造函数中，而非builder的构建过程中&lt;/li&gt;&lt;li&gt;支持多个field以varargs的方式设置（每个函数只能有一个varargs）&lt;/li&gt;&lt;li&gt;一个builder可以build多个对象&lt;/li&gt;&lt;li&gt;Builder结合泛型，实现Abstract Factory Pattern&lt;/li&gt;&lt;li&gt;传统的抽象工厂模式，是用Class类实现的，然而其有缺点：newInstance调用总是去调用无参数构造函数，不能保证存在；newInstance方法会抛出所有无参数构造函数中的异常，而且不会被编译期的异常检查机制覆盖；可能会导致运行时异常，而非编译期错误；&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;li&gt;小结&lt;br&gt;Builder模式在简单地类（参数较少，例如4个以下）中，优势并不明显，但是需要予以考虑，尤其是当参数可能会变多时，有可选参数时更是如此。&lt;/li&gt;&lt;/ul&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="读书笔记" scheme="http://windylee.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Java" scheme="http://windylee.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>MongoDb索引</title>
    <link href="http://windylee.cn/posts/c2f6f9e3/"/>
    <id>http://windylee.cn/posts/c2f6f9e3/</id>
    <published>2015-10-20T07:49:29.000Z</published>
    <updated>2018-02-21T16:28:25.427Z</updated>
    
    <content type="html"><![CDATA[<h4 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h4><p>索引是用来加速查询的，类似于数的目录一样。我们要查找某些内容不需要查遍整个数据库，只需要先在索引中查找，找到相应索引之后根据索引找到指向的文档。<br>创建索引使用ensureIndex函数，<code>db.people.ensureIndex({&#39;username&#39;:1})</code>,1代表对索引内容进行正向排序，-1代表对索引内容逆向排序。对某个键创建的索引会加速以该键为查询条件的查询，对其他查询没有帮助。索引创建既可以针对单个键创建也可以针对多个键创建，例如<code>db.people.ensureIndex({&#39;name&#39;:1,age:-1,&#39;sex&#39;:1})</code>其作用原理与sort相同(由前到后逐个匹配)。如果创建了我们上面所看到的索引实际上是有了<code>{name:1}</code>,<code>{name:1,age:-1}</code>,<code>{name:1,age:-1,sex:1}</code>三个索引，使用{age:-1}等索引的查询不会得到优化。<br>创建索引并不是只有优点的，他的缺点就是每次插入，更新，删除都会产生额外的开销用来更新索引。所以我们要根据实际情况合理的创建索引，通常我们要考虑实际情况中都需要经常对哪些键查询，然后对该查询字段创建索引，每个集合的最大索引个数为64个</p><h5 id="注意索引顺序"><a href="#注意索引顺序" class="headerlink" title="注意索引顺序"></a>注意索引顺序</h5><p>当我们创建多键索引时要分清主次，一般我们可以这样认为，当根据我们创建的多键索引进行查询时会先根据前面的条件筛选，将结果用于下一次筛选。所以创建多键索引时我们要将主要索引条件放在前面，建立索引时要考虑如下问题：</p><ol><li>会做什么样的查询，其中哪些键需要索引</li><li>每个键的索引方向是怎样的</li><li>如何应对拓展，有没有种不同的键的排列可以是常用数据更多地保存在内存中</li></ol><a id="more"></a><h5 id="索引内嵌文档"><a href="#索引内嵌文档" class="headerlink" title="索引内嵌文档"></a>索引内嵌文档</h5><p>为内嵌文档建立索引和为普通的键创建索引没有什么区别，只是在索引内嵌文档的字段的时候使用<strong>点表达式</strong>，也可以和普通键索引组成复合索引</p><h5 id="为排序创建索引"><a href="#为排序创建索引" class="headerlink" title="为排序创建索引"></a>为排序创建索引</h5><p>随着集合的增长，需要针对大量的排序做索引。因为如果排序实在内存中完成的，如果数据量特别大超出内存的限制就是报错。如果没有对数据进行sort，默认就是查询出来的顺序，所以创建索引之后查询出来的顺序就是排序之后的结果</p><h5 id="索引名称"><a href="#索引名称" class="headerlink" title="索引名称"></a>索引名称</h5><p>每一个索引都有一个字符串类型的名字用来唯一标示，数据库通过这个名字来删除或操作索引。默认情况索引名类似keyname1_dir1_keyname2_dir2…形式（keynameX代表索引的键，dirX代表索引的方向）。我们可以通过ensureIndex的第二个参数来指定索引的名字<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.ensureIndex(&#123;<span class="string">'name'</span>:<span class="number">1</span>,<span class="string">'age'</span>:<span class="number">-1</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'index1'</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一所以可以确保集合的每一个文档的指定键都有唯一的值，相当于关系型数据库中的unique键。要创建唯一索引需要在ensureIndex的第二个参数中指定unique为true。在创建集合是自动给我们创建了<code>_id</code>唯一索引，与普通唯一索引的区别是不能被删除<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.ensureIndex(&#123;<span class="string">'username'</span>:<span class="number">1</span>&#125;,&#123;<span class="string">'unique'</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p>可能当我们创建唯一索引的时候，有些值已经有重复了，这时候索引的创建就会失败。但是我们可以使用dropDups选项，这样可以保留发现的第一个文档，将其他重复文档删除<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.ensureIndex(&#123;<span class="string">'username'</span>:<span class="number">1</span>&#125;,&#123;<span class="string">'unique'</span>:<span class="literal">true</span>, <span class="string">'dropDups'</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p>创建符合唯一索引的时候，单个键的值可以相同，只要所有键的值组合起来不同就好</p><h4 id="强制使用索引"><a href="#强制使用索引" class="headerlink" title="强制使用索引"></a>强制使用索引</h4><p>如果发现MongoDb没有使用预期的索引，可以用hint强制使用某个索引。例如希望使用<code>{&#39;username&#39;:1,&#39;age&#39;:1}</code>索引<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.find(&#123;<span class="string">'age'</span>:<span class="number">14</span>,<span class="string">'username'</span>:<span class="string">'nicolas'</span>&#125;).hint(&#123;<span class="string">'username'</span>:<span class="number">1</span>,<span class="string">'age'</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p>多数情况下并没有这么做的必要，MongoDb会非常智能的选择使用哪个索引。在初次查询时会尝试各种查询方案，最优方案会被记录下来，还会定期重试其他方案，防止建立新的索引之后方案不再是最优</p><h4 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h4><p>索引的原信息存储在每个数据库的system.indexes集合中，不能对该集合插入或删除文档，操作只能通过ensureIndex和dropIndex进行<br>建立索引既耗时有费力，还需要消耗很多资源，可以使用<code>{&#39;background&#39;:true}</code>选项是这个过程在后台完成，同时正常处理请求。一般来说为已有文档创建索引比先创建索引再插入所有文档要稍快一些。不管怎么说在无关紧要的时刻创建索引是最好的选择<br>当索引没用的时候可以通过dropIndex选项删除索引,删除依据是创建索引的条件<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.dropIndex(&#123;<span class="string">'username'</span>:<span class="number">1</span>,<span class="string">'age'</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><h4 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h4><p>MongoDb为坐标平面提供了专门的索引成为地理空间索引，可以找出离某一坐标平面最近的点。创建地理空间索引同样适用ensureIndex选项，只不过参数不是1或-1而是2d。建立索引的键的值必须是包含两个元素的数组或包含两个键的内嵌文档(键名可以随意)。地理空间索引默认的范围是180·-180，如果想要指定大小可以使用第二个参数<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.start.insureIndex(&#123;<span class="string">'light-year'</span>:<span class="string">'2d'</span>&#125;,&#123;<span class="string">'min'</span>:<span class="number">-1000</span>,<span class="string">'max'</span>:<span class="number">1000</span>&#125;)</span><br></pre></td></tr></table></figure><p></p><p>地理空间索引的查询和普通的find查询差别不大，只不过使用了<code>$near</code>，需要两个目标值的数组作为参数，默认返回100个距离给点坐标最近的文档，可以使用limit进行限制。还可以使用<code>$maxDistance</code>限定查询的最大距离<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$near</span>:[<span class="number">40</span>,<span class="number">-73</span>], <span class="attr">$maxDistance</span>:<span class="number">40</span>&#125;&#125;).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p></p><p>MongoDb不仅可以根据距离查询，还可以根据形状查询，目前支持矩形,圆形查询和多边形查询，需要用到<code>$within</code><br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要给出矩形左上角和右下角坐标</span></span><br><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$within</span>:&#123;<span class="attr">$box</span>:&#123;[<span class="number">10</span>,<span class="number">30</span>],[<span class="number">15</span>,<span class="number">40</span>]&#125;&#125;&#125;&#125;)</span><br><span class="line"><span class="comment">//需要圆的原点坐标和半径</span></span><br><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$within</span>:&#123;<span class="attr">$circle</span>:&#123;[<span class="number">10</span>,<span class="number">20</span>],<span class="number">40</span>&#125;&#125;&#125;&#125;)</span><br><span class="line"><span class="comment">//多边形各个点的坐标</span></span><br><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$within</span>:&#123;<span class="attr">$polygon</span>:[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">3</span>]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure><p></p><p>我们可以组合地理空间索引和普通索引，这样可以满足继续要地里空间限制条件组合普通限制条件的查找<br></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.ensureIndex(&#123;<span class="string">'location'</span>:<span class="string">'2d'</span>,<span class="string">'desc'</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure><p></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;索引简介&quot;&gt;&lt;a href=&quot;#索引简介&quot; class=&quot;headerlink&quot; title=&quot;索引简介&quot;&gt;&lt;/a&gt;索引简介&lt;/h4&gt;&lt;p&gt;索引是用来加速查询的，类似于数的目录一样。我们要查找某些内容不需要查遍整个数据库，只需要先在索引中查找，找到相应索引之后根据索引找到指向的文档。&lt;br&gt;创建索引使用ensureIndex函数，&lt;code&gt;db.people.ensureIndex({&amp;#39;username&amp;#39;:1})&lt;/code&gt;,1代表对索引内容进行正向排序，-1代表对索引内容逆向排序。对某个键创建的索引会加速以该键为查询条件的查询，对其他查询没有帮助。索引创建既可以针对单个键创建也可以针对多个键创建，例如&lt;code&gt;db.people.ensureIndex({&amp;#39;name&amp;#39;:1,age:-1,&amp;#39;sex&amp;#39;:1})&lt;/code&gt;其作用原理与sort相同(由前到后逐个匹配)。如果创建了我们上面所看到的索引实际上是有了&lt;code&gt;{name:1}&lt;/code&gt;,&lt;code&gt;{name:1,age:-1}&lt;/code&gt;,&lt;code&gt;{name:1,age:-1,sex:1}&lt;/code&gt;三个索引，使用{age:-1}等索引的查询不会得到优化。&lt;br&gt;创建索引并不是只有优点的，他的缺点就是每次插入，更新，删除都会产生额外的开销用来更新索引。所以我们要根据实际情况合理的创建索引，通常我们要考虑实际情况中都需要经常对哪些键查询，然后对该查询字段创建索引，每个集合的最大索引个数为64个&lt;/p&gt;&lt;h5 id=&quot;注意索引顺序&quot;&gt;&lt;a href=&quot;#注意索引顺序&quot; class=&quot;headerlink&quot; title=&quot;注意索引顺序&quot;&gt;&lt;/a&gt;注意索引顺序&lt;/h5&gt;&lt;p&gt;当我们创建多键索引时要分清主次，一般我们可以这样认为，当根据我们创建的多键索引进行查询时会先根据前面的条件筛选，将结果用于下一次筛选。所以创建多键索引时我们要将主要索引条件放在前面，建立索引时要考虑如下问题：&lt;/p&gt;&lt;ol&gt;&lt;li&gt;会做什么样的查询，其中哪些键需要索引&lt;/li&gt;&lt;li&gt;每个键的索引方向是怎样的&lt;/li&gt;&lt;li&gt;如何应对拓展，有没有种不同的键的排列可以是常用数据更多地保存在内存中&lt;/li&gt;&lt;/ol&gt;
    
    </summary>
    
      <category term="MongoDb" scheme="http://windylee.cn/categories/MongoDb/"/>
    
    
      <category term="Database" scheme="http://windylee.cn/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDb查询</title>
    <link href="http://windylee.cn/posts/f3e67b24/"/>
    <id>http://windylee.cn/posts/f3e67b24/</id>
    <published>2015-10-18T11:30:51.000Z</published>
    <updated>2018-02-21T16:28:25.427Z</updated>
    
    <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>使用find或者findOne对数据库执行查询</li><li>使用<code>$</code>条件实现范围，集合包含，不等式和其他查询</li><li>使用<code>$where</code>子句用户复杂查询</li><li>查询会返回一个数据库游标，只有在需要数据的时候才会惰性的返回文档</li><li>针对游标执行的元操作，比如忽略一定数量的结果，限定返回结果的数量，对结果进行排序</li></ul><h4 id="find简介"><a href="#find简介" class="headerlink" title="find简介"></a>find简介</h4><blockquote><p>db.users.find()<br>db.users.find({‘name’:’nicolas’,’age’:20})</p></blockquote><p>不带参数的find会返回全部文档。find可以指定查询文档，只返回匹配查询条件的文档，当查询文档含有多个K-V时连接条件为AND,第二个查询语句会返回name为nicolas并且age为20的文档</p><ul><li>指定返回的键<blockquote><p>db.users.find({},{‘name’:1,’age’:0})</p></blockquote></li></ul><p>有时我们并不需要将文档中的所有K-V都返回，这种情况我们可以使用find函数的第二个参数指定要返回的键。其中1代表将返回的文档按照该字段正向排序，0代表将返回的文档按照该字段逆向排序</p><ul><li>限制<blockquote><p>db.stock.find({‘in_stock’:’this.num_sold’})</p></blockquote></li></ul><p>查询文档必须是常量（在自己代码里可以使正常的变量），但是不能引用文档中其他键的值。故上面的这个查询是错误的</p><h4 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h4><h5 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h5><p><code>$gt</code>,<code>$gte</code>,<code>$gt</code>,<code>gte</code>是全部的比较操作符，分别对应<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>，可以将其组合起来查找一个范围的值。其中对于日期查询尤为有用，因为对日期的精确匹配终究是徒劳的。</p><blockquote><p>db.users.find({‘age’:{$lt:30,$gt:20}) 查找年龄大于20小于30的人</p><p>start = new Date(“01/01/2007”)<br>db.users.find(‘registered’:{$lt:start}) 查找注册日期在2007年1月1日之前的用户</p></blockquote><a id="more"></a><h5 id="OR查询"><a href="#OR查询" class="headerlink" title="OR查询"></a>OR查询</h5><ul><li><p><code>$in</code>可以用来查询键值在给定数组中的文档，与之相反的是<code>$nin</code>。这两者用来对单个键做OR查询</p><blockquote><p>db.users.find({‘name’:{$in:[‘nicolas’,’windylee’]}) 返回name为nicolas或windylee的文档</p></blockquote></li><li><p><code>$or</code>可以对多个键做OR查询，<code>$or</code>接受一个包含所有可能条件的数组作为参数，只要符合数组中任何一个元素的条件就会被查询出来，<code>$or</code>可以包含其他条件。普通的and兴的查询，总是尽可能的用最少的条件来限定结果的范围，or型的查询真好相反，第一个条件尽可能地匹配更多的文档</p><blockquote><p>db.users.find({$or:[{‘name’:{$in:[‘nicolas’,’windylee’]}},’age’:20]}) 查询name为nicolas或windylee或age为20的用户</p></blockquote></li></ul><h5 id="not查询"><a href="#not查询" class="headerlink" title="$not查询"></a><code>$not</code>查询</h5><p><code>$not</code>是元条件句，可以用在任何其他条件之上，表示对其他条件的结果取反。经常与正则表达式联合使用，用来查询不匹配正则表达式的文档</p><blockquote><p>db.users.find({‘age’:{$not:{$mod:[5,1]}}) 查询age值模5余数不为1的文档</p></blockquote><h5 id="条件句的规则"><a href="#条件句的规则" class="headerlink" title="条件句的规则"></a>条件句的规则</h5><p>条件句是内层文档的键，修改器是外层文档的键，可对一个键应用多个条件，但是一个键不能对应多个更新修改器。例如<code>{$inc:{&#39;age&#39;:20},$set:{&#39;age&#39;:40}}</code>修改了age两次</p><h4 id="特定于类型的查询"><a href="#特定于类型的查询" class="headerlink" title="特定于类型的查询"></a>特定于类型的查询</h4><h5 id="空值查询"><a href="#空值查询" class="headerlink" title="空值查询"></a>空值查询</h5><ul><li>null<br>null不仅能够匹配到键值为null的文档，他还能匹配缺少这个键的所有文档</li><li><code>$exists</code><br>如果仅仅想匹配键值为null的文档，就需要使用到该关键字<blockquote><p>db.users.find({‘name’:{$exists:true}}) 返回name值不为空的文档</p></blockquote></li></ul><h5 id="查询数组"><a href="#查询数组" class="headerlink" title="查询数组"></a>查询数组</h5><ul><li><p><code>$ll</code><br>返回含有<code>$all</code>指向数组所有元素的文档</p><blockquote><p>db.users.find(‘course’:{$all:[‘english’,’chinese’]}) 返回课程含有english和chinese的用户</p></blockquote></li><li><p><code>$size</code><br>返回数组长度为指定大小的文档，<code>$size</code>不能与其他查询子句组合(比如<code>$gt</code>)</p><blockquote><p>db.users.find({‘course’:{$size:3}}) 返回选了3门课的文档</p></blockquote></li><li><p><code>$slice</code><br>返回一个数组的子集合。可以接受一个整型n，整数表示返回数组的前n条数据，负数表示返回数组的后n条数据；可以接受一个数组，数组的第一个元素表示偏移量，第二个元素表示获取的元素数量。除非特别声明，<code>$slice</code>返回文档中的所有键</p><blockquote><p>db.blog.posts.findOne(criteria,{‘comments’:{$slice,[1,2]}}) 默认会返回posts中的所有字段</p></blockquote></li></ul><h5 id="查询内嵌文档"><a href="#查询内嵌文档" class="headerlink" title="查询内嵌文档"></a>查询内嵌文档</h5><p>如果存在如下文档<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">'name'</span>:&#123;</span><br><span class="line">    <span class="string">'first'</span>:<span class="string">'Jone'</span></span><br><span class="line">        <span class="string">'last'</span>:<span class="string">'Schmoe'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>要查询姓名为Jon Schmoe的人可以这样<code>db.people.find({&#39;name&#39;:{&#39;first&#39;:&#39;Jon&#39;,&#39;last&#39;:&#39;Schmoe&#39;}})</code>这种方式采用全部匹配的规则，即查询条件中要包含内嵌文档的所有键，如果name内嵌文档中增加middle字段则上述查询条件就不起作用了。如果只想根据部分字段进行查询则需要点表达式<code>db.people.find({&#39;name.first&#39;:&#39;Joe&#39;,&#39;name.last&#39;:&#39;Schmoe&#39;})</code>，这也是带插入的文档不能包含’.’的原因<br>当文档变负责以后，即内嵌文档为数组时，如果有如下文档<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">'content'</span>:<span class="string">'...'</span></span><br><span class="line">    <span class="string">'comments'</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'author'</span>:<span class="string">'joe'</span>,</span><br><span class="line">            <span class="string">'score'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'comment'</span>:<span class="string">'nice post'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">'author'</span>:<span class="string">'mary'</span>,</span><br><span class="line">            <span class="string">'score'</span>:<span class="number">6</span>,</span><br><span class="line">            <span class="string">'comment'</span>:<span class="string">'terrible post'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果继续使用点表达式<code>db.blog.find({&#39;comments.author&#39;:&#39;jone&#39;,&#39;score&#39;:6})</code>则第一个条件会在comments1中找到，第二个条件会在comments2中找到，所以会返回我们上面看到的文档。若要正确指定一组条件我们需要<code>$elemMatch</code>，这种模糊的命名条件句能用来部分指定匹配数组中的单个嵌入文档的限定条件，所以正确的写法应该是这样的<code>db.blog.find({&#39;comments&#39;:{$eleMatch:{&#39;author:&#39;Jone&#39;,&#39;score&#39;:&#39;6}}})</code></p><h4 id="where查询"><a href="#where查询" class="headerlink" title="$where查询"></a><code>$where</code>查询</h4><p>我们上面说过find的查询条件只能是常量，不能是文档中的值，如果我们查询条件为文档中的数据，那这时候我们就需要<code>$where</code>子句了，例如<code>db.foo.find({$where:&#39;this.x+this.y=10&#39;})</code>。<code>$where</code>速度要慢很多，除非必要不要使用该条件。</p><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>数据库使用游标来返回find的执行结果，客户端队游标的实现通常能够对最终结果进行有效的控制，可以限制结果的数量，略过部分结果，根据任意方向任意键的组合对结果进行各种排序，或者执行其他一些功能强大的操作。当调用find的时候并不立即查询数据库，而是等待真正开始要求获得结果的时候才发送查询，这样我们就可以在执行之前给查询附加额外的选项</p><h5 id="limit-skip-sort"><a href="#limit-skip-sort" class="headerlink" title="limit, skip, sort"></a>limit, skip, sort</h5><p>limit限定返回结果的上限，skip跳过前n个匹配的文档；sort指定排序的键和排序条件，1为正序排序，-1为降序排序，如果指定了多个键，则按照多个键的顺序逐个排序，例如要按照username升序和age降序排序<code>db.c.find().sort({&#39;username&#39;:1,&#39;age&#39;:-1})</code>。find函数返回游标，这三个函数都可以组成链式操作。如果一个键对应不同的类型，则规定的类型顺序：最小值 &lt; null &lt; 数字（整形，长整形，双精度）&lt; 字符串 &lt; 对象/文旦 &lt; 数组 &lt; 二进制数据 &lt; 对象ID &lt; 布尔型 &lt; 日期型 &lt; 时间戳 &lt; 正则表达式 &lt; 最大值</p><h5 id="避免使用skip略过大量结果"><a href="#避免使用skip略过大量结果" class="headerlink" title="避免使用skip略过大量结果"></a>避免使用skip略过大量结果</h5><p>使用skip略过大量结果就会使操作变得非常缓慢，几乎所有的数据库都有这个问题，所以我们应尽量避免使用skip</p><ul><li>不用skip对结果分页<br>分页最简单的方式就是结合使用limit和skip两个函数，但我们可以有更好的解决方案。例如我们最获取文档时一般按照时间顺序进行排序，我们可以获取第一次获取的文档最后一个的时间，然后可以利用该时间值最为查询条件来获取下一页</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> latest=<span class="literal">null</span></span><br><span class="line"><span class="keyword">while</span>(page1.hasNext())&#123;</span><br><span class="line">latest=page1.next();</span><br><span class="line">    display(latest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> page2=db.foo.find(&#123;<span class="string">'date'</span>:&#123;<span class="attr">$gt</span>:latest.date&#125;).sort(<span class="string">'date'</span>:<span class="number">-1</span>).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>随机选取文档<br>一般做法是要查询文档总数，然后在0~n中选择一个随机数，使用skip跳过这些随机数来获取随机的一个文档。这样查询总数和使用skip略过文档都需要花费大量时间。我们可以再一开始就在文档中插入一个随机数的键，然后根据该随机数获取随机文档</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.people.insert(&#123;<span class="string">'name'</span>:<span class="string">'nicolas'</span>,<span class="string">'random'</span>:<span class="built_in">Math</span>.random()&#125;)</span><br><span class="line">db.people.findOne(&#123;<span class="attr">random</span>:&#123;<span class="attr">$lt</span>:<span class="built_in">Math</span>.random()&#125;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;使用find或者findOne对数据库执行查询&lt;/li&gt;&lt;li&gt;使用&lt;code&gt;$&lt;/code&gt;条件实现范围，集合包含，不等式和其他查询&lt;/li&gt;&lt;li&gt;使用&lt;code&gt;$where&lt;/code&gt;子句用户复杂查询&lt;/li&gt;&lt;li&gt;查询会返回一个数据库游标，只有在需要数据的时候才会惰性的返回文档&lt;/li&gt;&lt;li&gt;针对游标执行的元操作，比如忽略一定数量的结果，限定返回结果的数量，对结果进行排序&lt;/li&gt;&lt;/ul&gt;&lt;h4 id=&quot;find简介&quot;&gt;&lt;a href=&quot;#find简介&quot; class=&quot;headerlink&quot; title=&quot;find简介&quot;&gt;&lt;/a&gt;find简介&lt;/h4&gt;&lt;blockquote&gt;&lt;p&gt;db.users.find()&lt;br&gt;db.users.find({‘name’:’nicolas’,’age’:20})&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;不带参数的find会返回全部文档。find可以指定查询文档，只返回匹配查询条件的文档，当查询文档含有多个K-V时连接条件为AND,第二个查询语句会返回name为nicolas并且age为20的文档&lt;/p&gt;&lt;ul&gt;&lt;li&gt;指定返回的键&lt;blockquote&gt;&lt;p&gt;db.users.find({},{‘name’:1,’age’:0})&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;有时我们并不需要将文档中的所有K-V都返回，这种情况我们可以使用find函数的第二个参数指定要返回的键。其中1代表将返回的文档按照该字段正向排序，0代表将返回的文档按照该字段逆向排序&lt;/p&gt;&lt;ul&gt;&lt;li&gt;限制&lt;blockquote&gt;&lt;p&gt;db.stock.find({‘in_stock’:’this.num_sold’})&lt;/p&gt;&lt;/blockquote&gt;&lt;/li&gt;&lt;/ul&gt;&lt;p&gt;查询文档必须是常量（在自己代码里可以使正常的变量），但是不能引用文档中其他键的值。故上面的这个查询是错误的&lt;/p&gt;&lt;h4 id=&quot;查询条件&quot;&gt;&lt;a href=&quot;#查询条件&quot; class=&quot;headerlink&quot; title=&quot;查询条件&quot;&gt;&lt;/a&gt;查询条件&lt;/h4&gt;&lt;h5 id=&quot;比较操作符&quot;&gt;&lt;a href=&quot;#比较操作符&quot; class=&quot;headerlink&quot; title=&quot;比较操作符&quot;&gt;&lt;/a&gt;比较操作符&lt;/h5&gt;&lt;p&gt;&lt;code&gt;$gt&lt;/code&gt;,&lt;code&gt;$gte&lt;/code&gt;,&lt;code&gt;$gt&lt;/code&gt;,&lt;code&gt;gte&lt;/code&gt;是全部的比较操作符，分别对应&lt;code&gt;&amp;lt;&lt;/code&gt;,&lt;code&gt;&amp;lt;=&lt;/code&gt;,&lt;code&gt;&amp;gt;&lt;/code&gt;,&lt;code&gt;&amp;gt;=&lt;/code&gt;，可以将其组合起来查找一个范围的值。其中对于日期查询尤为有用，因为对日期的精确匹配终究是徒劳的。&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;db.users.find({‘age’:{$lt:30,$gt:20}) 查找年龄大于20小于30的人&lt;/p&gt;&lt;p&gt;start = new Date(“01/01/2007”)&lt;br&gt;db.users.find(‘registered’:{$lt:start}) 查找注册日期在2007年1月1日之前的用户&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="MongoDb" scheme="http://windylee.cn/categories/MongoDb/"/>
    
    
      <category term="Database" scheme="http://windylee.cn/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>MongoDb创建，删除，更改</title>
    <link href="http://windylee.cn/posts/9aa16efd/"/>
    <id>http://windylee.cn/posts/9aa16efd/</id>
    <published>2015-10-18T11:09:28.000Z</published>
    <updated>2018-02-21T16:28:25.426Z</updated>
    
    <content type="html"><![CDATA[<h6 id="插入并保存文档"><a href="#插入并保存文档" class="headerlink" title="插入并保存文档"></a>插入并保存文档</h6><blockquote><p>db.foo.insert({‘bar’:baz”})</p></blockquote><p>会自动给文档增加一个”_id”键(如果原来没有的话)。驱动程序会将数据转换成BSON形式，数据库解析BSON，检验是否包含’_id’键，并且文档长度不能超过4MB<br>删除文档</p><blockquote><p>db.users.remove()</p></blockquote><p>会删除users集合中的所有文档，但是不会删除集合本身，原来的索引也会保留。remove函数可以接受一个查询文档作为可选参数，只有符合条件的文档才会被删除，例如 &gt;db.mailing.list.remove({‘opt-out’:true})<br>删除集合</p><blockquote><p>db.users.drop()</p></blockquote><p>会删除users集合，所有的索引也会被删除，速度要比remove()快很多</p><h6 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h6><p>文档存入数据库以后，可以使用update方法来修改他，update有两个参数，一个是查询文档，用来找出要更新的文档，另一个是修改器文档，描述对找到的文档做哪些更改<br><a id="more"></a></p><ul><li>文档替换<blockquote><p>db.users.update({‘name’:’nicolas’},{‘age’:20})</p></blockquote></li></ul><p>完全用一个文档去替换另一个文档，不使用任何关键字，默认文档会变成和第二个参数文档完全一样的形式，例子中更新之后文档中就只有age字段</p><ul><li>使用修改器</li></ul><p>对字段值修改不需要改变文档的大小，修改速度非常快。对数组修改可能需要改变文档的大小，修改速度回慢一下<br><code>$inc</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$age:{‘age’,1}})</p></blockquote><p>更新之后age字段会增加1，当为负数时自减。当键不存在时创建一个键。只能用于整数，长整数和说京都浮点数</p><p><code>$set</code></p><blockquote><p>db.user.update({‘name’:’nicolas’},{$set:{‘age’:20}})</p></blockquote><p>$set用来指定一个键的值，如果这个键不存在就创建他。$set甚至可以修改键的数据类型。$set可以修改内嵌文档，只要将内嵌字段用”.”连接即可，类似于引用对象变量</p><p>`$unset·</p><blockquote><p>db.users.update({‘name’:’nicolas’},{$unset:{‘age’:1}})</p></blockquote><p>会将age的键删除</p><p><code>$push</code><br>如果指定的键已经存在，会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组</p><p><code>$ne</code></p><blockquote><p>db.users.update({‘course’:{$ne:’english’}},{$push:{‘course’:’english’}})</p></blockquote><p>当course字段中不存在english值时，会向course字段数组中放入english</p><p><code>$addToSet</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$addToSet:{‘courses’:’english’}})</p></blockquote><p>当name为nicolas中的course字段数组中不包括english是向其中添加english</p><p><code>$each</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$addToSet:{‘course’:{$each:[‘english’,’chinese’,’math’]}}})</p></blockquote><p>如果不存在这像个课程就像course字段中一次添加这些课程</p><p><code>$pop</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$pop:{‘course’:1}})</p></blockquote><p>可以冲数组的任何一段删除元素，1从数组末尾删除一个元素，-1从数组头部删除</p><p><code>$pull</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$pull:{‘course’:’english’}})</p></blockquote><p>根据特定条件删除元素，例子中删除course数组中值为english的元素</p><p><code>$</code></p><blockquote><p>db.blog.update({‘post’:1},{$inc,{‘comments.0.votes’:1}})</p></blockquote><p>使comments数组下标为0的元素中votes字段的值自增1</p><blockquote><p>db.blog.update({‘comments.author’:’nicolas’},{$inc,{‘comments.$.votes’:1}})</p></blockquote><p>首先会查找comments数组中author为nicolas的元素，记录下其下标。并改变该下标中元素的votes值为1</p><ul><li>upsert</li></ul><blockquote><p>db.person.update({‘name’:’windylee’},{$set:{‘age’:21,’sex’:’man’}},true)</p></blockquote><p>upsert是一种特殊的更新，要是没有文档符合更新调价，就会以这个条件和更新文档为基础创建一个新的文档，如果匹配则正常更新。将update的第三个参数设置为true即可开启此功能。例子中将会插入name，age，sex三个字段</p><ul><li>更新多个文档</li></ul><p>默认情况下，更新只能对符合匹配条件的第一个文档执行操作，要使所有匹配到的文档都得到更新，可以设置update的第四个参数为true</p>]]></content>
    
    <summary type="html">
    
      &lt;h6 id=&quot;插入并保存文档&quot;&gt;&lt;a href=&quot;#插入并保存文档&quot; class=&quot;headerlink&quot; title=&quot;插入并保存文档&quot;&gt;&lt;/a&gt;插入并保存文档&lt;/h6&gt;&lt;blockquote&gt;&lt;p&gt;db.foo.insert({‘bar’:baz”})&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;会自动给文档增加一个”_id”键(如果原来没有的话)。驱动程序会将数据转换成BSON形式，数据库解析BSON，检验是否包含’_id’键，并且文档长度不能超过4MB&lt;br&gt;删除文档&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;db.users.remove()&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;会删除users集合中的所有文档，但是不会删除集合本身，原来的索引也会保留。remove函数可以接受一个查询文档作为可选参数，只有符合条件的文档才会被删除，例如 &amp;gt;db.mailing.list.remove({‘opt-out’:true})&lt;br&gt;删除集合&lt;/p&gt;&lt;blockquote&gt;&lt;p&gt;db.users.drop()&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;会删除users集合，所有的索引也会被删除，速度要比remove()快很多&lt;/p&gt;&lt;h6 id=&quot;更新文档&quot;&gt;&lt;a href=&quot;#更新文档&quot; class=&quot;headerlink&quot; title=&quot;更新文档&quot;&gt;&lt;/a&gt;更新文档&lt;/h6&gt;&lt;p&gt;文档存入数据库以后，可以使用update方法来修改他，update有两个参数，一个是查询文档，用来找出要更新的文档，另一个是修改器文档，描述对找到的文档做哪些更改&lt;br&gt;
    
    </summary>
    
      <category term="MongoDb" scheme="http://windylee.cn/categories/MongoDb/"/>
    
    
      <category term="Database" scheme="http://windylee.cn/tags/Database/"/>
    
  </entry>
  
  <entry>
    <title>markdown新手指南</title>
    <link href="http://windylee.cn/posts/bc135409/"/>
    <id>http://windylee.cn/posts/bc135409/</id>
    <published>2015-09-21T00:58:04.000Z</published>
    <updated>2018-02-21T16:28:25.425Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><h3 id="Markdown是什么"><a href="#Markdown是什么" class="headerlink" title="Markdown是什么"></a>Markdown是什么</h3><p><strong>Markdown</strong>是一种极简的标记语言，可以轻易的将文本转化为HTML。语法非常容易学习，简单到每个人都可以在5分钟之内学会。Markdown之所以越来越流行，不是因为它复杂，而是因为他足够简单。</p><h3 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h3><ul><li>纯文本编写，兼容性很强，可以使用所有文本编辑器打开</li><li>让写作者专注与文字而不是排版</li><li>格式转换方便，可以将MarkDown文本轻易转换为HTML，电子书等</li></ul><h3 id="与word对比"><a href="#与word对比" class="headerlink" title="与word对比"></a>与word对比</h3><ul><li>使用word写文档需要浪费大量时间在word本身上，特别是那80%我们用不到的功能</li><li>浪费时间在排版上，需要花费大量时间用在调整粗体或者斜体，黑体还是宋体上</li></ul><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题有两种方式：Setext方式和Atx方式<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Setext方式，三个或更多的=或者-</span><br><span class="line">大标题</span><br><span class="line">===</span><br><span class="line">小标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p></p><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Atx方式，在标题前面加上#号，总共分为6个等级，#号越多，标题字号越小</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><a id="more"></a><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表，只需要在文字前面加上<code>-</code>,<code>+</code>或者<code>×</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 文本<span class="number">1</span></span><br><span class="line">- 文本<span class="number">2</span></span><br><span class="line">- 文本<span class="number">3</span></span><br></pre></td></tr></table></figure><p></p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><p>有序列表，只需要在文字前面加上<code>1.</code>， <code>2.</code>， <code>3.</code>等。前面序号只是代表语法标记，真正序号与我们所写的内容并无实际关系，例如：我将文本3的序号标记为4，但效果仍然显示为3。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 文本<span class="number">1</span></span><br><span class="line"><span class="number">2</span>. 文本<span class="number">2</span></span><br><span class="line"><span class="number">4</span>. 文本<span class="number">3</span></span><br></pre></td></tr></table></figure><p></p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><p>嵌套列表，<code>-</code>，<code>+</code>，<code>*</code>可循环使用，但符号之后的空格不能少，符号之前的空格也不能少<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 一级列表</span><br><span class="line">  + 二级列表</span><br><span class="line">  + 二级列表</span><br><span class="line">    × 三级列表</span><br><span class="line">      - 四级列表</span><br><span class="line">- 一级列表</span><br><span class="line">```language</span><br></pre></td></tr></table></figure><p></p><ul><li>一级列表<ul><li>二级列表</li><li>二级列表<ul><li>三级列表<ul><li>四级列表</li></ul></li></ul></li></ul></li><li>一级列表</li></ul><h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><p>链接，插入链接只需要使用<code>[显示文本](连接地址 Tooltips)</code>这样的语法实现，Tooltips可以省略，Tooltips表示鼠标悬浮时候的文本提示<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](http:<span class="comment">//www.baidu.com)</span></span><br></pre></td></tr></table></figure><p></p><p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p><p>图片，插入图片只需要使用<code>![](图片链接 Tooptips)</code>这样的语法实现，Tooltips可以省略<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](http:<span class="comment">//ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg "埃菲尔铁塔")</span></span><br></pre></td></tr></table></figure><p></p><p><img src="http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg" alt="" title="埃菲尔铁塔"></p><p>自动链接，直接显示链接网址，点击可以跳转<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http:<span class="comment">//www.sina.com&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><a href="http://www.sina.com" target="_blank" rel="noopener">http://www.sina.com</a></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在我们写作的时候经常需要引用他人的文字，这时候就需要用到引用这个格式。这时候我们就需要在文字前面加上<code>&gt;</code>来表示引用内容。可以嵌套使用表示多级引用<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 以眼看世界，即使站的最高，世界还是很小；以心看世界，即使身处局限，世界依然很大</span><br></pre></td></tr></table></figure><p></p><blockquote><p>以眼看世界，即使站的最高，世界还是很小；以心看世界，即使身处局限，世界依然很大</p></blockquote><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>被<code>**</code>包含的表示<em>斜体</em>，被<code>****</code>包含的表示<strong>粗体</strong>，其中的<code>*</code>也可以换成<code>_</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**一个人来到田纳西**</span><br><span class="line">__毫无疑问__</span><br><span class="line">*我做的馅饼</span><br><span class="line">是全天下*</span><br><span class="line">_最好吃的_</span><br></pre></td></tr></table></figure><p></p><p><strong>一个人来到田纳西</strong><br><strong>毫无疑问</strong><br><em>我做的馅饼<br>是全天下</em><br><em>最好吃的</em></p><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p><code>***</code>表示page break；<code>---</code>表示section break；<code>___</code>表示sentence break；<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">section <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">sentence <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">___</span><br></pre></td></tr></table></figure><p></p><p>page break</p><hr><p>section break</p><hr><p>sentence break</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>使用`</p><figure class="highlight plain"><figcaption><span>&#123;codeblock&#125;``` `表示代码块，language表示代码块中代码的语言类型，在&#123;codeblock&#125;中插入要写的代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">    ```java</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">``` `</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊表示"><a href="#特殊表示" class="headerlink" title="特殊表示"></a>特殊表示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~删除元素~~</span><br><span class="line">++下划线++</span><br><span class="line">==高亮显示==</span><br></pre></td></tr></table></figure><p><del>删除元素</del><br>++下划线++<br>==高亮显示==</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Markdown简介&quot;&gt;&lt;a href=&quot;#Markdown简介&quot; class=&quot;headerlink&quot; title=&quot;Markdown简介&quot;&gt;&lt;/a&gt;Markdown简介&lt;/h2&gt;&lt;h3 id=&quot;Markdown是什么&quot;&gt;&lt;a href=&quot;#Markdown是什么&quot; class=&quot;headerlink&quot; title=&quot;Markdown是什么&quot;&gt;&lt;/a&gt;Markdown是什么&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;Markdown&lt;/strong&gt;是一种极简的标记语言，可以轻易的将文本转化为HTML。语法非常容易学习，简单到每个人都可以在5分钟之内学会。Markdown之所以越来越流行，不是因为它复杂，而是因为他足够简单。&lt;/p&gt;&lt;h3 id=&quot;Markdown优点&quot;&gt;&lt;a href=&quot;#Markdown优点&quot; class=&quot;headerlink&quot; title=&quot;Markdown优点&quot;&gt;&lt;/a&gt;Markdown优点&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;纯文本编写，兼容性很强，可以使用所有文本编辑器打开&lt;/li&gt;&lt;li&gt;让写作者专注与文字而不是排版&lt;/li&gt;&lt;li&gt;格式转换方便，可以将MarkDown文本轻易转换为HTML，电子书等&lt;/li&gt;&lt;/ul&gt;&lt;h3 id=&quot;与word对比&quot;&gt;&lt;a href=&quot;#与word对比&quot; class=&quot;headerlink&quot; title=&quot;与word对比&quot;&gt;&lt;/a&gt;与word对比&lt;/h3&gt;&lt;ul&gt;&lt;li&gt;使用word写文档需要浪费大量时间在word本身上，特别是那80%我们用不到的功能&lt;/li&gt;&lt;li&gt;浪费时间在排版上，需要花费大量时间用在调整粗体或者斜体，黑体还是宋体上&lt;/li&gt;&lt;/ul&gt;&lt;h2 id=&quot;Markdown语法&quot;&gt;&lt;a href=&quot;#Markdown语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown语法&quot;&gt;&lt;/a&gt;Markdown语法&lt;/h2&gt;&lt;h3 id=&quot;标题&quot;&gt;&lt;a href=&quot;#标题&quot; class=&quot;headerlink&quot; title=&quot;标题&quot;&gt;&lt;/a&gt;标题&lt;/h3&gt;&lt;p&gt;标题有两种方式：Setext方式和Atx方式&lt;br&gt;&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Setext方式，三个或更多的=或者-&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;大标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;===&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;小标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;p&gt;&lt;/p&gt;&lt;h1 id=&quot;大标题&quot;&gt;&lt;a href=&quot;#大标题&quot; class=&quot;headerlink&quot; title=&quot;大标题&quot;&gt;&lt;/a&gt;大标题&lt;/h1&gt;&lt;h2 id=&quot;小标题&quot;&gt;&lt;a href=&quot;#小标题&quot; class=&quot;headerlink&quot; title=&quot;小标题&quot;&gt;&lt;/a&gt;小标题&lt;/h2&gt;&lt;figure class=&quot;highlight&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Atx方式，在标题前面加上#号，总共分为6个等级，#号越多，标题字号越小&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;# 一级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;## 二级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;### 三级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#### 四级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;##### 五级标题&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;###### 六级标题&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;h1 id=&quot;一级标题&quot;&gt;&lt;a href=&quot;#一级标题&quot; class=&quot;headerlink&quot; title=&quot;一级标题&quot;&gt;&lt;/a&gt;一级标题&lt;/h1&gt;&lt;h2 id=&quot;二级标题&quot;&gt;&lt;a href=&quot;#二级标题&quot; class=&quot;headerlink&quot; title=&quot;二级标题&quot;&gt;&lt;/a&gt;二级标题&lt;/h2&gt;&lt;h3 id=&quot;三级标题&quot;&gt;&lt;a href=&quot;#三级标题&quot; class=&quot;headerlink&quot; title=&quot;三级标题&quot;&gt;&lt;/a&gt;三级标题&lt;/h3&gt;&lt;h4 id=&quot;四级标题&quot;&gt;&lt;a href=&quot;#四级标题&quot; class=&quot;headerlink&quot; title=&quot;四级标题&quot;&gt;&lt;/a&gt;四级标题&lt;/h4&gt;&lt;h5 id=&quot;五级标题&quot;&gt;&lt;a href=&quot;#五级标题&quot; class=&quot;headerlink&quot; title=&quot;五级标题&quot;&gt;&lt;/a&gt;五级标题&lt;/h5&gt;&lt;h6 id=&quot;六级标题&quot;&gt;&lt;a href=&quot;#六级标题&quot; class=&quot;headerlink&quot; title=&quot;六级标题&quot;&gt;&lt;/a&gt;六级标题&lt;/h6&gt;
    
    </summary>
    
      <category term="markdown" scheme="http://windylee.cn/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://windylee.cn/tags/markdown/"/>
    
  </entry>
  
</feed>
