---
title: Netty实战读书笔记
tags: Java
categories: 读书笔记
abbrlink: bc6b2f71
date: 2018-12-28 23:32:20
---

### 第三章

1. Channel、EventLoop和ChannelFuture是Netty网络抽象的代表。
   - Channel---对Java中的Socket的封装。Netty拥有许多预定义的、专门化实现的广泛类层次结构的根(EmbeddedChannel、LocalServerChannel、NioDatagramChannel、NioSctpChannel和NioSocketChannel)
   - EventLoop---控制流、多线程处理、并发。EventLoopGroup是一个EventLoop的容器，可以包含一个或多个EventLoop。每个EventLoop在其生命周期内只和一个Thread绑定；EventLoop处理的IO事件都在它专有的Thread上被处理。一个Channel在其生命周期内只注册于一个EventLoop，一个EventLoop可能会被分配给一个或多个Channel。（在这种设计中，一个给定的Channel的I/O操作都是由同一个Thread执行的，实际上消除了对于同步的需要）
   - ChannelFuture----异步通知，可以通过该接口的`addListener()`方法注册一个ChannelFutureListener监听类，以便在某个操作完成时得到通知。
2. 在Netty中，有两种发送消息的方式。可以直接写到Channel中，会导致消息从ChannelPipeline的尾端开始流动；也可以写到和ChannelHandler相关联的ChannelHandlerContext对象中，会导致消息从ChannelPipeline中的下一个ChannelHandler流动。

<!-- more -->

### 第四章

1. ChannelPipeline的典型用途包括：

   - 将数据从一个格式转换为另一种格式
   - 提供异常的通知
   - 提供Channel变为活动的或者非活动的通知
   - 提供当Channel注册到EventLoop或者从EventLoop注销时的通知
   - 提供有关用户自定义事件的通知

2. Netty的Channel实现是线程安全的，因此可以存储一个指向Channel的引用，每当需要向远程节点写数据时，都可以使用存储的引用，可以保证消息按顺序发送。

3. Netty内置的传输：

   | 名称     | 包                          | 描述                                                         |
   | -------- | --------------------------- | ------------------------------------------------------------ |
   | NIO      | io.netty.channel.socket.nio | 使用java.nio.channelds包作为基础--给予选择器的方式           |
   | Epoll    | io.netty.channel.epoll      | 有JNI驱动的epoll()和非阻塞IO。这个传输支持只有在LInux上可用的多种特性，如SO_REUSEPORT，比NIO传输更快，而且是完全非阻塞的 |
   | OIO      | io.netty.channel.socket.io  | 使用java.net包作为基础--使用阻塞流                           |
   | Local    | io.netty.channel.local      | 可以在JVM内部通过管道进行通信的本地传输                      |
   | Embedded | io.netty.channel.embedded   | Embedded传输，允许是用ChannelHandler而又不需要一个真正的基于网络的传输，可以用来作为测试使用。 |

### 第五章

1. ByteBuf对比原生ByteBuffer的有点
   - 可以被用户自定义的缓冲区类型拓展
   - 通过内置的复合缓冲区类型实现透明的零拷贝
   - 容量可以按需增长，(可以指定最大容量，试图移动写索引超过这个值会触发异常)
   - 在读和写两种模式之间不需要调用ByteBuffer的flip()方法，读和写使用了不同的索引
   - 支持方法的链式调用
   - 支持引用计数
   - 支持池化
2. 名称以read或者write开头的ByteBuf方法，将会推进其对应的索引，而名称以set或get开头的操作不会修改索引。
3. ByteBuf的三种模式
   - 堆缓冲区，将数据存储在JVM的堆空间中，又称为支撑数据模式。可以在没有使用池化的情况下提供快速的分配和释放
   - 直接缓冲区，该数据不会被JVM的垃圾回收机制回收，也避免了每次调用本地I/O操作之前（或之后）将缓冲区的内容复制到一个中间缓冲区（或从中间缓冲区把内容复制到缓冲区）；其分配和释放都比较昂贵
   - 复合缓冲区，为多个ByteBuf提供了一个聚合视图。
4. ByteBuf字节级操作

![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/Netty%E5%AE%9E%E6%88%98%20p1.jpg)

- 如图所示，标记为可丢弃字节的分段包含了已经被读过的字节。通过调用`discardReadBytes()`方法可以丢弃他们以回收空间。因为可读字段必须被移动到缓冲区的开始位置，调用该方法后会导致内存复制，不建议频繁调用该方法。
- 可读字节分段存储了实际数据，任何名称以read或skip开头的操作都将检索或者跳过位于当前readIndex的数据，并且将它增加已读字节数。
- 可读字节分段是指一个拥有未定义内容的、写入就绪的内存区域，任何名称以write开头的操作都将从当前的writeIndex处开始写数据，并将它增加已经写入的字节数。

1. ByteBuf可以通过调用`markReaderIndex()`、`markWriterIndex()`、`resetWriterIndex()`和`resetReaderIndex()`来标记和重置ByteBuf的readIndex和writeIndex。也可以通过调用`readerIndex(int)`或者`writerIndex(int)`来将索引移动到指定位置。通过调用`clear()`方法来将readerIndex和writerIndex都置为0，但不会清除内存中的内容，因为只是重置索引所以比`discardReadBytes()`轻量的多。
2. 派生缓冲区为ByteBuf提供了以专门的方式来呈现其内容的视图，可以通过`duplicate()`、`slice()`、`slice(int, int)`、`Unpooled.unmodifiableBuffer(...)`、`order(ByteOrder)`、`readSlice(int)`等方法创建。这些方法都将返回一个新的ByteBuf实例，它具有自己的读写索引和标记索引，其共享源ByteBuf内存。意味着修改了它的内容也会同时修改其对应源的实例。

### 第六章

1. Channel的4具有4中状态

| 状态                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| ChannelUnregistered | Channel已经被创建，但还未注册到EventLoop                     |
| ChannelResistered   | Channel已经被注册到EventLoop                                 |
| ChannelActive       | Channel处于活动状态(已经连接到它的远程节点)。他现在可以接受和发送数据了 |
| ChannelInactive     | Channel没有连接到远程节点                                    |

当状态发生变化时，将会生成对应的事件。这些事件将会被转发给ChannelPipeline中的ChannelHandler，其可以随后对它们做出相应。

![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/Netty%E5%AE%9E%E6%88%98%20p2.jpg)

1. ChannelHandler定义了3中生命周期操作，每个方法都能接受一个ChannelHandlerContext参数。

| 类型            | 描述                                              |
| --------------- | ------------------------------------------------- |
| handlerAdded    | ChannelHandler添加到ChannelPipeline中时被调用     |
| handlerRemoved  | 从ChannelPipeline中移除ChannelHandler时被调用     |
| exceptionCaught | 当处理过程中在ChannelPipeline中有错误产生时被调用 |

1. ChannelInboundHandler接口负责处理入站数据以及各种状态的变化，其实现类在重写channelRead()方法时，需要显式的释放和池化ByteBuf实例相关的内存。继承自SimpleChannelInboundHandler的类在重写channelRead0()方法时，该抽象类会自动释放ByteBuf资源，所以我们不应该存储指向任何消息的引用。
2. ChannelOutboundHandler用来处理出站操作和数据
   - 如果再该Handler中消息被消费或者丢弃了，并且没有传递给ChannelPipeline中的下一个ChannelOutboundHandler，就需要调用realease方法释放内存。如果消息到达了实际的传输层，当它被写入时或者Channel关闭时，就将会被自动释放。
   - 该接口中的大部分方法都需要一个ChannelPromise参数，以便在操作完成时得到通知。ChannelPromise是ChannelFuture的一个子类，其定义了一些可写的方法，如setSuccess()和setFailure()。
3. ChannelPipline中的每一个ChannelHandler都是通过它的EventLoop(I/O线程)来处理传递给他的事件的，所以一定不要阻塞这个线程，否则的话会对整体的I/O处理产生负面的影响。
4. ChannelHandleContext有很多方法，其中一些方法也存在与Channel和ChannelPipeline中。如果调用Channel或者ChannelPipeline上的这些方法，他们将沿着整个ChannelPipeline进行传播；而调用位于ChannelHandlerContext上的相同方法，则将从当前所关联的ChannelHandler开始，并且只会传播给位于该ChannelPipeline中的下一个能够处理改事件的ChannelHandler。
5. ChannelHandler的数据入站异常处理逻辑
   - ChannelHandler.exceptionCaught()的默认实现是简单得将当前一场转发给ChannelPipeline中的下一个ChannelHandler
   - 如果异常到达了ChannelPipeline的尾端，他将会通过Warning级别的日志被记录为未被处理
   - 可以重写exceptionCaught()方法来自定义异常处理逻辑
6. ChannelHandler处理出站异常
   - 每个出站操作都将返回一个ChannelFuture。注册到ChannelFuture的ChannelFutureListener都将在操作完成时被通知该操作是否成功。
   - 几乎所有的ChannelOutboundHandler上的方法都会传入一个ChannelPromise的实例，其提供了立即通知的可写方法。

### 第七章 & 第八章

1. EventLoop继承了ScheduledExcutorService的同时，只定义了一个方法`parent()`，用于返回所属的EventLoopGroup。故其提供了ScheduledExecutorService的所有方法，并提供了更好的性能。
2. EventLoop线程分配时，每个EventLoop都将分配给一个Thread，Channel和EventLoop的分配方式根据所选IO类型有所不同。
   - 使用异步传输时，一个EventLoop可以被多个Channel共享。在使用ThreadLocal时，共享同一EventLoop的Channel获取到的ThreadLocal都是一样的
   - 使用同步传输时，每个EventLoop只能分配给一个Channel，保证了阻塞发生时编程的灵活性。
3. AbstractBootstrap类的完整声明如下：

```java
public abstract class AbstracBootstrap<B extends AbstractBootstrap<B, C>, C extends Channel>
```

在这个签名中，子类型B是其符类型的一个类型参数，因此可以返回到运行实例的引用以支持方法的链式调用。

1. Bootstrap在调用bind或者connect方法之前，必须调用如下方法来设置所需的组件：`group()`、`channel()`或`channelFactory()`、`handler()`，否则会抛出IllegalStateException异常。

### 第十章

1. Netty内置了三种解码器：

   - ByteToMessageDecoder将字节解码为消息，由于远程节点不一定能一次性发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到准备好处理。

   | 方法                                                         | 描述                                                         |
   | ------------------------------------------------------------ | ------------------------------------------------------------ |
   | decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) | 该方法必须在子类中实现。decode()方法被调用时将会传入一个包含了传入数据的ByteBuf，以及一个用来添加解码消息的List。对这个方法的调用将会重复进行，直到确定没有新的元素被添加到List，或者该ByteBuf中没有更多可读取的字节时为止。如果该List不为空，那么它的内容将会被传递给ChannelPipeline中的下一个ChannelInboundHandler |
   | decodeLast(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) | Netty提供的默认实现只是简单地调用decode()方法。当Channel的状态变为非活动时，这个方法将会被调用一次。 |

   ```java
   public class ToIntegerDecoder extends ByteToMessageDecoder{
       @Override
       public void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception{
           if(in.readableBytes() >= 4) out.add(in.readInt());
       }
   }
   ```

   对于编码器和解码器来说，一旦消息被编码或者解码，他就会被ReferenceCountUtil.release(msg)调用自动释放，如果需要保留引用以便稍后使用，可以调用ReferenceCountUtil.retain(msg)方法，这将增加该引用计数，防止该消息被释放。

   - ReplayingDecoder是对ByteToMessageDecoder的封装，使得我们不需要调用readableBytes()方法来检查ByteBuf中是否有足够的字节数。如果没有足够的字节可用，ByteBuf的read方法将会抛出一个Error，其将在基类中被捕获并处理。当有更多的数据可供读取时，该decode()方法将会被再次调用。
     1. 并不是所有的ByteBuf操作都被支持，如果调用了一个不被支持的方法，将会抛出一个异常
     2. ReplayingDecoder稍慢于ByteToMessageDecoder
     3. 如果使用ByteToMessageDecoder不会引入太多的复杂性，就使用它；否则使用ReplayingDecoder
   - MessageToMessageDecoder用于两个消息格式之间进行转换

   ```java
   public abstract class MessageToMessageDecoder<I> extends ChannelInboundAdapter
   // 参数类型I指定了decode()方法的输入参数msg的类型
   ```

   该类将调用I类的方法进行编码，调用O类的方法进行解码。综合考虑了实现的灵活性和简洁性。

2. 由于需要在解码之前在内存中缓存接收到的数据，但数据量太大有可能耗尽可用内存。Netty提供了一个TooLongFrameException异常类，其可由解码器在帧超出指定大小限制时抛出。

3. Netty提供了两种编码器MessageToByteEncoder和MessageToMessage，其使用方法和解码器类似。

4. 如果要想把编码和解码集成到一个类中，Netty提供了抽象的编解码器类：ByteToMessageCodec和MessageToMessageCodec，但是这样对编解码组件的可重用性造成了影响。

5. CombinedChannelDuplexHandler类可以整合一个已经实现好的编码器和解码器，其方法签名如下

```java
public class CombinedChannelDuplexHandler <I extends ChannelInboundHandler, O extends ChannelOutboundHandler>
```

### 第十一章

1. Netty内置的Http协议编解码器

| 名称                  | 描述                                                        |
| --------------------- | ----------------------------------------------------------- |
| HttpRequestEncoder    | 将HttpRequest，HttpContent和LastHttpContent消息编码为字节   |
| HttpResponseEncoder   | 将HttpResponse，HttpContent和LastHttpContent消息解码为字节  |
| HttpRequestDecoder    | 将字节解码为HttpRequest，HttpContent和LastHttpContent消息   |
| HttpResponseDecoder   | 将字节解码为HttpResponse，HttpContent和LastHttpContent消息  |
| HttpObjectAggregator  | 将多个消息部分合并为FullHttpRequest或者FullHttpResponse消息 |
| HttpContentCompressor | 用来压缩Http的request或response                             |

1. 用于空闲连接及超时的ChannelHandler

| 名称                | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| IdleStateHandler    | 当连接空闲时间太长时，将会触发一个IdleStateEvent事件。可以通过在自定义的ChannelInboundHandler中重写userEventTriggered()方法来处理该IdleStateEvent事件 |
| ReadTimeoutHandler  | 如果在指定的时间间隔没有收到任何的入站数据，则抛出一个ReadTimeoutException并关闭对应的Channel。可以通过重写ChannelHandler中的exceptionCaught()方法来检测该ReadTimeoutException |
| WriteTimeoutHandler | 如果在指定的时间间隔没有任何入站数据写入，则抛出一个WriteTimeoutException并关闭对应的Channel。可以通过重写ChannelHandler中的exceptionCaugh()方法检测该WriteTimeoutException |

1. 基于分隔符的解码器

| 名称                       | 描述                                           |
| -------------------------- | ---------------------------------------------- |
| LineBasedFrameDecoder      | 提取由行尾符（\n或者\r\n）分隔的帧的解码器     |
| DelimiterBasedFrameDecoder | 使用任何由用户提供的分割符来提取帧的通用解码器 |

1. 基于长度的解码器

| 名称                         | 描述                                                         |
| ---------------------------- | ------------------------------------------------------------ |
| FixedLengthFrameDecoder      | 提取在调用构造函数时指定的定长帧                             |
| LengthFieldBasedFrameDecoder | 根据编码进帧头部中的长度值提取帧，该类接收三个参数，分别用于指定maxFrameLength(帧最大长度)、lengthFieldOffset(长度字段偏移量)、lengthFieldLength(长度字段的长度) |

1. Protocol Buffers编解码器

| 名称                                 | 描述                                                         |
| ------------------------------------ | ------------------------------------------------------------ |
| ProtobufDecoder                      | 使用protobuf对消息进行解码                                   |
| ProtobufEncoder                      | 使用protobuf对消息进行编码                                   |
| ProtobufVarint32FrameDecoder         | 根据消息中的Google Protocol Buffers的“Base 128 Varints"整形长度字段值动态的分割所接收到的ByteBuf |
| ProtobufVarint32LengthFieldPrepender | 向Bytebuf前追加一个Google Protocol Buffers的“Base 128Varints”整形的长度字段 |