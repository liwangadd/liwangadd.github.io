---
title: 深入浅出Thrift
categories: Java
tags:
  - thrift
  - python
  - java
abbrlink: 4ed356c2
date: 2019-02-12 15:32:32
---

### 介绍

Apache Thrift是Facebook实现的一种高效的、支持多种编程语言的远程服务调用框架，包括一个软件库和一组代码生成引擎，以加快高效率、可拓展的后端服务的开发与实现速度。它采用接口描述语言定义并创建服务，支持可拓展的跨语言服务开发，所包含的代码生成引擎可以在多种语言中，如C++、Java、Python、PHP、Ruby、Erlang、Perl等创建高效的、无缝的服务，传输数据格式采用二进制格式，相对于JSON和XML体积更小，对于高并发、大数据量和多语言的环境更有优势。

### 架构

Thrift包含一个完整的堆栈结构用于构建客户端和服务端，下图描绘了Thrift的整体架构

![Thrift Stack](http://jnb.ociweb.com/jnb/jnbJun2009_files/jnbJun2009_stack.png)

如图所示，黄色部分是用户实现的业务逻辑，褐色部分是根据Thrift定义的服务接口文件生成的客户端和服务端代码框架，红色部分是根据Thrift文件生成代码实现数据的读写操作。红色部分以下是Thrift的传输体系、协议及底层I/O通信，使用Thrift可以很方便的定义一个服务并且选择不同的传输协议和传输层而不用重新生成代码

<!-- more -->

### 支持的协议、传输层和服务器类型

Thrift的网络栈如下图所示：

![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAthrift%20p1.jpg)

#### 协议

Protocol抽象层定义了一种将内存中数据结构映射成可传输格式的机制。换句话说，Protocol定义了datatype怎样使用底层的Transport对自己进行编解码。因此，Protocol的实现要给出编码机制并负责对数据进行序列化，在传输协议上总体划分为文本(text)和二进制(binary)传输协议。

- TBinaryProtocol 直接使用二进制编码格式进行传输
- TCompactProtocol 使用高效率的、密集的二进制编码格式进行数据传输
- TJSONProtocol 使用JSON的数据编码格式进行数据传输
- TSimpleJSONProtocol 只提供JSON只写的协议，适用于通过脚本语言解析

    requestTimeoutUnit = args.requestTimeoutUnit;
    requestTimeout = args.requestTimeout;
    beBackoffSlotInMillis = args.beBackoffSlotLengthUnit.toMillis(args.beBackoffSlotLength);
#### 传输

协议描述了应该传输什么样的数据，而传输层则负责如何传输数据，Thrift提供了如下几种传输方式：

- TSocket 使用阻塞式I/O进行传输，是最常见的模式
- TFrameTransport 使用非阻塞方式，按块的大小进行传输。若使用该传输层，其服务器必须修改为非阻塞的服务类型
- TFileTransport 以文件形式进行传输
- TMemoryTransport 将内存用于I/O，java实现时内部实际使用了简单的`ByteArrayOutputStream`
- TNonblockingTransport 使用非阻塞方式，用于构建异步客户端

Transport层提供了一个简单的网络读写抽象层。这使得thrift底层的transport从系统其它部分（如：序列化/反序列化）解耦，以下是一些Transport接口提供的方法:

![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAthrift%20p2.png)

除了以上几个接口，Thrift使用ServerTransport接口接受或者创建原始transport对象。正如名字暗示的那样，ServerTransport用在server端，为到来的连接创建Transport对象。

![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAthrift%20p3.png)

#### 服务端

Server将以上所有特性集成在一起：

（1）  创建一个transport对象

（2）  为transport对象创建输入输出protocol

（3）  基于输入输出protocol创建processor

（4）  等待连接请求并将之交给processor处理

- TSimpleServer 单线程服务器端，使用标准的阻塞式I/O，循环监听新请求的到来并完成对请求的处理，通常在演示时候使用。

  ![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/TSimpleServer.jpg)

- TThreadPoolServer 多线程服务端，使用标准的阻塞式I/O。主线程负责阻塞式监听是否有新的请求到来，业务处理交由一个线程池处理。

  ![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/TThreadPoolServer.jpg)

- TNonblockingServer 用于构建异步客户端，使用非阻塞式I/O。使用单线程模型，效率提升主要体现在IO多路复用上(需使用TFramedTransport数据传输方式)

  ![img](http://windylee-blog.oss-cn-beijing.aliyuncs.com/TNonblockingServer.jpg)

- THaHaServer 是TNonblockingServer的子类，引入了线程池来专门进行业务处理。主线程需要完成对所有socket的监听以及数据读写工作，业务处理教程交给一个线程池来完成。

  ![img](http://windylee-blog.oss-cn-beijing.aliyuncs.com/THaHaServer.jpg)

- TThreadSelectorServer 其包括如下几个部分

  1. 一个AcceptThread线程对象，专门用于处理监听socket上的新连接

  2. 若干个SelectorThread对象专门用于处理业务socket的网络I/O操作，所有网络数据的读写均是由这些线程来完成

  3. 一个负载均衡器SelectorThreadLoadBanancer对象，主要用于AcceptThread县城接收到一个新socket连接请求时，决定将这个新连接请求分配给哪个SelectorThread线程

  4. 一个ExecutorService类型的工作线程池，在SelectorThread线程将请求数据读取之后，交给ExecutorService线程池中的线程完成此次调用的具体执行。

     ![1545895620043](http://windylee-blog.oss-cn-beijing.aliyuncs.com/TThreadSelectorServer.jpg)

### 调用过程

Thrift调用过程中，Thrift客户端和服务器之间主要用到输出层类、协议层类和处理类三个主要的核心类，这三个类互相协作共同完成rpc的整个调用过程。

1. 将客户端程序调用的函数名和参数传递给协议层，协议层将函数名和参数按照协议格式进行封装，然后封装的结果交给下层的传输层。需要保证与Thrift服务器程序所使用的协议类型一致，否则Thrift服务器程序便无法在其协议层进行数据解析
2. 传输层将协议层传递过来的数据进行处理，例如传输层实现类`TFramedTransport`就是将数据封装成帧的格式，然后将处理之后的数据通过网络发送给Thrift服务器。需要保证与Thrift服务器程序所采用的传输层的实现类一致，否则Thrift的传输层也无法将数据进行逆向的处理。
3. Thrfit服务器通过传输层接受网络上传输过来的调用请求数据，将接收到的数据进行逆向的处理，然后在交付给Thrift服务器的协议类。dushubiji
4. Thrift服务端的协议类将传输层处理之后的数据按照协议进行解封装，并将解封装之后的数据交给Processor处理器类进行处理
5. Thrift服务端的Processor类根据协议层解析的记过，按照函数名找到函数名所对应的函数对象
6. Thrift服务端使用传过来的参数调用这个找到的函数对象
7. Thrift服务端将函数对象执行的结果交给协议层
8. Thrift服务端的协议层将函数的执行结果进行协议封装，传输层将协议层封装的结果进行处理，然后发送给Thrift客户端程序
9. Thrift客户端程序的传输层将受到的网络结果进行逆向处理，得到实际的协议数据。协议层将数据按照写一个数进行解封装，然后得到具体的函数执行结果，并将其交付给调用函数

### 示例

首先使用接口描述语言编写脚本文件`Hello.thrift`，代码如下

```c
namespace java cn.windylee.thrift

service Hello{
    string helloString(1:string para);
    i32 helloInt(1:i32 para);
    bool helloBoolean(1:bool para);
    void helloVoid();
    string helloNull();
}
```

在文件中定义了五个方法，每个方法包含一个方法名，参数列表和返回类型。每个参数包括参数序号，参数类型以及参数名。使用Thrift工具变异Hello.Thrift，就会生成对应语言的文件。该文件包含了在Hello.thrift文件中描述的服务Hello的接口定义，即Hello.Iface接口，以及服务调用的底层通信细节，包括客户端的调用逻辑Hello.Client以及服务端的处理逻辑Hello.Processor，用于构建客户端和服务端的功能。

```bash
thrift -gen py Hello.thrift # 生成python2的接口代码
thrift -gen java HelloService.thrift # 生成java的接口代码
```

创建Java客户端实现代码，调用Hello.Client访问服务端的逻辑实现

```java
import org.apache.thrift.protocol.TBinaryProtocol;
import org.apache.thrift.protocol.TProtocol;
import org.apache.thrift.transport.TSocket;
import org.apache.thrift.transport.TTransport;

public class HelloClient {

    public static void main(String[] args) throws Exception {
        TTransport transport = new TSocket("127.0.0.1", 9090);
        transport.open();
        TProtocol protocol = new TBinaryProtocol(transport);
        Hello.Client client = new Hello.Client(protocol);
        client.helloVoid();

        String recvStr = client.helloString("hello world");
        System.out.println(recvStr);

        int recvInt = client.helloInt(123);
        System.out.println(recvInt);

        String RecvNull = client.helloNull();
        System.out.println(RecvNull);

        transport.close();
    }

}
```

创建服务端实现代码

```python
#!/usr/bin/env python
# -*- coding:utf-8 -*-

from hello import Hello
from hello.ttypes import *
from thrift.transport import TSocket
from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol
from thrift.server import TServer


class HelloServerHandler:
    def helloString(self, para):
        ret = "Received: " + para
        print(ret)
        return ret

    def helloInt(self, para):
        ret = "Received: " + str(para)
        print(ret)
        return para * 2

    def helloBoolean(self, para):
        ret = "Received: "+ str(para)
        print(ret)
        return True

    def helloVoid(self):
        ret = "A request from client"
        print(ret)

    def helloNull(self):
        ret = "Received Nothing"
        return ret


if __name__ == '__main__':
    handler = HelloServerHandler()
    processor = Hello.Processor(handler)
    transport = TSocket.TServerSocket("127.0.0.1", 9090)
    tfactory = TTransport.TBufferedTransportFactory()
    pfactory = TBinaryProtocol.TBinaryProtocolFactory()

    server = TServer.TSimpleServer(processor, transport, tfactory, pfactory)

    print("Starting thrift server in python...")
    server.serve()
    print("done!")

```

