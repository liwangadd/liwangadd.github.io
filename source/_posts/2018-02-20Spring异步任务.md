title: Spring异步任务
date: 2018-02-20 22:51:49
tags: Spring
categories: Java Web
---

在Spring3.0之前如果我们想要异步执行某项任务，需要我们自己编写线程池来实现。在Spring3.X新增了注解@Async，可以标记方法或者类中的所有方法都可以异步执行，而调用他的方法会在原来的线程中执行。这样可以避免阻塞，保证任务的实时性。适用于处理log，发送邮件等

\#### 配置

\##### 配置文件

同Spring自己实现的定时任务一样，我们需要在配置文件中引入task命名空间

```xml

<beans xmlns="http://www.springframework.org/schema/beans"

​    xmlns:task="http://www.springframework.org/schema/task"

​    ...

​    http://www.springframework.org/schema/task

​    http://www.springframework.org/schema/task/spring-task.xsd">

\```

然后配置相关的线程池和缺省的异步调度器

\```xml

<!--配置executor，一个应用中可以有多个executor-->

<task:executor id="mailExecutor" pool-size="10" keep-alive="100" queue-capacity="5" rejection-policy="ABORT"/>

<task:executor id="logExecutor" pool-size="10"/>

<!--指定一个缺省的executor给@Async使用，当@Async没有指定使用哪个executor将默认使用该executor-->

<task:annotation-driven executor="mailExecutor"/>

\```

<!--more-->

\##### 配置参数

\- id: 当配置多个executor时，被@Async("id")指定使用，也可以作为线程名的前缀

\- pool-size 指定线程池的大小

\- queue-capacity：当最小的线程数已经被占用满后，新的任务会被放进queue里面，当这个queue的capacity也被占满之后，pool里面会创建新线程处理这个任务，直到总线程数达到了max size，这是系统会拒绝这个任务并抛出TaskRejectedException异常(可以通过rejection-policy来决定如何处理这种情况)，缺省值为Integer.MAX_VALUE

\- keey-alive：超过core size的那些线程，任务完成后，经过这个时长就会被结束掉

\- rejection-policy：当pool已经达到max size的时候，如何处理新任务

ABORT（缺省）：抛出TaskRejectedException异常，然后不执行

DISCARD：不执行，也不抛出异常

DISCARD_OLDEST：丢弃queue中最旧的那个任务

CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行

\#### 注解

\##### 注解源码

\```java

@Target({ElementType.METHOD, ElementType.TYPE})

@Retention(RetentionPolicy.RUNTIME)

@Documented

public @interface Async {

​    String value() default "";

}

\```

通过@Async的源码我们可以知道，该注解可以用在方法上也可以用在类上，注解在方法上表明该方法是一部执行的，注解在类上表明该类中的所有方法都是一步执行的

\##### 方法返回值

如果我们不想从异步线程中获取返回值，那么我们可以将返回值声明为void。如果我们想要从线程中获取数据，可以使用Future作为返回值。通过future.get()得到需要返回的对象，也可以使用future,get(time,unit)，在制定时间内获取返回值，如果超过设置的时间则抛出异常

\```java

@Async("logExecutor")

​    public void business() throws InterruptedException {

​        System.out.println("异步任务开始执行");

​        Thread.sleep(2000);

​        System.out.println("异步任务执行结束");

​    }

​    /**

​     \* 没有指定调度器将使用缺省值

​     \* @return

​     \* @throws InterruptedException

​     */[^]

​    @Async

​    public Future<String> business2() throws InterruptedException {

​        System.out.println("异步任务开始执行");

​        Thread.sleep(2000);

​        System.out.println("异步任务执行结束");

​        return new AsyncResult<String>("hello world");

​    }

\```