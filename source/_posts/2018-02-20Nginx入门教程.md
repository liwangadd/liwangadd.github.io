---
title: Nginx入门教程
tags: nginx
categories: Linux
abbrlink: 750751bd
date: 2018-02-20 22:58:46
---

### 介绍

Nginx是一个开源、高性能的HTTP服务器和反向代理服务器，还可以用来作为IMAP/POP3的代理服务器，其处理静态文件、索引文件的效率非常高。相比于apache的多进程多线程的并发模型，Nginx是基于事件的异步IO的并发模型，支持epoll/kqueue等网络IO模型。

### 安装

安装Nginx主要有两种方式，通过仓库中的二级制包安装和源码安装。在Ubuntu系统中可以通过`sudo apt-get install nginx`从官方仓库中安装，这种安装方式可以满足用户的基本需求。但如果对Nginx的精简度和性能有非常高的要求，就需要通过源码的方式安装，分为以下三步：

```shell
./configure
make
sudo make install

```

如果要对Nginx进行定制，就需要在第一步制定需求，主要参数如下：

- –conf-path 指定配置文件的位置，默认为/etc/nginx/nginx.conf
- –error-log-path 指定错误日志文件所在位置，默认为/var/log/nginx/error.log,安装完成后可在配置文件中进行配置
- –http-log-path 指定http连接日志文件所在位置，默认为/var/log/nginx/access.log
- –with-模块名称 该模块会被编译
- –without-模块名称 编译时将该模块排除在外

<!--more-->

源码安装完成之后，默认Nginx服务已经启动。若想手动启动Nginx服务可以通过`sudo service nginx start`,同理关闭或者重启可以通过`sudo service nginx stop/restart`。 虽然Nginx重启速度很快，但是每次修改配置文件后，仅仅想让配置文件生效可以通过`sudo nginx -s reload` 命令，而不用重启服务

#### 配置文件详解

Nginx是模块化的系统，整个系统被分成一个个的模块，每个模块负责不同的功能。例如http_gzip_static_module是负责压缩的，http_ssl_module是负责加密的。如果想使用某个模块需要在编译时将其加入其中，使用被编译的模块需要通过指令，整个配置文件就是通过指令组成的。默认的配置文件位于`/etc/nginx/nginx.conf`，内容如下

```shell
user nginx;
worker_processes 1;
pid /run/nginx.pid;

events {
  worker_connections 768;
}

http {

  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  keepalive_timeout 65;
  types_hash_max_size 2048;

  include /etc/nginx/mime.types;
  default_type application/octet-stream;

  access_log /var/log/nginx/access.log;
  error_log /var/log/nginx/error.log;

  gzip on;
  gzip_disable "msie6";

  include /etc/nginx/conf.d/*.conf;
  include /etc/nginx/sites-enabled/*;
}

```

可以看到，配置文件主要由两个block组成。Nginx是存在三个顶级block的，分别是

```shell
events {
}
http {
}
mail{
}

```

从配置文件中可以看出：events模块中包含nginx中所有处理连接的设置，可以通过worker_connections指定每个工作进程可以同时接受的最大连接数；http模块主要是用来配置web服务，可以用于指定是否启用压缩，是否支持发送文件等；mail模块用来配置IMAP/POP3代理。我们主要关注http模块，如果Nginx的配置文件过大，将全部配置写在同一文件中将难以维护，此时可以将不同用途的配置写在不同的配置文件中，通过include指令加载进来。

如果想要部署一个网站，就需要在http模块中添加一个server块。下面看一个例子。

```Shell
server {
    listen	80;
  	server_name example.org www.example.org;
  	root	/usr/nginx/www;
  	
  	location / {
        index	index.html index.php;
    }
  
  	location ^~ /images/ {
        index icon.html;
    }
  
  	location ~* \.(gif|jpg|png)$ {
        expires 30d;
    }
  
  	error_page 500 502 503 /50x.html;
}

```

在电脑中的hosts文件中，加入一行`127.0.0.1 www.example.org`，在浏览器中输入www.example.org就可以访问了。该配置中通过listen表明监听80端口，通过server_name指定网站的域名，通过root指定网站的根目录，最下面的error_page说明当服务器发生500、502、503错误时，将网站根目录下的50x.html返回给用户。

下面我们主要关注location指令，location用于URL模式设置，可以看到在匹配的URL开头有一些特殊符号，不同的符号用于限定在匹配时采用的特殊规则：

- =开头表示精确匹配，与指定字符串有任何区别将不能匹配成功
- ^~开头表示匹配以指定字符串开头的URL，不适用正则
- ~开头表示区分大小写的正则匹配
- ~*开头表示不区分大小写的正则匹配
- /通用匹配，如果所有匹配都失败，则返回该默认匹配

各种匹配的优先级为：(=) > (完整路径) > (^~) > (~, ~*) > (location 部分起始路径) > (/)。

在上面的配置文件中的`$`符号是正则表达式中的结束标志。在最后一个location中有expires指令，该指令的作用是让Nginx缓存请求返回的信息(这里是图片静态文件)，缓存的有效期的30天。

#### 反向代理

代理可以分问正向代理和反向代理。正向代理的步骤是：用户要访问服务器C，而用户的请求会先到达代理服务器B，然后B再将用户请求转发到服务器C，此时代理服务器B才是真正访问服务器C的，代理服务器B再将得到的结果转发给用户。在这个过程中用户就像直接访问服务器C一样，过程中不知道代理服务器的存在。而反响代理的步骤是：用户只知道代理服务器的地址，通过该地址直接访问代理服务器B，代理服务器B将请求转发给真正的服务提供者C，得到结果后再返回给用户。用户根本不知道服务提供者的地址或者完全不能访问到，整个过程用户是直接与代理服务器B交互的。反向代理可以用来隐藏和保护原始服务器，实现负载均衡，加密和SSL加速等。

Nginx的反向代理是通过ngx_http_proxy_module这个模块实现的，nginx可以代理的协议有http(s)、fastcgi、uswgi、memcached等。下面是实现的一个简单代理服务器的配置文件。

```shell
....
http{
  ....
  upstream java_demo{
      # 实际服务器的地址
      server 127.0.0.1:8080;
  }
  server {
    server_name www.example.com;
    listen       443;
    proxy_connect_timeout 180; # nginx跟后端服务器连接超时时间(代理连接超时)
    proxy_send_timeout 180; 
    proxy_read_timeout 180; # 连接成功后，后端服务器响应时间(代理接收超时)
    proxy_set_header Host $host;
    proxy_set_header X-Forwarder-For $remote_addr;
    
    location / {
      # 将请求转发到实际服务提供者
      proxy_pass http://java_demo;
    }
 }

```

#### gzip压缩

当css文件和js文件过大时，可以通过压缩的机制提高网站的加载速度。Nginx通过ngx_http_gzip_module模块实现对文件的压缩操作，启用压缩要在配置文件中指定。

```shell
....
http {
        gzip on;
        gzip_disable "msie6";
        # gzip_vary on;
        # gzip_proxied any;
        # gzip_comp_level 6;
        # gzip_buffers 16 8k;
        # gzip_http_version 1.1;
        gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
        server {
                location ~ ^/assets/ {
                   gzip_static on;
                   expires max;
                   add_header Cache-Control public;
                }        
        }
}

```

使用gzip指令来启用gzip压缩功能，使用gzip_types限制了要压缩的文件类型。这两个属性时必须配置的，其他属性根据需要进行配置。同时需要在要启用压缩的location块中加入配置文件中的那三行。

#### 负载均衡

听说过nginx的人肯定都知道其在负载均衡中的重要角色，几乎成熟的网站都会使用nginx作为负载均衡服务器。同时nginx也在不断发展，在1.9版本之前其只能作为http的负载均衡，而在1.9之后其也实现了对tcp进行负载均衡。nginx负载均衡模块实现了如下4种调度方式：

1. round-robin：Nginx默认的轮询算法，每个请求按时间顺序逐一分配到不同的后端服务器。可以通过weight指定轮询权值，权值越大表明被访问到的可能性越大。

   ```Shell
   upstream java_demo {
     server 127.0.0.1:8080 weight=2;
     server 127.0.0.1:8081 weight=1;
   }

   ```

   ​

2. least_conn：请求会被发送到活跃连接数最少的服务器上。

   ```shell
   upstream java_demo {
     least_conn;
     server 127.0.0.1:8080;
     server 127.0.0.1:8081;
   }

   ```

   ​

3. ip_hash：根据访问用户ip的hash结果分配请求，相同的ip总是会被分配到同一台应用服务器。

   ```shell
   upstream java_demo {
     ip_hash;
     server 127.0.0.1:8080;
     server 127.0.0.1:8081;
   }

   ```

   ​

4. hash：相比于ip_hash方式，这是一个粒度更小的控制，ip_hash默认是用户ip的hash值。而该方式根据指定字段的hash值进行分配。

   ```shell
   upstream java_demo {
     hash $request_uri; # 根据请求地址分配
     server 127.0.0.1:8080;
     server 127.0.0.1:8081;
   }

   ```

   nginx对负载均衡提供了很好的支持，相对于反向代理，我们只需在upstream块中添加多个server地址和指定负载均衡算法，nginx就可以根据我们指定的负载均衡算法分发用户请求。

   在配置负载均衡时，upstream块中的server可以有如下配置参数

   - down。加入该字段的server将暂时不参与负载均衡，对该服务器的请求会自动发送到下一个服务器。
   - backup。预留的备份服务器，当其他所有的非backup都出现故障或者忙的时候，才会将请求发送到该服务器。
   - weight。指定该服务器被访问到的概率，值越大被访问到的概率越高，默认weight的权值为1。
   - max_fails。表示请求失败的次数，若某一服务器对同一请求失败超过max_fails次，则将该请求发送到下一服务器。
   - max_timeout。表示请求失败的超时时间，在设定的时间内没有成功，就作为失败处理。