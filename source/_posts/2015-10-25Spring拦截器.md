---
title: Spring拦截器
tags: Spring
categories: Java Web
abbrlink: 2b6e765e
date: 2015-10-25 13:17:25
---
#### 处理器拦截器简介
Spring MVC的处理器拦截器类型于Servlet开发中的Filter，用于对处理器进行预处理和后处理
##### 常见应用场景
- 日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等
- 权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面
- 性能监控：通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间
- 通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。
- OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。

本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。
#### 拦截器实现
SpringMVC 中的`Interceptor`拦截请求是通过`HandlerInterceptor`来实现的。在SpringMVC中定义一个`Interceptor`非常简单，主要有两种方式，第一种方式是要定义的`Interceptor`类要实现了Spring 的`HandlerInterceptor`接口，或者是这个类继承实现了`HandlerInterceptor`接口的类，比如Spring 已经提供的实现了`HandlerInterceptor`接口的抽象类`HandlerInterceptorAdapte`；第二种方式是实现Spring的`WebRequestInterceptor`接口，或者是继承实现了`WebRequestInterceptor`的类。
##### `HandlerInterceptor`接口
```java
public interface HandlerInterceptor {  
    boolean preHandle(  
            HttpServletRequest request, HttpServletResponse response,   
            Object handler)   
            throws Exception;  
 
   void postHandle(  
           HttpServletRequest request, HttpServletResponse response,   
           Object handler, ModelAndView modelAndView)   
           throws Exception;  
  
   void afterCompletion(  
	            HttpServletRequest request, HttpServletResponse response,   
            Object handler, Exception ex)  
            throws Exception;  
}
```

<!--more-->

有接口的定义我们可以看出`HandlerInterceptor`中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。
- `preHandle`实现处理器的预处理，第三个参数为响应处理器（一般为Controller）。返回true表示继续流程；返回false表示中断流程，不会继续调用其他的拦截器和处理器，这时候我们需要通过`response`来产生响应。我们可以在该方法中进行一些前置初始化操作或者是对当前请求的一个预处理。
- `postHandle`实现处理器的后处理，但是在`DispatcherServlet`渲染页面之前调用，我们可以调用modelAndView进行模型数据进行处理或对视图进行处理
- `afterCompleting`视图渲染完毕后回调该方法，该方法主要用于数据清理

![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/WechatIMG118.jpeg)
![](http://windylee-blog.oss-cn-beijing.aliyuncs.com/WechatIMG119.jpeg)
如果我们继承自HandlerInterceptor接口，那么我们每次都需要重写三个方法。但是大多数时候我们只需要重写其中一两个方法，这时候我们可以继承HandlerInterceptorAdapter类，选择性的重写其中的方法。
下面给出一个计算请求处理时间的例子
```java
public class StopWatchHandlerInterceptor extends HandlerInterceptorAdapter {

    private NamedThreadLocal<Clock>  startTimeThreadLocal =
		new NamedThreadLocal<Clock>("StopWatch-StartTime");

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse 			response,
Object handler) throws Exception {
        Cloxk start = Clock.now()//1、开始时间
        startTimeThreadLocal.set(beginTime);//线程绑定变量（该数据只有当前请求的线程可见）
        return true;//继续流程
    }

    @Override  
    public void afterCompletion(HttpServletRequest request, HttpServletResponse 		response, Object handler, Exception ex) throws Exception {
        Clock end = Clock.now();//2、结束时间  
        Clock start = startTimeThreadLocal.get();//得到线程绑定的局部变量（开始时间）
        long consumeTime = Duration.betwen(start, end).toMillis()//3、消耗的时间
            System.out.println(String.format("%s consume %d millis", request.getRequestURI(), consumeTime));
    }
}
```
##### `WebRequestInterceptor`接口
该接口中也定义了三个方法，我们也可以通过这三个方法来实现拦截，这三个方法都传递了同一个参数`WebRequest`，三个方法的调用时机同`HanlderInterceptor`。`WebRequest`是Spring中定义的一个接口，方法基本和`HttpServletRequest`一样，对`WebRequest`做的任何操作都会同步到`HttpServletRequest`，然后在当前请求中一直传递

- `preHandle(WebRequest request)`由于没有返回值，无法控制请求流程。我们一般在该方法中进行资源的准备工作。比如我们在使用Hibernate的时候可以在这个方法中准备一个Hibernate的Session对象，然后利用WebRequest的`setAttribute(name, value, scope)`把它放到WebRequest 的属性中。这里可以说说这个setAttribute 方法的第三个参数scope：
   * `SCOPE_REQUEST` ：它的值是0 ，代表只有在request 中可以访问。
   * `SCOPE_SESSION` ：它的值是1 ，如果环境允许的话它代表的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。
   * `SCOPE_GLOBAL_SESSION` ：它的值是2 ，如果环境允许的话，它代表的是一个全局共享的session，否则就代表普通的session，并且在该session 范围内可以访问。

- `postHandle(WebRequest request, ModelMap model)`ModelMap 就是Controller 处理之后返回的Model 对象，我们可以通过改变它的属性来改变返回的Model 模型。
- `afterCompletion(WebRequest request, Exception ex) `可以在该方法中进行资源的释放操作，Exception 参数表示的是当前请求的异常对象，如果在Controller 中抛出的异常已经被Spring 的异常处理器给处理了的话，那么这个异常对象就是是null 。

#### 配置拦截器
```xml
<mvc:interceptors>
	<bean class="com.windylee.interceptor.AllInterceptor"/>
	<mvc:interceptor>
    	<!--指定拦截器的拦截路径-->
     	<mvc:mapping path="/interceptor/**"/>
        <!--指定拦截器的实现类-->
		<bean class="com.windylee.interceptor.StopWatchHandlerInterceptor"/>
	</mvc:interceptor>
</mvc:interceptors>
```
`mvc:interceptors`标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，在mvc:interceptors标签下声明interceptor主要有两种方式：

- 直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。例子中的`AllInterceptor`会拦截所有请求
- 使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。

#### 推荐
推荐能使用servlet规范中的过滤器Filter实现的功能就用Filter实现，因为HandlerInteceptor只有在Spring Web MVC环境下才能使用，因此Filter是最通用的、最先应该使用的。如登录这种拦截器最好使用Filter来实现。

