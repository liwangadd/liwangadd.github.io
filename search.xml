<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Nginx入门教程]]></title>
    <url>%2Fposts%2F750751bd%2F</url>
    <content type="text"><![CDATA[介绍Nginx是一个开源、高性能的HTTP服务器和反向代理服务器，还可以用来作为IMAP/POP3的代理服务器，其处理静态文件、索引文件的效率非常高。相比于apache的多进程多线程的并发模型，Nginx是基于事件的异步IO的并发模型，支持epoll/kqueue等网络IO模型。安装安装Nginx主要有两种方式，通过仓库中的二级制包安装和源码安装。在Ubuntu系统中可以通过sudo apt-get install nginx从官方仓库中安装，这种安装方式可以满足用户的基本需求。但如果对Nginx的精简度和性能有非常高的要求，就需要通过源码的方式安装，分为以下三步：123./configuremakesudo make install如果要对Nginx进行定制，就需要在第一步制定需求，主要参数如下：–conf-path 指定配置文件的位置，默认为/etc/nginx/nginx.conf–error-log-path 指定错误日志文件所在位置，默认为/var/log/nginx/error.log,安装完成后可在配置文件中进行配置–http-log-path 指定http连接日志文件所在位置，默认为/var/log/nginx/access.log–with-模块名称 该模块会被编译–without-模块名称 编译时将该模块排除在外源码安装完成之后，默认Nginx服务已经启动。若想手动启动Nginx服务可以通过sudo service nginx start,同理关闭或者重启可以通过sudo service nginx stop/restart。 虽然Nginx重启速度很快，但是每次修改配置文件后，仅仅想让配置文件生效可以通过sudo nginx -s reload 命令，而不用重启服务配置文件详解Nginx是模块化的系统，整个系统被分成一个个的模块，每个模块负责不同的功能。例如http_gzip_static_module是负责压缩的，http_ssl_module是负责加密的。如果想使用某个模块需要在编译时将其加入其中，使用被编译的模块需要通过指令，整个配置文件就是通过指令组成的。默认的配置文件位于/etc/nginx/nginx.conf，内容如下12345678910111213141516171819202122232425262728user nginx;worker_processes 1;pid /run/nginx.pid;events &#123; worker_connections 768;&#125;http &#123; sendfile on; tcp_nopush on; tcp_nodelay on; keepalive_timeout 65; types_hash_max_size 2048; include /etc/nginx/mime.types; default_type application/octet-stream; access_log /var/log/nginx/access.log; error_log /var/log/nginx/error.log; gzip on; gzip_disable "msie6"; include /etc/nginx/conf.d/*.conf; include /etc/nginx/sites-enabled/*;&#125;可以看到，配置文件主要由两个block组成。Nginx是存在三个顶级block的，分别是123456events &#123;&#125;http &#123;&#125;mail&#123;&#125;从配置文件中可以看出：events模块中包含nginx中所有处理连接的设置，可以通过worker_connections指定每个工作进程可以同时接受的最大连接数；http模块主要是用来配置web服务，可以用于指定是否启用压缩，是否支持发送文件等；mail模块用来配置IMAP/POP3代理。我们主要关注http模块，如果Nginx的配置文件过大，将全部配置写在同一文件中将难以维护，此时可以将不同用途的配置写在不同的配置文件中，通过include指令加载进来。如果想要部署一个网站，就需要在http模块中添加一个server块。下面看一个例子。12345678910111213141516171819server &#123; listen 80; server_name example.org www.example.org; root /usr/nginx/www; location / &#123; index index.html index.php; &#125; location ^~ /images/ &#123; index icon.html; &#125; location ~* \.(gif|jpg|png)$ &#123; expires 30d; &#125; error_page 500 502 503 /50x.html;&#125;在电脑中的hosts文件中，加入一行127.0.0.1 www.example.org，在浏览器中输入www.example.org就可以访问了。该配置中通过listen表明监听80端口，通过server_name指定网站的域名，通过root指定网站的根目录，最下面的error_page说明当服务器发生500、502、503错误时，将网站根目录下的50x.html返回给用户。下面我们主要关注location指令，location用于URL模式设置，可以看到在匹配的URL开头有一些特殊符号，不同的符号用于限定在匹配时采用的特殊规则：=开头表示精确匹配，与指定字符串有任何区别将不能匹配成功^~开头表示匹配以指定字符串开头的URL，不适用正则~开头表示区分大小写的正则匹配~*开头表示不区分大小写的正则匹配/通用匹配，如果所有匹配都失败，则返回该默认匹配各种匹配的优先级为：(=) &gt; (完整路径) &gt; (^~) &gt; (~, ~*) &gt; (location 部分起始路径) &gt; (/)。在上面的配置文件中的$符号是正则表达式中的结束标志。在最后一个location中有expires指令，该指令的作用是让Nginx缓存请求返回的信息(这里是图片静态文件)，缓存的有效期的30天。反向代理代理可以分问正向代理和反向代理。正向代理的步骤是：用户要访问服务器C，而用户的请求会先到达代理服务器B，然后B再将用户请求转发到服务器C，此时代理服务器B才是真正访问服务器C的，代理服务器B再将得到的结果转发给用户。在这个过程中用户就像直接访问服务器C一样，过程中不知道代理服务器的存在。而反响代理的步骤是：用户只知道代理服务器的地址，通过该地址直接访问代理服务器B，代理服务器B将请求转发给真正的服务提供者C，得到结果后再返回给用户。用户根本不知道服务提供者的地址或者完全不能访问到，整个过程用户是直接与代理服务器B交互的。反向代理可以用来隐藏和保护原始服务器，实现负载均衡，加密和SSL加速等。Nginx的反向代理是通过ngx_http_proxy_module这个模块实现的，nginx可以代理的协议有http(s)、fastcgi、uswgi、memcached等。下面是实现的一个简单代理服务器的配置文件。123456789101112131415161718192021....http&#123; .... upstream java_demo&#123; # 实际服务器的地址 server 127.0.0.1:8080; &#125; server &#123; server_name www.example.com; listen 443; proxy_connect_timeout 180; # nginx跟后端服务器连接超时时间(代理连接超时) proxy_send_timeout 180; proxy_read_timeout 180; # 连接成功后，后端服务器响应时间(代理接收超时) proxy_set_header Host $host; proxy_set_header X-Forwarder-For $remote_addr; location / &#123; # 将请求转发到实际服务提供者 proxy_pass http://java_demo; &#125; &#125;gzip压缩当css文件和js文件过大时，可以通过压缩的机制提高网站的加载速度。Nginx通过ngx_http_gzip_module模块实现对文件的压缩操作，启用压缩要在配置文件中指定。123456789101112131415161718....http &#123; gzip on; gzip_disable "msie6"; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript; server &#123; location ~ ^/assets/ &#123; gzip_static on; expires max; add_header Cache-Control public; &#125; &#125;&#125;使用gzip指令来启用gzip压缩功能，使用gzip_types限制了要压缩的文件类型。这两个属性时必须配置的，其他属性根据需要进行配置。同时需要在要启用压缩的location块中加入配置文件中的那三行。负载均衡听说过nginx的人肯定都知道其在负载均衡中的重要角色，几乎成熟的网站都会使用nginx作为负载均衡服务器。同时nginx也在不断发展，在1.9版本之前其只能作为http的负载均衡，而在1.9之后其也实现了对tcp进行负载均衡。nginx负载均衡模块实现了如下4种调度方式：round-robin：Nginx默认的轮询算法，每个请求按时间顺序逐一分配到不同的后端服务器。可以通过weight指定轮询权值，权值越大表明被访问到的可能性越大。1234upstream java_demo &#123; server 127.0.0.1:8080 weight=2; server 127.0.0.1:8081 weight=1;&#125;​least_conn：请求会被发送到活跃连接数最少的服务器上。12345upstream java_demo &#123; least_conn; server 127.0.0.1:8080; server 127.0.0.1:8081;&#125;​ip_hash：根据访问用户ip的hash结果分配请求，相同的ip总是会被分配到同一台应用服务器。12345upstream java_demo &#123; ip_hash; server 127.0.0.1:8080; server 127.0.0.1:8081;&#125;​hash：相比于ip_hash方式，这是一个粒度更小的控制，ip_hash默认是用户ip的hash值。而该方式根据指定字段的hash值进行分配。12345upstream java_demo &#123; hash $request_uri; # 根据请求地址分配 server 127.0.0.1:8080; server 127.0.0.1:8081;&#125;nginx对负载均衡提供了很好的支持，相对于反向代理，我们只需在upstream块中添加多个server地址和指定负载均衡算法，nginx就可以根据我们指定的负载均衡算法分发用户请求。在配置负载均衡时，upstream块中的server可以有如下配置参数down。加入该字段的server将暂时不参与负载均衡，对该服务器的请求会自动发送到下一个服务器。backup。预留的备份服务器，当其他所有的非backup都出现故障或者忙的时候，才会将请求发送到该服务器。weight。指定该服务器被访问到的概率，值越大被访问到的概率越高，默认weight的权值为1。max_fails。表示请求失败的次数，若某一服务器对同一请求失败超过max_fails次，则将该请求发送到下一服务器。max_timeout。表示请求失败的超时时间，在设定的时间内没有成功，就作为失败处理。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring定时任务]]></title>
    <url>%2Fposts%2F4016a806%2F</url>
    <content type="text"><![CDATA[关于spring的定时任务，我们在spring3.0之前一般会使用Quartz，这是一个功能相当强大的调度器，可以让你的程序在指定时间执行，也可以按照某个频度执行，但是配置起来稍显复杂。Spring3.0以后自带task，可以将它看成一个轻量级的Quartz，使用起来比Quartz简单许多，不需要额外的包，而且支持注解和配置文件两种形式。基本使用配置文件方式首先需要在配置文件中引入task命名空间12345&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:task="http://www.springframework.org/schema/task" ... http://www.springframework.org/schema/task http://www.springframework.org/schema/task/spring-task.xsd"&gt;然后配置需要定时执行的任务12345678&lt;!--Spring定时器注解开关，注册之后可以再java类中使用task命名空间的注解--&gt;&lt;task:annotation-driven scheduler="myScheduler"/&gt; &lt;!--内部使用的线程池，配置线程池，指定线程池的大小--&gt; &lt;task:scheduler id="myScheduler" pool-size="10&gt; &lt;!--配置定时任务，指定需要定时执行的类和方法，并配置调度方式--&gt; &lt;task:scheduled-task scheduler="myScheduler"&gt; &lt;task:scheduled ref="scheduledTaskManager" method="autoCardCalculate" cron="0 5 * * * *"/&gt; &lt;/task:scheduled-task&gt;注解形式首先我们看一下源码中注解的定义123456789101112131415161718192021@Target(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Repeatable(Schedules.class)public @interface Scheduled &#123; String cron() default ""; String zone() default ""; long fixedDelay() default -1L; String fixedDelayString() default ""; long fixedRate() default -1L; String fixedRateString() default ""; long initialDelay() default -1L; String initialDelayString() default "";&#125;我们可以看到该注解有八个参数，分别表示的意思是：cron：指定cron表达式zone：指定时区fixedRate：从上一个任务开始到下一个任务开始的间隔，单位是毫秒fixedDelay：从上一个任务完成到下一个任务开始的间隔，单位是毫秒initialDelay：任务第一次执行前需要延迟的毫秒数这些配置参数都可以在xml配置文件中使用，效果是一样的执行任务的POJO类1234567891011121314151617181920212223242526public class ScheduledTaskManager&#123; /** * 每日凌晨2点执行一次 */ @Scheduled(cron = "0 0 2 * * *") public void autoCardCalculate() &#123; System.out.println("hello world" + new Date()); &#125; /** * 心跳更新，启动时执行一次，之后每隔一分钟执行一次 */ @Scheduled(fixedRate = 1000 * 60) public void heartbeat() &#123; System.out.println("hello world" + new Date()); &#125; /** * 启动后一秒钟之后执行一次，之后每次执行完间隔2分钟执行一次 */ @Scheduled(fixedDelay = 1000 * 60 * 2, initialDelay = 1000) public void persistRecord() &#123; System.out.println("hello world" + new Date()); &#125;&#125;组合多个Scheduled@Scheduled可以让我们很方便的配置定时任务，但是有的定时任务不是一个表达式就能表达完全的，比如说我既想在周三10:10又想在周四17:40执行某项任务。这时候我们很难用一个表示式，或者根本行不通，这时候我们就要组合多个@Scheduled表达式。@Schedules注解里面只有一个参数Scheduled数组，意味着我们可以将多个@Scheduled压入数组，组合使用12//每隔18秒执行一次，并且每天的4:00执行一次@Schedules(&#123;@Scheduled(cron = "* * 4 * * *"),@Scheduled(fixedRate = 1000*18)&#125;)cronExpression的配置说明各字段意义字段允许值允许的特殊字符秒0-59, - * /分0-59, - * /小时0-23, - * /日期1-31, - * /月份1-12或JAN-DEC, - * /星期1-7或SUN-SAT, - * /年（可选）留空，1970-2099, - * /- 指定区间* 通配符? 你不想设置那个值/ 没多少执行一次例子CRON表达式含义0 0 12 * * ?每天中午12点触发0 15 10 ? * *每天上午10:15触发0 15 10 * * ?每天上午10:15触发0 15 10 * * ? *每天上午10:15触发0 15 10 * * ? 20152015年的每天上午10:15触发0 * 14 * * ?每天下午14:00到14：59每分钟触发一次0 0/5 14 * * ?每天下午14:00到14:55没5分钟触发一次0 0/5 14,18 * * ?每天14:00到14:55和18:00到18:55每5分钟触发一次0 0-5 14 * * ?每天14:00前五分钟每分钟触发一次0 10,44 14 ? 3 WED3月每周三14:10和14:44触发0 15 10 ? * MON-FRI周一到周五的10:15触发]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring异步任务]]></title>
    <url>%2Fposts%2Fc0ceddf6%2F</url>
    <content type="text"><![CDATA[在Spring3.0之前如果我们想要异步执行某项任务，需要我们自己编写线程池来实现。在Spring3.X新增了注解@Async，可以标记方法或者类中的所有方法都可以异步执行，而调用他的方法会在原来的线程中执行。这样可以避免阻塞，保证任务的实时性。适用于处理log，发送邮件等#### 配置##### 配置文件同Spring自己实现的定时任务一样，我们需要在配置文件中引入task命名空间123456789101112&lt;beans xmlns="http://www.springframework.org/schema/beans"​ xmlns:task="http://www.springframework.org/schema/task"​ ...​ http://www.springframework.org/schema/task​ http://www.springframework.org/schema/task/spring-task.xsd"&gt;\然后配置相关的线程池和缺省的异步调度器\123456789101112&lt;!--配置executor，一个应用中可以有多个executor--&gt;&lt;task:executor id="mailExecutor" pool-size="10" keep-alive="100" queue-capacity="5" rejection-policy="ABORT"/&gt;&lt;task:executor id="logExecutor" pool-size="10"/&gt;&lt;!--指定一个缺省的executor给@Async使用，当@Async没有指定使用哪个executor将默认使用该executor--&gt;&lt;task:annotation-driven executor="mailExecutor"/&gt;\##### 配置参数- id: 当配置多个executor时，被@Async(“id”)指定使用，也可以作为线程名的前缀- pool-size 指定线程池的大小- queue-capacity：当最小的线程数已经被占用满后，新的任务会被放进queue里面，当这个queue的capacity也被占满之后，pool里面会创建新线程处理这个任务，直到总线程数达到了max size，这是系统会拒绝这个任务并抛出TaskRejectedException异常(可以通过rejection-policy来决定如何处理这种情况)，缺省值为Integer.MAX_VALUE- keey-alive：超过core size的那些线程，任务完成后，经过这个时长就会被结束掉- rejection-policy：当pool已经达到max size的时候，如何处理新任务ABORT（缺省）：抛出TaskRejectedException异常，然后不执行DISCARD：不执行，也不抛出异常DISCARD_OLDEST：丢弃queue中最旧的那个任务CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行#### 注解##### 注解源码\1234567891011121314@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface Async &#123;​ String value() default "";&#125;\通过@Async的源码我们可以知道，该注解可以用在方法上也可以用在类上，注解在方法上表明该方法是一部执行的，注解在类上表明该类中的所有方法都是一步执行的##### 方法返回值如果我们不想从异步线程中获取返回值，那么我们可以将返回值声明为void。如果我们想要从线程中获取数据，可以使用Future作为返回值。通过future.get()得到需要返回的对象，也可以使用future,get(time,unit)，在制定时间内获取返回值，如果超过设置的时间则抛出异常\1234567891011121314151617181920212223242526272829303132333435363738@Async("logExecutor")​ public void business() throws InterruptedException &#123;​ System.out.println("异步任务开始执行");​ Thread.sleep(2000);​ System.out.println("异步任务执行结束");​ &#125;​ /**​ \* 没有指定调度器将使用缺省值​ \* @return​ \* @throws InterruptedException​ */[^]​ @Async​ public Future&lt;String&gt; business2() throws InterruptedException &#123;​ System.out.println("异步任务开始执行");​ Thread.sleep(2000);​ System.out.println("异步任务执行结束");​ return new AsyncResult&lt;String&gt;("hello world");​ &#125;\]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring拦截器]]></title>
    <url>%2Fposts%2F2b6e765e%2F</url>
    <content type="text"><![CDATA[处理器拦截器简介Spring MVC的处理器拦截器类型于Servlet开发中的Filter，用于对处理器进行预处理和后处理常见应用场景日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面性能监控：通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。拦截器实现SpringMVC 中的Interceptor拦截请求是通过HandlerInterceptor来实现的。在SpringMVC中定义一个Interceptor非常简单，主要有两种方式，第一种方式是要定义的Interceptor类要实现了Spring 的HandlerInterceptor接口，或者是这个类继承实现了HandlerInterceptor接口的类，比如Spring 已经提供的实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapte；第二种方式是实现Spring的WebRequestInterceptor接口，或者是继承实现了WebRequestInterceptor的类。HandlerInterceptor接口12345678910111213141516public interface HandlerInterceptor &#123; boolean preHandle( HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception; void postHandle( HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception; void afterCompletion( HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception; &#125;有接口的定义我们可以看出HandlerInterceptor中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。preHandle实现处理器的预处理，第三个参数为响应处理器（一般为Controller）。返回true表示继续流程；返回false表示中断流程，不会继续调用其他的拦截器和处理器，这时候我们需要通过response来产生响应。我们可以在该方法中进行一些前置初始化操作或者是对当前请求的一个预处理。postHandle实现处理器的后处理，但是在DispatcherServlet渲染页面之前调用，我们可以调用modelAndView进行模型数据进行处理或对视图进行处理afterCompleting视图渲染完毕后回调该方法，该方法主要用于数据清理如果我们继承自HandlerInterceptor接口，那么我们每次都需要重写三个方法。但是大多数时候我们只需要重写其中一两个方法，这时候我们可以继承HandlerInterceptorAdapter类，选择性的重写其中的方法。下面给出一个计算请求处理时间的例子123456789101112131415161718192021public class StopWatchHandlerInterceptor extends HandlerInterceptorAdapter &#123; private NamedThreadLocal&lt;Clock&gt; startTimeThreadLocal = new NamedThreadLocal&lt;Clock&gt;("StopWatch-StartTime"); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response,Object handler) throws Exception &#123; Cloxk start = Clock.now()//1、开始时间 startTimeThreadLocal.set(beginTime);//线程绑定变量（该数据只有当前请求的线程可见） return true;//继续流程 &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; Clock end = Clock.now();//2、结束时间 Clock start = startTimeThreadLocal.get();//得到线程绑定的局部变量（开始时间） long consumeTime = Duration.betwen(start, end).toMillis()//3、消耗的时间 System.out.println(String.format("%s consume %d millis", request.getRequestURI(), consumeTime)); &#125;&#125;WebRequestInterceptor接口该接口中也定义了三个方法，我们也可以通过这三个方法来实现拦截，这三个方法都传递了同一个参数WebRequest，三个方法的调用时机同HanlderInterceptor。WebRequest是Spring中定义的一个接口，方法基本和HttpServletRequest一样，对WebRequest做的任何操作都会同步到HttpServletRequest，然后在当前请求中一直传递preHandle(WebRequest request)由于没有返回值，无法控制请求流程。我们一般在该方法中进行资源的准备工作。比如我们在使用Hibernate的时候可以在这个方法中准备一个Hibernate的Session对象，然后利用WebRequest的setAttribute(name, value, scope)把它放到WebRequest 的属性中。这里可以说说这个setAttribute 方法的第三个参数scope：SCOPE_REQUEST ：它的值是0 ，代表只有在request 中可以访问。SCOPE_SESSION ：它的值是1 ，如果环境允许的话它代表的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。SCOPE_GLOBAL_SESSION ：它的值是2 ，如果环境允许的话，它代表的是一个全局共享的session，否则就代表普通的session，并且在该session 范围内可以访问。postHandle(WebRequest request, ModelMap model)ModelMap 就是Controller 处理之后返回的Model 对象，我们可以通过改变它的属性来改变返回的Model 模型。afterCompletion(WebRequest request, Exception ex)可以在该方法中进行资源的释放操作，Exception 参数表示的是当前请求的异常对象，如果在Controller 中抛出的异常已经被Spring 的异常处理器给处理了的话，那么这个异常对象就是是null 。配置拦截器123456789&lt;mvc:interceptors&gt; &lt;bean class="com.windylee.interceptor.AllInterceptor"/&gt; &lt;mvc:interceptor&gt; &lt;!--指定拦截器的拦截路径--&gt; &lt;mvc:mapping path="/interceptor/**"/&gt; &lt;!--指定拦截器的实现类--&gt; &lt;bean class="com.windylee.interceptor.StopWatchHandlerInterceptor"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt;mvc:interceptors标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，在mvc:interceptors标签下声明interceptor主要有两种方式：直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。例子中的AllInterceptor会拦截所有请求使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。推荐推荐能使用servlet规范中的过滤器Filter实现的功能就用Filter实现，因为HandlerInteceptor只有在Spring Web MVC环境下才能使用，因此Filter是最通用的、最先应该使用的。如登录这种拦截器最好使用Filter来实现。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java8新的时间日期库]]></title>
    <url>%2Fposts%2Fb5a2dc36%2F</url>
    <content type="text"><![CDATA[综述时间API分类概述新的API： java.time，由5个包组成java.time- 包含值对象的基础包java.time.chrono - 提供对不同的日历系统的访问java.time.format - 格式化和解析时间和日期java.time.temporal - 包括底层框架和扩展特性java.time.zone - 包含市区支持的类我们平时只会用到基础和format包，也可能用到temporal包，因此虽然新的API提供了多达68个新的公开类型，但是我们一般只会用到其中的三分之一关键日期/时间概述不可变性。借鉴于java.util.Calendar的前车之鉴，设计这个API的时候着重考虑了原有方法的不可变性，不允许任何更改，如果必须改变的话就会返回一个新的实例，所以我们必须捕获该方法的返回值瞬间性。表示时间上的某个精确的时刻，使用从epoch开始计算的毫秒表示关键API使用Clock他可以通过时区来获取当前的instant，日期和时间。Clock类可以用来代替System.currentTimeMillis()和TimeZone.getDefault()123Clock clock=Clock.systemUTC();//获取格林尼治时间System.out.println(clock.instant());//获取Instant类型数据，后面会讲到System.out.println(clock.millis());//获取标准毫秒数Instant所谓的Instant累代表的是某个时间（有点类似与java.util.Date），他是精确到纳秒的，而Date是精确到毫秒的。instant表示的是时间线上的一点，而不需要任何上下文信息，例如：时区。概念上讲他只是简单的表示自1970年1月1日0是0分0秒开始的秒数。下面给去确定一个方法的运行时间长度的代码1234567Instant start = Instant.now();doSomeThing();Instant end = Instant.now();Duration duration = Duration.between(start, end);long seconds = duration.getSeconds();//秒表示long millis = duration.toMillis();//毫秒表示boolean isAfter = end.isAfter(start);//时间点end是否在start之后[^]常用函数now() 静态函数，获取当前时间戳isAfter()/isBefore() 判断两个时间点的先后顺序plusXXX() 在该时间点加上某段时间minusXXX() 在该时间点上减去某段时间Instant用在当你需要记录事件的发生时间，额如需要记录任何有关时区信息时。Instant只能包含秒数和毫秒数，例如如下代码就会抛出异常12instant.get(ChronoField.MONTH_OF_YEAR);instant.plus(6, ChronoUnit.YEARS);LocalDateLocalDate表示日期的不可变类型，不包含时间和时区。LocalDate和下面要讲的LocalTime都被设计成值类型的，这意味着我们不能用==来判断两个LocalDate是不是相等而是应该通过equals()。下面给出一个获取当前年月日的例子12345LocalDate today = LocalDate.now(); int year = today.getYear(); int month = today.getMonthValue(); int day = today.getDayOfMonth(); System.out.printf("Year : %d Month : %d day : %d \t %n", year, month, day);常用函数now()根据当前时间戳创建LocalDateof()根据制定的年月日创建LocalDateparse(charqueue, DateTimeFormatter)根据传入的format将字符串转化为LocalDate对象ofYearDay()根据指定的年和一年中的第几天创建LocalDategetXXX()获取当前LocalDate中关于日期的信息，年月日等等plusXXX()在当前的LocalDate的基础上增加指定时间类型来创建一个新的LocalDateminusXXX()在当前的LocalDate的基础上减去指定时间类型来创建一个新的LocalDatewithXXX()在当前的LocalDate的基础上指定某个时间类型的值来创建一个新的LocalDateisXXX()判断两个LocalDate的大小关系，特别（isLeepYear()判断是否为闰年）lengthOfXXX()获取LocalDate代表的年或月的天数with(TemporalAdjuster)TemporalAdjusters提供了几个用来获取TemporalAdjuster的方法，用来处理比较复杂的逻辑，比如获取当月的最后一天lastDayOfMonth()atTime()将LocalDate转化为LocalDateTimeLocalTimeLocalTime是值类型，且和日期，时区没有关联。当我们对时间进行加减操作时，以午夜为基准，24小时一个周期。因此，20:00加上6小时，结果是02:00。LocalTime用法和LocalDate类似12345LocalTime time = LocalTime.of(20, 30);int hour = date.getHour(); // 20int minute = date.getMinute(); // 30time = time.withSecond(6); // 20:30:06time = time.plusMinutes(3); // 20:33:06常用函数和LocalDate基本类似，只是将对年月日的操作转换为时分秒toSecondOfDay()获取该时间点距离0:00的秒数LocalDateTime这个值类型只是LocalDate和LocalTime的简单组合。他表示一个和时区无关的日期和时间。LocalDateTime可以直接创建或者组合时间和日期1234LocalDateTime dt1 = LocalDateTime.of(2014, Month.JUNE, 10, 20, 30);LocalDateTime dt2 = LocalDateTime.of(date, time);Month month = dt1.getMonth();int minute = dt1.getMinute();常用函数将LocalDate和LocalTime两个类的plusXXX(), minusXXX(), withXXX(),getXXX()简单相加与LocalDate对象其他函数完全类似isXXX()与LocalDate完全一样toLocalDate()/toLocalTime()将LocalDateTime转换为LocalTime或者LocalDate时间长度Duration表示以秒和纳秒位基准的时长；Period表示以年，月，日衡量的时长。他们可以作为参数，传给主要的时间/日期类的增加或减少的方法，也可以计算两个时间点之间的间隔12345Duration duration = Duration.ofDays(10);LocalTime start = LocalTime.now();doSoneThing();LocalTime end = LocalTime.now();Duration spend = Duration.between(start, end);常用函数ofXXX()根据参数指定的大小计算以XXX个单位的时间间隔between(arg1, arg2)计算两个参数时间点的时间间隔plusXXX()/minuxXXX()在当前时间间隔的基础上加上或减去指定个单位的时间toXXX()将时间间隔格式化位指定单位的时间，Duration一般使用该类型函数，Period一般使用getXXX()abs()求时间间隔的绝对值，保证时间间隔不为负数isZero()/isNegative()判断时间间隔是否为0或负withXXX()直接指定某个单位的值格式化java.time.format包是专门用来格式化输出输入时间/日期的。这个包围绕DateTimeFormatter类和它的辅助创建类DateTimeFormatterBuilder展开。静态方法ofPattern(Charqueue)和DateTimeFormatter中的常量是最通用的创建格式化器的方式常用ISO格式常量，如ISO_LOCAL_DATE字母模式，如ofPattern(“dd/MM/uuuu”)本地化样式，如ofLocalizedDate(FormatStyle.MEDIUM)有了格式化器，我们就可以将该实例传递给parse()或者format()作为参数，用来将字符串格式化为对象或者将对象格式化位字符串12345678910111213141516171819//按照内置的不同方式格式化String format = DateTimeFormatter.ISO_LOCAL_DATE.format(LocalDate.now());String format2 = DateTimeFormatter.ISO_LOCAL_TIME.format(LocalTime.now());String format3 = DateTimeFormatter.ISO_DATE.format(LocalDateTime.now());String format4 = DateTimeFormatter.ISO_INSTANT.format(Instant.now());System.out.println(format);System.out.println(format2);System.out.println(format3);System.out.println(format4); //按照标准格式格式化DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);String format5 = formatter.format(LocalDateTime.now());System.out.println(format5); //按照指定方式格式化DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy-MM-dd E HH:mm:ss");String format6 = pattern.format(LocalDateTime.now());System.out.println(format6);其他YearMonth仅仅包含年和月字段，操作也LocalDate类似MonthDay仅仅包含月和日字段，操作与LocalDate类似]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[effictive-java读书笔记]]></title>
    <url>%2Fposts%2F636894a%2F</url>
    <content type="text"><![CDATA[Effective Java一书笔记对象的创建与销毁Item 1: 使用static工厂方法，而不是构造函数创建对象仅仅是创建对象的方法，并非Factory Pattern优点命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutable的对象来说，使得用==判等符合语义，且更高效；工厂方法能够返回任何返回类型的子类对象，甚至是私有实现；使得开发模块之间通过接口耦合，降低耦合度；而接口的实现也将更加灵活；接口不能有static方法，通常做法是为其再创建一个工厂方法类，如Collection与Collections；Read More: Service Provider Framework缺点仅有static工厂方法，没有public/protected构造函数的类将无法被继承；见仁见智，这一方面也迫使开发者倾向于组合而非继承；Javadoc中不能和其他static方法区分开，没有构造函数的集中显示优点；但可以通过公约的命名规则来改善；小结static工厂方法和public构造函数均有其优缺点，在编码过程中，可以先考虑一下工厂方法是否合适，再进行选择。Item 2: 使用当构造函数的参数较多，尤其是其中还有部分是可选参数时，使用Builder模式以往的方法Telescoping constructor：针对可选参数，从0个到最多个，依次编写一个构造函数，它们按照参数数量由少到多逐层调用，最终调用到完整参数的构造函数；代码冗余，有时还得传递无意义参数，而且容易导致使用过程中出隐蔽的bug；JavaBeans Pattern：灵活，但是缺乏安全性，有状态不一致问题，线程安全问题；Builder Pattern代码灵活简洁；具备安全性；immutable参数检查：最好放在要build的对象的构造函数中，而非builder的构建过程中支持多个field以varargs的方式设置（每个函数只能有一个varargs）一个builder可以build多个对象Builder结合泛型，实现Abstract Factory Pattern传统的抽象工厂模式，是用Class类实现的，然而其有缺点：newInstance调用总是去调用无参数构造函数，不能保证存在；newInstance方法会抛出所有无参数构造函数中的异常，而且不会被编译期的异常检查机制覆盖；可能会导致运行时异常，而非编译期错误；小结Builder模式在简单地类（参数较少，例如4个以下）中，优势并不明显，但是需要予以考虑，尤其是当参数可能会变多时，有可选参数时更是如此。Item 3: 单例模式！不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。double-check-locking123456789101112private static volatile RestAdapter sRestAdapter = null;public static RestAdapter provideRestAdapter() &#123; if (sRestAdapter == null) &#123; synchronized (RestProvider.class) &#123; if (sRestAdapter == null) &#123; sRestAdapter = new RestAdapter(); &#125; &#125; &#125; return sRestAdapter;&#125;DCL可能会失效，因为指令重排可能导致同步解除后，对象初始化不完全就被其他线程获取；使用volatile关键字修饰对象，或者使用static SingletonHolder来避免该问题（后者JLS推荐）；class的static代码：一个类只有在被使用时才会初始化，而类初始化过程是非并行的，这些都由JLS能保证用enum实现单例还存在反射安全性问题：利用反射，可以访问私有方法，可通过加一个控制变量，该变量在getInstance函数中设置，如果不是从getInstance调用构造函数，则抛出异常；Item 4: 将构造函数私有化，使得不能从类外创建实例，同时也能禁止类被继承util类可能不希望被实例化，有其需求Item 5: 避免创建不必要的对象提高性能：创建对象需要时间、空间，“重量级”对象尤甚；immutable的对象也应该避免重复创建，例如String；避免auto-boxing但是因此而故意不创建必要的对象是错误的，使用object pool通常也是没必要的lazy initialize也不是特别必要，除非使用场景很少且很重量级Map#keySet方法，每次调用返回的是同一个Set对象，如果修改了返回的set，其他使用的代码可能会产生bug需要defensive copying的时候，如果没有创建一个新对象，将导致很隐藏的BugItem 6: 不再使用的对象一定要解除引用，避免memory leak例如，用数组实现一个栈，pop的时候，如果仅仅是移动下标，没有把pop出栈的数组位置引用解除，将发生内存泄漏程序发生错误之后，应该尽快把错误抛出，而不是以错误的状态继续运行，否则可能导致更大的问题通过把变量（引用）置为null不是最好的实现方式，只有在极端情况下才需要这样；好的办法是通过作用域来使得变量的引用过期，所以尽量缩小变量的作用域是很好的实践；注意，在Dalvik虚拟机中，存在一个细微的bug，可能会导致内存泄漏，详见当一个类管理了一块内存，用于保存其他对象（数据）时，例如用数组实现的栈，底层通过一个数组来管理数据，但是数组的大小不等于有效数据的大小，GC器却并不知道这件事，所以这时候，需要对其管理的数据对象进行null解引用当一个类管理了一块内存，用于保存其他对象（数据）时，程序员应该保持高度警惕，避免出现内存泄漏，一旦数据无效之后，需要立即解除引用实现缓存的时候也很容易导致内存泄漏，放进缓存的对象一定要有换出机制，或者通过弱引用来进行引用listner和callback也有可能导致内存泄漏，最好使用弱引用来进行引用，使得其可以被GCItem 7: 不要使用finalize方法finalize方法不同于C++的析构函数，不是用来释放资源的好地方finalize方法执行并不及时，其执行线程优先级很低，而当对象unreachable之后，需要执行finalize方法之后才能释放，所以会导致对象生存周期变长，甚至根本不会释放finalize方法的执行并不保证执行成功/完成使用finalize时，性能会严重下降finalize存在的意义充当“safety net”的角色，避免对象的使用者忘记调用显式termination方法，尽管finalize方法的执行时间没有保证，但是晚释放资源好过不释放资源；此处输出log警告有利于排查bug用于释放native peer，但是当native peer持有必须要释放的资源时，应该定义显式termination方法子类finalize方法并不会自动调用父类finalize方法（和构造函数不同），为了避免子类不手动调用父类的finalize方法导致父类的资源未被释放，当需要使用finalize时，使用finalizer guardian比较好：定义一个私有的匿名Object子类对象，重写其finalize方法，在其中进行父类要做的工作因为当父类对象被回收时，finalizer guardian也会被回收，它的finalize方法就一定会被触发##Object的方法尽管Object不是抽象类，但是其定义的非final方法设计的时候都是希望被重写的，finalize除外。Item 8: 当重写equals方法时，遵循其语义能不重写equals时就不要重写当对象表达的不是值，而是可变的状态时对象不需要使用判等时父类已重写，且满足子类语义当需要判等，且继承实现无法满足语义时，需要重写（通常是“value class”，或immutable对象）当用作map的key时重写equals时需要遵循的语义Reflexive（自反性）: x.equals(x)必须返回true（x不为null）Symmetric（对称性）: x.equals(y) == y.equals(x)Transitive（传递性）: x.equals(y) &amp;&amp; y.equals(z) ==&gt; x.equals(z)Consistent（一致性）: 当对象未发生改变时，多次调用应该返回同一结果x.equals(null)必须返回false实现建议先用==检查是否引用同一对象，提高性能用instanceof再检查是否同一类型再强制转换为正确的类型再对各个域进行equals检查，遵循同样的规则确认其语义正确，编写测例重写equals时，同时也重写hashCode！重写equals方法，传入的参数是ObjectItem 9: 重写equals时也重写hashCode函数避免在基于hash的集合中使用时出错语义一致性当两个对象equals返回true时，hashCode方法的返回值也要相同hashCode的计算方式要求：equals的两个对象hashCode一样，但是不equals的对象hashCode不一样取一个素数，例如17，result = 17对每一个关心的field（在equals中参与判断的field），记为f，将其转换为一个int，记为cboolean: f ? 1 : 0byte/char/short/int: (int) flong: (int) (f ^ (f &gt;&gt; 32))float: Float.floatToIntBits(f)double: Double.doubleToLongBits(f)，再按照long处理Object: f == null ? 0 : f.hashCode()array: 先计算每个元素的hashCode，再按照int处理对每个field计算的c，result = 31 * result + c返回result编写测例计算hashCode时，不重要的field（未参与equals判断）不要参与计算Item 10: 重写toString()方法增加可读性，简洁、可读、具有信息量Item 11: 慎重重写clone方法Cloneable接口是一个mixin interface，用于表明一个对象可以被cloneContractx.clone() != xx.clone().getClass() == x.getClass()：要求太弱，当一个非final类重写clone方法的时候，创建的对象一定要通过super.clone()来获得，所有父类都遵循同样的原则，如此最终通过Object.clone()创建对象，能保证创建的是正确的类实例。而这一点很难保证。x.clone().equals(x)不调用构造函数：要求太强，一般都会在clone函数里面调用对于成员变量都是primitive type的类，直接调用super.clone()，然后cast为自己的类型即可（重写时允许返回被重写类返回类型的子类，便于使用方，不必每次cast）成员变量包含对象（包括primitive type数组），可以通过递归调用成员的clone方法并赋值来实现然而上述方式违背了final的使用协议，final成员不允许再次赋值，然而clone方法里面必须要对其赋值，则无法使用final保证不可变性了递归调用成员的clone方法也会存在性能问题，对HashTable递归调用深拷贝也可能导致StackOverFlow（可以通过遍历添加来避免）优雅的方式是通过super.clone()创建对象，然后为成员变量设置相同的值，而不是简单地递归调用成员的clone方法和构造函数一样，在clone的过程中，不能调用non final的方法，如果调用虚函数，那么该函数会优先执行，而此时被clone的对象状态还未完成clone/construct，会导致corruption。因此上一条中提及的“设置相同的值”所调用的方法，要是final或者private。重载类的clone方法可以省略异常表的定义，如果重写时把可见性改为public，则应该省略，便于使用；如果设计为应该被继承，则应该重写得和Object的一样，且不应该实现Cloneable接口；多线程问题也需要考虑；要实现clone方法的类，都应该实现Cloneable接口，同时把clone方法可见性设为public，返回类型为自己，应该调用super.clone()来创建对象，然后手动设置每个域的值clone方法太过复杂，如果不实现Cloneable接口，也可以通过别的方式实现copy功能，或者不提供copy功能，immutable提供copy功能是无意义的提供拷贝构造函数，或者拷贝工厂方法，而且此种方法更加推荐，但也有其不足设计用来被继承的类时，如果不实现一个正确高效的clone重写，那么其子类也将无法实现正确高效的clone功能Item 12: 当对象自然有序时，实现Comparable接口实现Comparable接口可以利用其有序性特点，提高集合使用/搜索/排序的性能Contactsgn(x.compareTo(y)) == - sgn(y.compareTo(x))，当类型不对时，应该抛出ClassCastException，抛出异常的行为应该是一致的transitive: x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 ==&gt; x.compareTo(z) &gt; 0x.compareTo(y) == 0 ==&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z))建议，但非必须：与equals保持一致，即 x.compareTo(y) == 0 ==&gt; x.equals(y)，如果不一致，需要在文档中明确指出TreeSet, TreeMap等使用的就是有序保存，而HashSet, HashMap则是通过equals + hashCode保存当要为一个实现了Comparable接口的类增加成员变量时，不要通过继承来实现，而是使用组合，并提供原有对象的访问方法，以保持对Contract的遵循实现细节优先比较重要的域谨慎使用返回差值的方式，有可能会溢出##Classes and InterfacesItem 13: 最小化类、成员的可见性封装（隐藏）：公开的接口需要暴露，而接口的实现则需要隐藏，使得接口与实现解耦，降低模块耦合度，增加可测试性、稳定性、可维护性、可优化性、可修改性如果一个类只对一个类可见，则应该将其定义为私有的内部类，而没必要public的类都应该定义为package private为了便于测试，可以适当放松可见性，但也只应该改为package private，不能更高成员不能是非private的，尤其是可变的对象。一旦外部可访问，将失去对其内容的控制能力，而且会有多线程问题暴露的常量也不能是可变的对象，否则public static final也将失去其意义，final成员无法改变其指向，但其指向的对象却是可变的（immutable的对象除外），长度非0的数组同样也是有问题的，可以考虑每次访问时创建拷贝，或者使用Collections.unmodifiableList(Arrays.asList(arr))Item 14: public class中，使用accessor method而非public field后者外部可以直接访问，失去了安全性package private或者private则可以不必这样把immutable的field置为public勉强可以接受，mutable的成员一定不能置为publicItem 15: 最小化可变性不提供可以改变本对象状态的方法保证类不可被继承使用final field使用private field在构造函数、accessor中，对mutable field使用defensive copy实现建议操作函数，例如BigInteger的add方法，不是static的，但也不能改变本对象的状态，则使用functional的方式，返回一个新的对象，其状态是本对象修改之后的状态如此实现的immutable对象生来就是线程安全的，无需同步操作，但应该鼓励共用实例，避免创建过多重复的对象正确实现的immutable对象也不需要clone, copy方法；可以适当引入Object cache；劣势每一个值都需要一个对象，调用改变状态的方法而创建一个新的对象，尤其是它是重量级的，开销会变大；连续调用这样的方法，影响更大；为常用的多次操作组合提供一个方法其他保证class无法被继承，除了声明为final外，还可以将默认构造函数声明为private或package private，然后提供public static工厂方法使用public static工厂方法，具体实现类可以有多个，还能进行object cache当实现Serializable接口是，一定要实现readObject/readResolve方法，或者使用ObjectOutputStream.writeUnshared/ObjectInputStream.readUnshared小结除非有很好的理由让一个Class mutable，否则应该使其immutable如果非要mutable，也应尽可能限制其可变性Item 16: Favor composition (and forwarding) over inheritance跨包继承、继承不是被设计为应该被继承的实现类，是一件很危险的事情，继承接口、继承抽象类，当然是没问题的如果子类的功能依赖于父类的实现细节，那么一旦父类发生变化，子类将有可能出现Bug，即便代码都没有修改；而设计为应被继承的类，在修改后，是应该有文档说明的，子类开发者既可以得知，也可以知道如何修改例子：统计HashSet添加元素的次数用继承方式，重写add，addAll，在其中计数，这就不对，因为HashSet内部的addAll是通过调用add实现的但是通过不重写addAll也只不对的，以后有可能HashSet的实现就变了在重写中重新实现一遍父类的逻辑也是行不通的，因为这可能会导致性能问题、bug等，而且有些功能不访问私有成员也是无法实现的还有一个原因就是父类的实现中，可能会增加方法，改变其行为，而这一点，在子类中是无法控制的而通过组合的方式，将不会有这些问题，把另一个类的对象声明为私有成员，外部将无法访问它，自己也能在转发（forwarding）过程中执行拦截操作，也不必依赖其实现细节，这种组合、转发的实现被称为wrapper，或者Decorator pattern，或者delegation（严格来说不是代理，代理一般wrapper对象都需要把自己传入到被wrap的对象方法中？）缺点不适用于callback frameworks？继承应该在is-a的场景中使用继承除了会继承父类的API功能，也会继承父类的设计缺陷，而组合则可以隐藏成员类的设计缺陷Item 17: Design and document for inheritance or else prohibit it一个类必须在文档中说明，每个可重写的方法，在该类的实现中的哪些地方会被调用（the class must document its self-use of overridable methods）。调用时机、顺序、结果产生的影响，包括多线程、初始化等情况。被继承类应该通过谨慎选择protected的方法或成员，来提供一些hook，用于改变其内部的行为，例如java.util.AbstractList::removeRange。The only way to test a class designed for inheritance is to write subclasses. 用于判断是否需要增加或者减少protected成员/方法，通常写3个子类就差不多了。You must test your class by writing subclasses before you release it.Constructors must not invoke overridable methods. 父类的构造函数比子类的构造函数先执行，而如果父类构造函数中调用了可重写的方法，那么就会导致子类的重写方法比子类的构造函数先执行，会导致corruption。如果实现了Serializable/Cloneable接口，neither clone nor readObject may invoke an overridable method, directly or indirectly. 重写方法会在deserialized/fix the clone’s state之前执行。如果实现了Serializable接口，readResolve/writeReplace必须是protected，而非privatedesigning a class for inheritance places substantial limitations on the class.The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed. 声明为final class或者把构造函数私有化（提供public static工厂方法）。如果确实想要允许继承，就应该为每个被自己使用的可重写方法都写好文档Item 18: Prefer interfaces to abstract classesJava类只允许单继承，接口可以多继承，使用接口定义类型，使得class hierarchy更加灵活定义mixin（optional functionality to be “mixed in”）时使用interface是很方便的，需要增加此功能的类只需要implement该接口即可，而如果使用抽象类，则无法增加一个extends语句接口允许构建没有hierarchy的类型系统使用接口定义类型，可以使得item 16中提到的wrapper模式更加安全、强大，skeletal implementation：该类为abstract，把必须由client实现的方法设为abstract，可以有默认实现的则提供默认实现simulated multiple inheritance：通过实现定义的接口，同时在内部实现一个匿名的skeletal implementation，将对对该接口的调用转发到匿名类中，起到“多继承”的效果simple implementation：提供一个非抽象的接口实现类，提供一个最简单、能work的实现，也允许被继承使用接口定义类型的缺点：不便于演进，一旦接口发布，如果想要增加功能（增加方法），则client将无法编译；而使用abstract class，则没有此问题，只需要提供默认实现即可小结通过接口定义类型，可以允许多实现（多继承）但是演进需求大于灵活性、功能性时，抽象类更合适提供接口时，提供一个skeletal implementation，同时审慎考虑接口设计Item 19: 仅仅用interface去定义一个类型，该接口应该有实现类，使用者通过接口引用，去调用接口的方法避免用接口去定义常量，应该用noninstantiable utility class去定义常量相关常量的命名，通过公共前缀来实现分组Item 20: Prefer class hierarchies to tagged classestagged class: 在内部定义一个tag变量，由其控制功能的转换tag classes are verbose, error-prone, and inefficient而class hierarchy，不同功能由不同子类实现，公共部分抽象为一个基类，也能反映出各个子类之间的关系Item 21: Use function objects to represent strategies只提供一个功能函数的类实例，没有成员变量，只需一个对象（单例），为其功能定义一个接口，则可以实现策略模式，把具体策略传入相应函数中，使用策略具体的策略实例通常使用匿名类定义，调用使用该策略的方法时才予以创建/预先创建好之后每次将其传入Item 22: Favor static member classes over nonstatic有4种nested class：non-static member class; static member class(inner class); anonymous class; local classstatic member class经常作为helper class，和外部类一起使用如果nested class的生命周期独立于外部类存在，则必须定义为static member class，否则可能造成内存泄漏private static member class用处一：表示（封装）外部类的一些成员，例如Map的Entry内部类。non-static member class将持有外部类实例的强引用，可以直接引用外部类的成员和方法用处一：定义一个Adapter，使得外部内的实例，可以作为和外部类语义不同的实例来查看（访问），例如Collection的Iterator。如果nested class不需要引用外部类的成员和方法，则一定要将其定义为static，避免空间/时间开销，避免内存泄漏anonymous class当在非static代码块内定义时，会持有外部类的引用，否则不会持有限制只能在被声明的地方进行实例化无法进行instanceof测试不能用匿名类实现多个接口不能用匿名类继承一个类的同时实现接口匿名类中新添加的方法无法在匿名类外部访问不能有static成员应该尽量保持简短用处一：创建function object用处二：创建process object，例如：Runnable, Thread, TimberTask用处三：用于public static工厂方法，例如Collections类里面的一些工厂方法，很多是返回一个匿名的内部实现local class比较少用是否static取决于其定义的上下文可以在作用域内重复使用不能有static成员也应尽量保持简短小结四种nested class如果nested class在整个外部类内都需要可见，或者定义代码太长，应使用member class能static就一定要static，即便需要对外部类进行引用，对于生命周期独立于外部类的，也应该通过WeakReference进行引用，避免内存泄漏；至于生命周期和外部类一致的，则不必这样GenericsItem 23: Don’t use raw types in new codeJava泛型，例如List&lt;E&gt;，真正使用的时候都是List&lt;String&gt;等，把E替换为实际的类型Java泛型从1.5引入，为了保持兼容性，实现的是伪泛型，类型参数信息在编译完成之后都会被擦除，其在运行时的类型都是raw type，类型参数保存的都是Object类型，List&lt;E&gt;的raw type就是List编译器在编译期通过类型参数，为读操作自动进行了类型强制转换，同时在写操作时自动进行了类型检查如果使用raw type，那编译器就不会在写操作时进行类型检查了，写入错误的类型也不会报编译错误，那么在后续读操作进行强制类型转换时，将会导致转换失败，抛出异常一旦错误发生，应该让它尽早被知道（抛出/捕获），编译期显然优于运行期List与List&lt;Object&gt;的区别前者不具备类型安全性，后者具备，例如以下代码12345678910// Uses raw type (List) - fails at runtime!public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;String&gt;(); unsafeAdd(strings, new Integer(42)); String s = strings.get(0); // Compiler-generated cast&#125;private static void unsafeAdd(List list, Object o) &#123; list.add(o);&#125;不会报编译错误，但会给一个编译警告：Test.java:10: warning: unchecked call to add(E) in raw type List list.add(o);，而运行时则会发生错误。但如果使用List&lt;Object&gt;，即unsageAdd参数改为List&lt;Object&gt; list, Object o，则会报编译错误：Test.java:5: unsafeAdd(List&lt;Object&gt;,Object) cannot be applied to (List&lt;String&gt;,Integer) unsafeAdd(strings, new Integer(42));因为List&lt;String&gt;是List的子类，但却不是List&lt;Object&gt;的子类。并不是说这个场景应该使用List&lt;Object&gt;，这个场景应该使用List&lt;String&gt;，这里只是为了说明List和List&lt;Object&gt;是有区别的。List v.s. List&lt;?&gt;（unbounded wildcard types），当不确定类型参数，或者说类型参数不重要时，也不应该使用raw type，而应该使用List&lt;?&gt;任何参数化的List均是List&lt;?&gt;的子类，可以作为参数传入接受List&lt;?&gt;的函数，例如以下代码均是合法的：1234567void func(List&lt;?&gt; list) &#123; ...&#125;func(new List&lt;Object&gt;());func(new List&lt;Integer&gt;());func(new List&lt;String&gt;());持有List&lt;?&gt;的引用后，并不能向其中加入任何元素，读取出来的元素也是Object类型，而不会被自动强转为任何类型。如果List&lt;?&gt;的行为不能满足需求，可以考虑使用模板方法，或者List&lt;E extends XXX&gt;（bounded wildcard types）You must use raw types in class literals.List.class, String[].class, and int.class are all legal, but List&lt;String&gt;.class and List&lt;?&gt;.class are not.instanceof不支持泛型，以下用法是推荐的，但不应该将o强转为List12345// Legitimate use of raw type - instanceof operatorif (o instanceof Set) &#123; // Raw type Set&lt;?&gt; m = (Set&lt;?&gt;) o; // Wildcard type ...&#125;相关术语汇总Item 24: Eliminate unchecked warnings当出现类型不安全的强制转换时（一般都是涉及泛型，raw type），编译器会给出警告，首先要做的是尽量消除不安全的转换，消除警告实在无法消除/确定不会导致运行时的ClassCastException，可以通过@SuppressWarnings(&quot;unchecked&quot;)消除警告，但不要直接忽略该警告使用@SuppressWarnings(&quot;unchecked&quot;)时，应该在注视内证明确实不存在运行时的ClassCastException；同时应该尽量减小其作用的范围，通常是应该为一个赋值语句添加注解Item 25: Prefer lists to arraysarrays are covariant(协变): 如果Sub是Super的子类，那么Sub[]也是Super[]的子类generics are invariant(不变): 任意两个不同的类Type1和Type2，List&lt;Type1&gt;和List&lt;Type2&gt;之间没有任何继承关系考虑以下代码1234567// Fails at runtime!Object[] objectArray = new Long[1];objectArray[0] = "I don't fit in"; // Throws ArrayStoreException// Won't compile!List&lt;Object&gt; ol = new ArrayList&lt;Long&gt;(); // Incompatible typesol.add("I don't fit in");arrays are reified(具体化): array在运行时能知道且强制要求元素的类型generics are implemented by erasure(non-reifiable): 仅仅在编译时知道元素的类型数组和泛型同时使用时会受到很大限制以下语句均不能通过编译：new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]；但是声明是可以的，例如List&lt;String&gt;[] stringListsnon-reifiable type: 例如E, List&lt;E&gt;, List&lt;String&gt;，这些类型在运行时的信息比编译时的信息更少只有unbounded wildcard type才是reifiable的，如：List&lt;?&gt;, Map&lt;?, ?&gt;常规来说，不能返回泛型元素的数组，因为会报编译错误：generic array creation errors当泛型和varargs一起使用时，也会导致编译警告有时为了类型安全，不得不做些妥协，牺牲性能和简洁，使用List而不是数组把数组强转为non-reifiable类型是非常危险的，仅应在非常确定类型安全的情况下使用Item 26: Favor generic types当需要一个类成员的数据类型具备一般性时，应该用泛型，这也正是泛型的设计场景之一，不应该用Object类但使用泛型有时也不得不进行cast，例如当泛型遇上数组总的来说把suppress数组类型强转的unchecked warning比suppress一个标量类型强转的unchecked warning风险更大，但有时出于代码简洁性考虑，也不得不做出妥协有时看似与item 25矛盾，实属无奈，Java原生没有List，ArrayList不得不基于数组实现，HashMap也是基于数组实现的泛型比使用者进行cast更加安全，而且由于Java泛型的擦除实现，也可以和未做泛型的老代码无缝兼容Item 27: Favor generic methods泛型方法的类型参数在函数修饰符（可见性/static/final等）和返回值之间，例子：123456// Generic methodpublic static &lt;E&gt; Set&lt;E&gt; union(Set&lt;E&gt; s1, Set&lt;E&gt; s2) &#123; Set&lt;E&gt; result = new HashSet&lt;&gt;(s1); result.addAll(s2); return result;&#125;recursive type bound12// Using a recursive type bound to express mutual comparabilitypublic static &lt;T extends Comparable&lt;T&gt;&gt; T max(List&lt;T&gt; list) &#123;...&#125;泛型方法要比方法使用者进行cast更加安全Item 28: Use bounded wildcards to increase API flexibility考虑以下代码1234567891011121314151617public class Stack&lt;E&gt; &#123; public Stack(); public void push(E e); public E pop(); public boolean isEmpty(); public void pushAll(Iterable&lt;E&gt; src); public void popAll(Collection&lt;E&gt; dst);&#125;Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();Iterable&lt;Integer&gt; integers = ... ;numberStack.pushAll(integers);Stack&lt;Number&gt; numberStack = new Stack&lt;Number&gt;();Collection&lt;Object&gt; objects = ... ;numberStack.popAll(objects);pushAll和popAll的调用均无法通过编译，因为尽管Integer是Number的子类，但Iterable&lt;Integer&gt;不是Iterable&lt;Number&gt;的子类，这是由泛型的invariant特性导致的，所以Iterable&lt;Integer&gt;不能传入接受Iterable&lt;Number&gt;参数的函数，popAll的使用同理bounded wildcards: &lt;? extends E&gt;, &lt;? super E&gt;, PECS stands for producer-extends, consumer-super. 如果传入的参数是要输入给该类型数据的，则应该使用extends，如果是要容纳该类型数据的输出，则应该使用super这很好理解，作为输入是要赋值给E类型的，当然应该是E的子类（这里的extends包括E类型本身）；而容纳输出是要把E赋值给传入参数的，当然应该是E的父类（同样包括E本身）返回值类型不要使用bounded wildcards，否则使用者也需要使用，这将会给使用者造成麻烦代码对于bounded wildcards的使用在使用者那边应该是透明的，即他们不会感知到bounded wildcards的存在，如果他们也需要考虑bounded wildcards的问题，则说明对bounded wildcards的使用有问题了有时候编译器的类型推导在遇到bounded wildcards会无法完成，这时就需要显示指定类型信息，例如：123456public static &lt;E&gt; Set&lt;E&gt; union(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2);Set&lt;Integer&gt; integers = ... ;Set&lt;Double&gt; doubles = ... ;//Set&lt;Number&gt; numbers = union(integers, doubles); //compile errorSet&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles); //compile passComparables are always consumers, so you should always use Comparable&lt;? super T&gt; in preference to Comparable&lt;T&gt;. The same is true of comparators, so you should always use Comparator&lt;? super T&gt; in preference to Comparator&lt;T&gt;.unbounded type parameter(&lt;E&gt; ... List&lt;E&gt;) v.s. unbounded wildcard(List&lt;?&gt;)：if a type parameter appears only once in a method declaration, replace it with a wildcard.Item 29: Consider typesafe heterogeneous containers使用泛型时，类型参数是有限个的，例如List&lt;T&gt;，Map&lt;K, V&gt;，但有时可能需要一个容器，能放入任意类型的对象，但需要具备类型安全性，例如数据库的一行，它的每一列都可能是任意类型的数据由于Class类从1.5就被泛型化了，所以使得这种需求可以实现，例如：12345// Typesafe heterogeneous container pattern - APIpublic class Favorites &#123; public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance); public &lt;T&gt; T getFavorite(Class&lt;T&gt; type);&#125;通常这样使用的Class对象被称为type token，它传入函数，用来表述编译时和运行时的类型信息Favorites的实现也是很简单的：1234567891011121314// Typesafe heterogeneous container pattern - implementationpublic class Favorites &#123; private Map&lt;Class&lt;?&gt;, Object&gt; favorites = new HashMap&lt;Class&lt;?&gt;, Object&gt;(); public &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123; if (type == null) throw new NullPointerException("Type is null"); favorites.put(type, instance); &#125; public &lt;T&gt; T getFavorite(Class&lt;T&gt; type) &#123; return type.cast(favorites.get(type)); &#125;&#125;注意，这里的unbound wildcard并不是应用于Map的，而是应用于Class的类型参数，因此Map可以put key进去，而且key可以是任意类型参数的Class对象另外，Map的value类型是Object，一旦put到Map中去，其编译期类型信息就丢失了，将通过get方法的动态类型转换（cast）来重新获得其类型信息cast方法将检查类型信息，如果是该类型（或其子类），转换将成功，并返回引用，否则将抛出ClassCastException这一heterogeneous container实现有两个不足通过为put方法传入Class的raw type，使用者可以很轻易地破坏类型安全性，解决方案也很简单，在put时也进行一下cast：1234// Achieving runtime type safety with a dynamic castpublic &lt;T&gt; void putFavorite(Class&lt;T&gt; type, T instance) &#123; favorites.put(type, type.cast(instance));&#125;这样做的效果是使得想要破坏类型安全性的put使用者产生异常，而使用get的使用者则不会因为恶意put使用者产生异常。这种做法也被java.util.Collections包中的一些方法使用，例如命名为checkedSet, checkedList, checkedMap的类。这个容器内不能放入non-reifiable的类型，例如List&lt;String&gt;，因为List&lt;String&gt;.class是有语法错误的，List&lt;String&gt;, List&lt;Integer&gt;都只有同一个class对象：List.class；另外String[].class是合法的。Favorites使用的类型参数是unbounded的，可以put任意类型，也可以使用bounded type token，使用bounded时可能需要把Class&lt;?&gt;转换为Class&lt;? extends Annotation&gt;，直接用class.cast将会导致unchecked warning，可以通过class.asSubclass来进行转换，例子：12345678910// Use of asSubclass to safely cast to a bounded type tokenstatic Annotation getAnnotation(AnnotatedElement element, String annotationTypeName) &#123; Class&lt;?&gt; annotationType = null; // Unbounded type token try &#123; annotationType = Class.forName(annotationTypeName); &#125; catch (Exception ex) &#123; throw new IllegalArgumentException(ex); &#125; return element.getAnnotation(annotationType.asSubclass(Annotation.class));&#125;##Enums and AnnotationsItem 30: Use enums instead of int constants类型安全可以为常量提供数据和方法的绑定可以遍历实现建议如果是通用的，应该定义为top level enum，否则应定义为内部类constant-specific method implementations12345678// Enum type with constant-specific method implementationspublic enum Operation &#123; PLUS &#123; double apply(double x, double y)&#123;return x + y;&#125; &#125;, MINUS &#123; double apply(double x, double y)&#123;return x - y;&#125; &#125;, TIMES &#123; double apply(double x, double y)&#123;return x * y;&#125; &#125;, DIVIDE &#123; double apply(double x, double y)&#123;return x / y;&#125; &#125;; abstract double apply(double x, double y);&#125;结合constant-specific data123456789101112131415161718192021// Enum type with constant-specific class bodies and datapublic enum Operation &#123; PLUS("+") &#123; double apply(double x, double y) &#123; return x + y; &#125; &#125;, MINUS("-") &#123; double apply(double x, double y) &#123; return x - y; &#125; &#125;, TIMES("*") &#123; double apply(double x, double y) &#123; return x * y; &#125; &#125;, DIVIDE("/") &#123; double apply(double x, double y) &#123; return x / y; &#125; &#125;; private final String symbol; Operation(String symbol) &#123; this.symbol = symbol; &#125; @Override public String toString() &#123; return symbol; &#125; abstract double apply(double x, double y);&#125;If switch statements on enums are not a good choice for implementing con- stant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting external enum types with constant-specific behavior.A minor performance disadvantage of enums over int constants is that there is a space and time cost to load and initialize enum types.所以，在安卓设备（手机、平板）上，应该避免使用enum，减小空间和时间的开销Item 31: Use instance fields instead of ordinals每个enum的常量都有一个ordinal()方法获取其在该enum类型中的位置，但该方法只应该在实现EnumSet, EnumMap等类型的时候被使用，其他情形都不应该被使用如果需要为每一个常量绑定一个数据，可以使用instance field实现，如果需要绑定方法，则可以用constant-specific method implementations，参考上一个itemItem 32: Use EnumSet instead of bit fieldsbit fields的方式不优雅、容易出错、没有类型安全性EnumSet则没有这些缺点，而且对于大多数enum类型来说，其性能都和bit field相当通用建议：声明变量时，不要用实现类型，应该用接口类型，例如，应该用List&lt;Integer&gt;而不是ArrayList&lt;Integer&gt;EnumSet并非immutable的，可以通过Conllections.unmodifiableSet来封装为immutable，但是代码简洁性与性能都将受到影响]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDb索引]]></title>
    <url>%2Fposts%2Fc2f6f9e3%2F</url>
    <content type="text"><![CDATA[索引简介索引是用来加速查询的，类似于数的目录一样。我们要查找某些内容不需要查遍整个数据库，只需要先在索引中查找，找到相应索引之后根据索引找到指向的文档。创建索引使用ensureIndex函数，db.people.ensureIndex({&#39;username&#39;:1}),1代表对索引内容进行正向排序，-1代表对索引内容逆向排序。对某个键创建的索引会加速以该键为查询条件的查询，对其他查询没有帮助。索引创建既可以针对单个键创建也可以针对多个键创建，例如db.people.ensureIndex({&#39;name&#39;:1,age:-1,&#39;sex&#39;:1})其作用原理与sort相同(由前到后逐个匹配)。如果创建了我们上面所看到的索引实际上是有了{name:1},{name:1,age:-1},{name:1,age:-1,sex:1}三个索引，使用{age:-1}等索引的查询不会得到优化。创建索引并不是只有优点的，他的缺点就是每次插入，更新，删除都会产生额外的开销用来更新索引。所以我们要根据实际情况合理的创建索引，通常我们要考虑实际情况中都需要经常对哪些键查询，然后对该查询字段创建索引，每个集合的最大索引个数为64个注意索引顺序当我们创建多键索引时要分清主次，一般我们可以这样认为，当根据我们创建的多键索引进行查询时会先根据前面的条件筛选，将结果用于下一次筛选。所以创建多键索引时我们要将主要索引条件放在前面，建立索引时要考虑如下问题：会做什么样的查询，其中哪些键需要索引每个键的索引方向是怎样的如何应对拓展，有没有种不同的键的排列可以是常用数据更多地保存在内存中索引内嵌文档为内嵌文档建立索引和为普通的键创建索引没有什么区别，只是在索引内嵌文档的字段的时候使用点表达式，也可以和普通键索引组成复合索引为排序创建索引随着集合的增长，需要针对大量的排序做索引。因为如果排序实在内存中完成的，如果数据量特别大超出内存的限制就是报错。如果没有对数据进行sort，默认就是查询出来的顺序，所以创建索引之后查询出来的顺序就是排序之后的结果索引名称每一个索引都有一个字符串类型的名字用来唯一标示，数据库通过这个名字来删除或操作索引。默认情况索引名类似keyname1_dir1_keyname2_dir2…形式（keynameX代表索引的键，dirX代表索引的方向）。我们可以通过ensureIndex的第二个参数来指定索引的名字1db.people.ensureIndex(&#123;'name':1,'age':-1&#125;,&#123;'name':'index1'&#125;)唯一索引唯一所以可以确保集合的每一个文档的指定键都有唯一的值，相当于关系型数据库中的unique键。要创建唯一索引需要在ensureIndex的第二个参数中指定unique为true。在创建集合是自动给我们创建了_id唯一索引，与普通唯一索引的区别是不能被删除1db.people.ensureIndex(&#123;'username':1&#125;,&#123;'unique':true&#125;)可能当我们创建唯一索引的时候，有些值已经有重复了，这时候索引的创建就会失败。但是我们可以使用dropDups选项，这样可以保留发现的第一个文档，将其他重复文档删除1db.people.ensureIndex(&#123;'username':1&#125;,&#123;'unique':true, 'dropDups':true&#125;)创建符合唯一索引的时候，单个键的值可以相同，只要所有键的值组合起来不同就好强制使用索引如果发现MongoDb没有使用预期的索引，可以用hint强制使用某个索引。例如希望使用{&#39;username&#39;:1,&#39;age&#39;:1}索引1db.people.find(&#123;'age':14,'username':'nicolas'&#125;).hint(&#123;'username':1,'age':1&#125;)多数情况下并没有这么做的必要，MongoDb会非常智能的选择使用哪个索引。在初次查询时会尝试各种查询方案，最优方案会被记录下来，还会定期重试其他方案，防止建立新的索引之后方案不再是最优索引管理索引的原信息存储在每个数据库的system.indexes集合中，不能对该集合插入或删除文档，操作只能通过ensureIndex和dropIndex进行建立索引既耗时有费力，还需要消耗很多资源，可以使用{&#39;background&#39;:true}选项是这个过程在后台完成，同时正常处理请求。一般来说为已有文档创建索引比先创建索引再插入所有文档要稍快一些。不管怎么说在无关紧要的时刻创建索引是最好的选择当索引没用的时候可以通过dropIndex选项删除索引,删除依据是创建索引的条件1db.people.dropIndex(&#123;'username':1,'age':-1&#125;)地理空间索引MongoDb为坐标平面提供了专门的索引成为地理空间索引，可以找出离某一坐标平面最近的点。创建地理空间索引同样适用ensureIndex选项，只不过参数不是1或-1而是2d。建立索引的键的值必须是包含两个元素的数组或包含两个键的内嵌文档(键名可以随意)。地理空间索引默认的范围是180·-180，如果想要指定大小可以使用第二个参数1db.start.insureIndex(&#123;'light-year':'2d'&#125;,&#123;'min':-1000,'max':1000&#125;)地理空间索引的查询和普通的find查询差别不大，只不过使用了$near，需要两个目标值的数组作为参数，默认返回100个距离给点坐标最近的文档，可以使用limit进行限制。还可以使用$maxDistance限定查询的最大距离1db.map.find(&#123;'gps':&#123;$near:[40,-73], $maxDistance:40&#125;&#125;).limit(10)MongoDb不仅可以根据距离查询，还可以根据形状查询，目前支持矩形,圆形查询和多边形查询，需要用到$within123456//要给出矩形左上角和右下角坐标db.map.find(&#123;'gps':&#123;$within:&#123;$box:&#123;[10,30],[15,40]&#125;&#125;&#125;&#125;)//需要圆的原点坐标和半径db.map.find(&#123;'gps':&#123;$within:&#123;$circle:&#123;[10,20],40&#125;&#125;&#125;&#125;)//多边形各个点的坐标db.map.find(&#123;'gps':&#123;$within:&#123;$polygon:[[1,2],[1,4],[6,3]]&#125;&#125;&#125;)我们可以组合地理空间索引和普通索引，这样可以满足继续要地里空间限制条件组合普通限制条件的查找1db.ensureIndex(&#123;'location':'2d','desc':1&#125;)]]></content>
      <categories>
        <category>MongoDb</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDb查询]]></title>
    <url>%2Fposts%2Ff3e67b24%2F</url>
    <content type="text"><![CDATA[简介使用find或者findOne对数据库执行查询使用$条件实现范围，集合包含，不等式和其他查询使用$where子句用户复杂查询查询会返回一个数据库游标，只有在需要数据的时候才会惰性的返回文档针对游标执行的元操作，比如忽略一定数量的结果，限定返回结果的数量，对结果进行排序find简介db.users.find()db.users.find({‘name’:’nicolas’,’age’:20})不带参数的find会返回全部文档。find可以指定查询文档，只返回匹配查询条件的文档，当查询文档含有多个K-V时连接条件为AND,第二个查询语句会返回name为nicolas并且age为20的文档指定返回的键db.users.find({},{‘name’:1,’age’:0})有时我们并不需要将文档中的所有K-V都返回，这种情况我们可以使用find函数的第二个参数指定要返回的键。其中1代表将返回的文档按照该字段正向排序，0代表将返回的文档按照该字段逆向排序限制db.stock.find({‘in_stock’:’this.num_sold’})查询文档必须是常量（在自己代码里可以使正常的变量），但是不能引用文档中其他键的值。故上面的这个查询是错误的查询条件比较操作符$gt,$gte,$gt,gte是全部的比较操作符，分别对应&lt;,&lt;=,&gt;,&gt;=，可以将其组合起来查找一个范围的值。其中对于日期查询尤为有用，因为对日期的精确匹配终究是徒劳的。db.users.find({‘age’:{$lt:30,$gt:20}) 查找年龄大于20小于30的人start = new Date(“01/01/2007”)db.users.find(‘registered’:{$lt:start}) 查找注册日期在2007年1月1日之前的用户OR查询$in可以用来查询键值在给定数组中的文档，与之相反的是$nin。这两者用来对单个键做OR查询db.users.find({‘name’:{$in:[‘nicolas’,’windylee’]}) 返回name为nicolas或windylee的文档$or可以对多个键做OR查询，$or接受一个包含所有可能条件的数组作为参数，只要符合数组中任何一个元素的条件就会被查询出来，$or可以包含其他条件。普通的and兴的查询，总是尽可能的用最少的条件来限定结果的范围，or型的查询真好相反，第一个条件尽可能地匹配更多的文档db.users.find({$or:[{‘name’:{$in:[‘nicolas’,’windylee’]}},’age’:20]}) 查询name为nicolas或windylee或age为20的用户$not查询$not是元条件句，可以用在任何其他条件之上，表示对其他条件的结果取反。经常与正则表达式联合使用，用来查询不匹配正则表达式的文档db.users.find({‘age’:{$not:{$mod:[5,1]}}) 查询age值模5余数不为1的文档条件句的规则条件句是内层文档的键，修改器是外层文档的键，可对一个键应用多个条件，但是一个键不能对应多个更新修改器。例如{$inc:{&#39;age&#39;:20},$set:{&#39;age&#39;:40}}修改了age两次特定于类型的查询空值查询nullnull不仅能够匹配到键值为null的文档，他还能匹配缺少这个键的所有文档$exists如果仅仅想匹配键值为null的文档，就需要使用到该关键字db.users.find({‘name’:{$exists:true}}) 返回name值不为空的文档查询数组$ll返回含有$all指向数组所有元素的文档db.users.find(‘course’:{$all:[‘english’,’chinese’]}) 返回课程含有english和chinese的用户$size返回数组长度为指定大小的文档，$size不能与其他查询子句组合(比如$gt)db.users.find({‘course’:{$size:3}}) 返回选了3门课的文档$slice返回一个数组的子集合。可以接受一个整型n，整数表示返回数组的前n条数据，负数表示返回数组的后n条数据；可以接受一个数组，数组的第一个元素表示偏移量，第二个元素表示获取的元素数量。除非特别声明，$slice返回文档中的所有键db.blog.posts.findOne(criteria,{‘comments’:{$slice,[1,2]}}) 默认会返回posts中的所有字段查询内嵌文档如果存在如下文档1234567&#123; 'name':&#123; 'first':'Jone' 'last':'Schmoe' &#125; 'age':45&#125;要查询姓名为Jon Schmoe的人可以这样db.people.find({&#39;name&#39;:{&#39;first&#39;:&#39;Jon&#39;,&#39;last&#39;:&#39;Schmoe&#39;}})这种方式采用全部匹配的规则，即查询条件中要包含内嵌文档的所有键，如果name内嵌文档中增加middle字段则上述查询条件就不起作用了。如果只想根据部分字段进行查询则需要点表达式db.people.find({&#39;name.first&#39;:&#39;Joe&#39;,&#39;name.last&#39;:&#39;Schmoe&#39;})，这也是带插入的文档不能包含’.’的原因当文档变负责以后，即内嵌文档为数组时，如果有如下文档123456789101112131415&#123; 'content':'...' 'comments':[ &#123; 'author':'joe', 'score':3, 'comment':'nice post' &#125;, &#123; 'author':'mary', 'score':6, 'comment':'terrible post' &#125; ]&#125;如果继续使用点表达式db.blog.find({&#39;comments.author&#39;:&#39;jone&#39;,&#39;score&#39;:6})则第一个条件会在comments1中找到，第二个条件会在comments2中找到，所以会返回我们上面看到的文档。若要正确指定一组条件我们需要$elemMatch，这种模糊的命名条件句能用来部分指定匹配数组中的单个嵌入文档的限定条件，所以正确的写法应该是这样的db.blog.find({&#39;comments&#39;:{$eleMatch:{&#39;author:&#39;Jone&#39;,&#39;score&#39;:&#39;6}}})$where查询我们上面说过find的查询条件只能是常量，不能是文档中的值，如果我们查询条件为文档中的数据，那这时候我们就需要$where子句了，例如db.foo.find({$where:&#39;this.x+this.y=10&#39;})。$where速度要慢很多，除非必要不要使用该条件。游标数据库使用游标来返回find的执行结果，客户端队游标的实现通常能够对最终结果进行有效的控制，可以限制结果的数量，略过部分结果，根据任意方向任意键的组合对结果进行各种排序，或者执行其他一些功能强大的操作。当调用find的时候并不立即查询数据库，而是等待真正开始要求获得结果的时候才发送查询，这样我们就可以在执行之前给查询附加额外的选项limit, skip, sortlimit限定返回结果的上限，skip跳过前n个匹配的文档；sort指定排序的键和排序条件，1为正序排序，-1为降序排序，如果指定了多个键，则按照多个键的顺序逐个排序，例如要按照username升序和age降序排序db.c.find().sort({&#39;username&#39;:1,&#39;age&#39;:-1})。find函数返回游标，这三个函数都可以组成链式操作。如果一个键对应不同的类型，则规定的类型顺序：最小值 &lt; null &lt; 数字（整形，长整形，双精度）&lt; 字符串 &lt; 对象/文旦 &lt; 数组 &lt; 二进制数据 &lt; 对象ID &lt; 布尔型 &lt; 日期型 &lt; 时间戳 &lt; 正则表达式 &lt; 最大值避免使用skip略过大量结果使用skip略过大量结果就会使操作变得非常缓慢，几乎所有的数据库都有这个问题，所以我们应尽量避免使用skip不用skip对结果分页分页最简单的方式就是结合使用limit和skip两个函数，但我们可以有更好的解决方案。例如我们最获取文档时一般按照时间顺序进行排序，我们可以获取第一次获取的文档最后一个的时间，然后可以利用该时间值最为查询条件来获取下一页123456var latest=nullwhile(page1.hasNext())&#123; latest=page1.next(); display(latest)&#125;var page2=db.foo.find(&#123;'date':&#123;$gt:latest.date&#125;).sort('date':-1).limit(10)随机选取文档一般做法是要查询文档总数，然后在0~n中选择一个随机数，使用skip跳过这些随机数来获取随机的一个文档。这样查询总数和使用skip略过文档都需要花费大量时间。我们可以再一开始就在文档中插入一个随机数的键，然后根据该随机数获取随机文档12db.people.insert(&#123;'name':'nicolas','random':Math.random()&#125;)db.people.findOne(&#123;random:&#123;$lt:Math.random()&#125;&#125;)]]></content>
      <categories>
        <category>MongoDb</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDb创建，删除，更改]]></title>
    <url>%2Fposts%2F9aa16efd%2F</url>
    <content type="text"><![CDATA[插入并保存文档db.foo.insert({‘bar’:baz”})会自动给文档增加一个”_id”键(如果原来没有的话)。驱动程序会将数据转换成BSON形式，数据库解析BSON，检验是否包含’_id’键，并且文档长度不能超过4MB删除文档db.users.remove()会删除users集合中的所有文档，但是不会删除集合本身，原来的索引也会保留。remove函数可以接受一个查询文档作为可选参数，只有符合条件的文档才会被删除，例如 &gt;db.mailing.list.remove({‘opt-out’:true})删除集合db.users.drop()会删除users集合，所有的索引也会被删除，速度要比remove()快很多更新文档文档存入数据库以后，可以使用update方法来修改他，update有两个参数，一个是查询文档，用来找出要更新的文档，另一个是修改器文档，描述对找到的文档做哪些更改文档替换db.users.update({‘name’:’nicolas’},{‘age’:20})完全用一个文档去替换另一个文档，不使用任何关键字，默认文档会变成和第二个参数文档完全一样的形式，例子中更新之后文档中就只有age字段使用修改器对字段值修改不需要改变文档的大小，修改速度非常快。对数组修改可能需要改变文档的大小，修改速度回慢一下$incdb.users.update({‘name’:’nicolas’},{$age:{‘age’,1}})更新之后age字段会增加1，当为负数时自减。当键不存在时创建一个键。只能用于整数，长整数和说京都浮点数$setdb.user.update({‘name’:’nicolas’},{$set:{‘age’:20}})$set用来指定一个键的值，如果这个键不存在就创建他。$set甚至可以修改键的数据类型。$set可以修改内嵌文档，只要将内嵌字段用”.”连接即可，类似于引用对象变量`$unset·db.users.update({‘name’:’nicolas’},{$unset:{‘age’:1}})会将age的键删除$push如果指定的键已经存在，会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组$nedb.users.update({‘course’:{$ne:’english’}},{$push:{‘course’:’english’}})当course字段中不存在english值时，会向course字段数组中放入english$addToSetdb.users.update({‘name’:’nicolas’},{$addToSet:{‘courses’:’english’}})当name为nicolas中的course字段数组中不包括english是向其中添加english$eachdb.users.update({‘name’:’nicolas’},{$addToSet:{‘course’:{$each:[‘english’,’chinese’,’math’]}}})如果不存在这像个课程就像course字段中一次添加这些课程$popdb.users.update({‘name’:’nicolas’},{$pop:{‘course’:1}})可以冲数组的任何一段删除元素，1从数组末尾删除一个元素，-1从数组头部删除$pulldb.users.update({‘name’:’nicolas’},{$pull:{‘course’:’english’}})根据特定条件删除元素，例子中删除course数组中值为english的元素$db.blog.update({‘post’:1},{$inc,{‘comments.0.votes’:1}})使comments数组下标为0的元素中votes字段的值自增1db.blog.update({‘comments.author’:’nicolas’},{$inc,{‘comments.$.votes’:1}})首先会查找comments数组中author为nicolas的元素，记录下其下标。并改变该下标中元素的votes值为1upsertdb.person.update({‘name’:’windylee’},{$set:{‘age’:21,’sex’:’man’}},true)upsert是一种特殊的更新，要是没有文档符合更新调价，就会以这个条件和更新文档为基础创建一个新的文档，如果匹配则正常更新。将update的第三个参数设置为true即可开启此功能。例子中将会插入name，age，sex三个字段更新多个文档默认情况下，更新只能对符合匹配条件的第一个文档执行操作，要使所有匹配到的文档都得到更新，可以设置update的第四个参数为true]]></content>
      <categories>
        <category>MongoDb</category>
      </categories>
      <tags>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown新手指南]]></title>
    <url>%2Fposts%2Fbc135409%2F</url>
    <content type="text"><![CDATA[Markdown简介Markdown是什么Markdown是一种极简的标记语言，可以轻易的将文本转化为HTML。语法非常容易学习，简单到每个人都可以在5分钟之内学会。Markdown之所以越来越流行，不是因为它复杂，而是因为他足够简单。Markdown优点纯文本编写，兼容性很强，可以使用所有文本编辑器打开让写作者专注与文字而不是排版格式转换方便，可以将MarkDown文本轻易转换为HTML，电子书等与word对比使用word写文档需要浪费大量时间在word本身上，特别是那80%我们用不到的功能浪费时间在排版上，需要花费大量时间用在调整粗体或者斜体，黑体还是宋体上Markdown语法标题标题有两种方式：Setext方式和Atx方式12345Setext方式，三个或更多的=或者-大标题===小标题---大标题小标题1234567Atx方式，在标题前面加上#号，总共分为6个等级，#号越多，标题字号越小# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题一级标题二级标题三级标题四级标题五级标题六级标题列表无序列表，只需要在文字前面加上-,+或者×123- 文本1- 文本2- 文本3文本1文本2文本3有序列表，只需要在文字前面加上1.， 2.， 3.等。前面序号只是代表语法标记，真正序号与我们所写的内容并无实际关系，例如：我将文本3的序号标记为4，但效果仍然显示为3。1231. 文本12. 文本24. 文本3文本1文本2文本3嵌套列表，-，+，*可循环使用，但符号之后的空格不能少，符号之前的空格也不能少1234567- 一级列表 + 二级列表 + 二级列表 × 三级列表 - 四级列表- 一级列表```language一级列表二级列表二级列表三级列表四级列表一级列表链接和图片链接，插入链接只需要使用[显示文本](连接地址 Tooltips)这样的语法实现，Tooltips可以省略，Tooltips表示鼠标悬浮时候的文本提示1[百度](http://www.baidu.com)百度图片，插入图片只需要使用![](图片链接 Tooptips)这样的语法实现，Tooltips可以省略1![](http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg "埃菲尔铁塔")自动链接，直接显示链接网址，点击可以跳转1&lt;http://www.sina.com&gt;http://www.sina.com引用在我们写作的时候经常需要引用他人的文字，这时候就需要用到引用这个格式。这时候我们就需要在文字前面加上&gt;来表示引用内容。可以嵌套使用表示多级引用1&gt; 以眼看世界，即使站的最高，世界还是很小；以心看世界，即使身处局限，世界依然很大以眼看世界，即使站的最高，世界还是很小；以心看世界，即使身处局限，世界依然很大强调被**包含的表示斜体，被****包含的表示粗体，其中的*也可以换成_12345**一个人来到田纳西**__毫无疑问__*我做的馅饼是全天下*_最好吃的_一个人来到田纳西毫无疑问我做的馅饼是全天下最好吃的分隔符***表示page break；---表示section break；___表示sentence break；123456789page break***section break---sentence break___page breaksection breaksentence break代码使用`&#123;codeblock&#125;``` `表示代码块，language表示代码块中代码的语言类型，在&#123;codeblock&#125;中插入要写的代码123456```java ```java public static void main(String[] args)&#123; &#125; ``` `123public static void main(String[] args)&#123;&#125;特殊表示123~~删除元素~~++下划线++==高亮显示==删除元素++下划线++==高亮显示==]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
