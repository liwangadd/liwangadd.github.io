<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Nginx入门教程</title>
      <link href="/2018/02/20/2018-02-20Nginx%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Nginx是一个开源、高性能的HTTP服务器和反向代理服务器，还可以用来作为IMAP/POP3的代理服务器，其处理静态文件、索引文件的效率非常高。相比于apache的多进程多线程的并发模型，Nginx是基于事件的异步IO的并发模型，支持epoll/kqueue等网络IO模型。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装Nginx主要有两种方式，通过仓库中的二级制包安装和源码安装。在Ubuntu系统中可以通过<code>sudo apt-get install nginx</code>从官方仓库中安装，这种安装方式可以满足用户的基本需求。但如果对Nginx的精简度和性能有非常高的要求，就需要通过源码的方式安装，分为以下三步：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><p>如果要对Nginx进行定制，就需要在第一步制定需求，主要参数如下：</p><ul><li>–conf-path 指定配置文件的位置，默认为/etc/nginx/nginx.conf</li><li>–error-log-path 指定错误日志文件所在位置，默认为/var/log/nginx/error.log,安装完成后可在配置文件中进行配置</li><li>–http-log-path 指定http连接日志文件所在位置，默认为/var/log/nginx/access.log</li><li>–with-模块名称 该模块会被编译</li><li>–without-模块名称 编译时将该模块排除在外</li></ul><a id="more"></a><p>源码安装完成之后，默认Nginx服务已经启动。若想手动启动Nginx服务可以通过<code>sudo service nginx start</code>,同理关闭或者重启可以通过<code>sudo service nginx stop/restart</code>。 虽然Nginx重启速度很快，但是每次修改配置文件后，仅仅想让配置文件生效可以通过<code>sudo nginx -s reload</code> 命令，而不用重启服务</p><h4 id="配置文件详解"><a href="#配置文件详解" class="headerlink" title="配置文件详解"></a>配置文件详解</h4><p>Nginx是模块化的系统，整个系统被分成一个个的模块，每个模块负责不同的功能。例如http_gzip_static_module是负责压缩的，http_ssl_module是负责加密的。如果想使用某个模块需要在编译时将其加入其中，使用被编译的模块需要通过指令，整个配置文件就是通过指令组成的。默认的配置文件位于<code>/etc/nginx/nginx.conf</code>，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes 1;</span><br><span class="line">pid /run/nginx.pid;</span><br><span class="line"></span><br><span class="line">events &#123;</span><br><span class="line">  worker_connections 768;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http &#123;</span><br><span class="line"></span><br><span class="line">  sendfile on;</span><br><span class="line">  tcp_nopush on;</span><br><span class="line">  tcp_nodelay on;</span><br><span class="line">  keepalive_timeout 65;</span><br><span class="line">  types_hash_max_size 2048;</span><br><span class="line"></span><br><span class="line">  include /etc/nginx/mime.types;</span><br><span class="line">  default_type application/octet-stream;</span><br><span class="line"></span><br><span class="line">  access_log /var/log/nginx/access.log;</span><br><span class="line">  error_log /var/log/nginx/error.log;</span><br><span class="line"></span><br><span class="line">  gzip on;</span><br><span class="line">  gzip_disable "msie6";</span><br><span class="line"></span><br><span class="line">  include /etc/nginx/conf.d/*.conf;</span><br><span class="line">  include /etc/nginx/sites-enabled/*;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，配置文件主要由两个block组成。Nginx是存在三个顶级block的，分别是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">&#125;</span><br><span class="line">mail&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从配置文件中可以看出：events模块中包含nginx中所有处理连接的设置，可以通过worker_connections指定每个工作进程可以同时接受的最大连接数；http模块主要是用来配置web服务，可以用于指定是否启用压缩，是否支持发送文件等；mail模块用来配置IMAP/POP3代理。我们主要关注http模块，如果Nginx的配置文件过大，将全部配置写在同一文件中将难以维护，此时可以将不同用途的配置写在不同的配置文件中，通过include指令加载进来。</p><p>如果想要部署一个网站，就需要在http模块中添加一个server块。下面看一个例子。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen80;</span><br><span class="line">  server_name example.org www.example.org;</span><br><span class="line">  root/usr/nginx/www;</span><br><span class="line">  </span><br><span class="line">  location / &#123;</span><br><span class="line">        indexindex.html index.php;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  location ^~ /images/ &#123;</span><br><span class="line">        index icon.html;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  location ~* \.(gif|jpg|png)$ &#123;</span><br><span class="line">        expires 30d;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  error_page 500 502 503 /50x.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在电脑中的hosts文件中，加入一行<code>127.0.0.1 www.example.org</code>，在浏览器中输入<a href="http://www.example.org就可以访问了。该配置中通过listen表明监听80端口，通过server_name指定网站的域名，通过root指定网站的根目录，最下面的error_page说明当服务器发生500、502、503错误时，将网站根目录下的50x.html返回给用户。" target="_blank" rel="noopener">www.example.org就可以访问了。该配置中通过listen表明监听80端口，通过server_name指定网站的域名，通过root指定网站的根目录，最下面的error_page说明当服务器发生500、502、503错误时，将网站根目录下的50x.html返回给用户。</a></p><p>下面我们主要关注location指令，location用于URL模式设置，可以看到在匹配的URL开头有一些特殊符号，不同的符号用于限定在匹配时采用的特殊规则：</p><ul><li>=开头表示精确匹配，与指定字符串有任何区别将不能匹配成功</li><li>^~开头表示匹配以指定字符串开头的URL，不适用正则</li><li>~开头表示区分大小写的正则匹配</li><li>~*开头表示不区分大小写的正则匹配</li><li>/通用匹配，如果所有匹配都失败，则返回该默认匹配</li></ul><p>各种匹配的优先级为：(=) &gt; (完整路径) &gt; (^~) &gt; (~, ~*) &gt; (location 部分起始路径) &gt; (/)。</p><p>在上面的配置文件中的<code>$</code>符号是正则表达式中的结束标志。在最后一个location中有expires指令，该指令的作用是让Nginx缓存请求返回的信息(这里是图片静态文件)，缓存的有效期的30天。</p><h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>代理可以分问正向代理和反向代理。正向代理的步骤是：用户要访问服务器C，而用户的请求会先到达代理服务器B，然后B再将用户请求转发到服务器C，此时代理服务器B才是真正访问服务器C的，代理服务器B再将得到的结果转发给用户。在这个过程中用户就像直接访问服务器C一样，过程中不知道代理服务器的存在。而反响代理的步骤是：用户只知道代理服务器的地址，通过该地址直接访问代理服务器B，代理服务器B将请求转发给真正的服务提供者C，得到结果后再返回给用户。用户根本不知道服务提供者的地址或者完全不能访问到，整个过程用户是直接与代理服务器B交互的。反向代理可以用来隐藏和保护原始服务器，实现负载均衡，加密和SSL加速等。</p><p>Nginx的反向代理是通过ngx_http_proxy_module这个模块实现的，nginx可以代理的协议有http(s)、fastcgi、uswgi、memcached等。下面是实现的一个简单代理服务器的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">http&#123;</span><br><span class="line">  ....</span><br><span class="line">  upstream java_demo&#123;</span><br><span class="line">      # 实际服务器的地址</span><br><span class="line">      server 127.0.0.1:8080;</span><br><span class="line">  &#125;</span><br><span class="line">  server &#123;</span><br><span class="line">    server_name www.example.com;</span><br><span class="line">    listen       443;</span><br><span class="line">    proxy_connect_timeout 180; # nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">    proxy_send_timeout 180; </span><br><span class="line">    proxy_read_timeout 180; # 连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">    proxy_set_header Host $host;</span><br><span class="line">    proxy_set_header X-Forwarder-For $remote_addr;</span><br><span class="line">    </span><br><span class="line">    location / &#123;</span><br><span class="line">      # 将请求转发到实际服务提供者</span><br><span class="line">      proxy_pass http://java_demo;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="gzip压缩"><a href="#gzip压缩" class="headerlink" title="gzip压缩"></a>gzip压缩</h4><p>当css文件和js文件过大时，可以通过压缩的机制提高网站的加载速度。Nginx通过ngx_http_gzip_module模块实现对文件的压缩操作，启用压缩要在配置文件中指定。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">....</span><br><span class="line">http &#123;</span><br><span class="line">        gzip on;</span><br><span class="line">        gzip_disable "msie6";</span><br><span class="line">        # gzip_vary on;</span><br><span class="line">        # gzip_proxied any;</span><br><span class="line">        # gzip_comp_level 6;</span><br><span class="line">        # gzip_buffers 16 8k;</span><br><span class="line">        # gzip_http_version 1.1;</span><br><span class="line">        gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;</span><br><span class="line">        server &#123;</span><br><span class="line">                location ~ ^/assets/ &#123;</span><br><span class="line">                   gzip_static on;</span><br><span class="line">                   expires max;</span><br><span class="line">                   add_header Cache-Control public;</span><br><span class="line">                &#125;        </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用gzip指令来启用gzip压缩功能，使用gzip_types限制了要压缩的文件类型。这两个属性时必须配置的，其他属性根据需要进行配置。同时需要在要启用压缩的location块中加入配置文件中的那三行。</p><h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h4><p>听说过nginx的人肯定都知道其在负载均衡中的重要角色，几乎成熟的网站都会使用nginx作为负载均衡服务器。同时nginx也在不断发展，在1.9版本之前其只能作为http的负载均衡，而在1.9之后其也实现了对tcp进行负载均衡。nginx负载均衡模块实现了如下4种调度方式：</p><ol><li><p>round-robin：Nginx默认的轮询算法，每个请求按时间顺序逐一分配到不同的后端服务器。可以通过weight指定轮询权值，权值越大表明被访问到的可能性越大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  server 127.0.0.1:8080 weight=2;</span><br><span class="line">  server 127.0.0.1:8081 weight=1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>least_conn：请求会被发送到活跃连接数最少的服务器上。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  least_conn;</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>ip_hash：根据访问用户ip的hash结果分配请求，相同的ip总是会被分配到同一台应用服务器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  ip_hash;</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p></li><li><p>hash：相比于ip_hash方式，这是一个粒度更小的控制，ip_hash默认是用户ip的hash值。而该方式根据指定字段的hash值进行分配。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream java_demo &#123;</span><br><span class="line">  hash $request_uri; # 根据请求地址分配</span><br><span class="line">  server 127.0.0.1:8080;</span><br><span class="line">  server 127.0.0.1:8081;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>nginx对负载均衡提供了很好的支持，相对于反向代理，我们只需在upstream块中添加多个server地址和指定负载均衡算法，nginx就可以根据我们指定的负载均衡算法分发用户请求。</p><p>在配置负载均衡时，upstream块中的server可以有如下配置参数</p><ul><li>down。加入该字段的server将暂时不参与负载均衡，对该服务器的请求会自动发送到下一个服务器。</li><li>backup。预留的备份服务器，当其他所有的非backup都出现故障或者忙的时候，才会将请求发送到该服务器。</li><li>weight。指定该服务器被访问到的概率，值越大被访问到的概率越高，默认weight的权值为1。</li><li>max_fails。表示请求失败的次数，若某一服务器对同一请求失败超过max_fails次，则将该请求发送到下一服务器。</li><li>max_timeout。表示请求失败的超时时间，在设定的时间内没有成功，就作为失败处理。</li></ul></li></ol>]]></content>
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring定时任务</title>
      <link href="/2018/02/20/2018-02-20Spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"/>
      <content type="html"><![CDATA[<p>关于spring的定时任务，我们在spring3.0之前一般会使用Quartz，这是一个功能相当强大的调度器，可以让你的程序在指定时间执行，也可以按照某个频度执行，但是配置起来稍显复杂。Spring3.0以后自带task，可以将它看成一个轻量级的Quartz，使用起来比Quartz简单许多，不需要额外的包，而且支持注解和配置文件两种形式。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h5><p>首先需要在配置文件中引入task命名空间<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span></span></span><br><span class="line"><span class="tag">    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span>/<span class="attr">spring-task.xsd</span>"&gt;</span></span><br></pre></td></tr></table></figure></p><p>然后配置需要定时执行的任务<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Spring定时器注解开关，注册之后可以再java类中使用task命名空间的注解--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"myScheduler"</span>/&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--内部使用的线程池，配置线程池，指定线程池的大小--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"myScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"10&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">   &lt;!--配置定时任务，指定需要定时执行的类和方法，并配置调度方式--&gt;</span></span></span><br><span class="line"><span class="tag"><span class="string">   &lt;task:scheduled-task scheduler="</span><span class="attr">myScheduler</span>"&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"scheduledTaskManager"</span> <span class="attr">method</span>=<span class="string">"autoCardCalculate"</span> <span class="attr">cron</span>=<span class="string">"0 5 * * * *"</span>/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">task:scheduled-task</span>&gt;</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h5 id="注解形式"><a href="#注解形式" class="headerlink" title="注解形式"></a>注解形式</h5><p>首先我们看一下源码中注解的定义<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.ANNOTATION_TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Repeatable</span>(Schedules.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Scheduled &#123;</span><br><span class="line">    <span class="function">String <span class="title">cron</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">zone</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fixedDelay</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">fixedDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">fixedRate</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">fixedRateString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">initialDelay</span><span class="params">()</span> <span class="keyword">default</span> -1L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">initialDelayString</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以看到该注解有八个参数，分别表示的意思是：<br>cron：指定cron表达式<br>zone：指定时区<br>fixedRate：从上一个任务开始到下一个任务开始的间隔，单位是毫秒<br>fixedDelay：从上一个任务完成到下一个任务开始的间隔，单位是毫秒<br>initialDelay：任务第一次执行前需要延迟的毫秒数<br>这些配置参数都可以在xml配置文件中使用，效果是一样的</p><h5 id="执行任务的POJO类"><a href="#执行任务的POJO类" class="headerlink" title="执行任务的POJO类"></a>执行任务的POJO类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledTaskManager</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 每日凌晨2点执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(cron = <span class="string">"0 0 2 * * *"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autoCardCalculate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 心跳更新，启动时执行一次，之后每隔一分钟执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span> * <span class="number">60</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">heartbeat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 启动后一秒钟之后执行一次，之后每次执行完间隔2分钟执行一次</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Scheduled</span>(fixedDelay = <span class="number">1000</span> * <span class="number">60</span> * <span class="number">2</span>, initialDelay = <span class="number">1000</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">persistRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world"</span> + <span class="keyword">new</span> Date());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="组合多个Scheduled"><a href="#组合多个Scheduled" class="headerlink" title="组合多个Scheduled"></a>组合多个Scheduled</h5><p>@Scheduled可以让我们很方便的配置定时任务，但是有的定时任务不是一个表达式就能表达完全的，比如说我既想在周三10:10又想在周四17:40执行某项任务。这时候我们很难用一个表示式，或者根本行不通，这时候我们就要组合多个@Scheduled表达式。<br>@Schedules注解里面只有一个参数Scheduled数组，意味着我们可以将多个@Scheduled压入数组，组合使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//每隔18秒执行一次，并且每天的4:00执行一次</span></span><br><span class="line"><span class="meta">@Schedules</span>(&#123;<span class="meta">@Scheduled</span>(cron = <span class="string">"* * 4 * * *"</span>),<span class="meta">@Scheduled</span>(fixedRate = <span class="number">1000</span>*<span class="number">18</span>)&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="cronExpression的配置说明"><a href="#cronExpression的配置说明" class="headerlink" title="cronExpression的配置说明"></a>cronExpression的配置说明</h4><h5 id="各字段意义"><a href="#各字段意义" class="headerlink" title="各字段意义"></a>各字段意义</h5><table><thead><tr><th>字段</th><th>允许值</th><th>允许的特殊字符</th></tr></thead><tbody><tr><td>秒</td><td>0-59</td><td>, - * /</td></tr><tr><td>分</td><td>0-59</td><td>, - * /</td></tr><tr><td>小时</td><td>0-23</td><td>, - * /</td></tr><tr><td>日期</td><td>1-31</td><td>, - * /</td></tr><tr><td>月份</td><td>1-12或JAN-DEC</td><td>, - * /</td></tr><tr><td>星期</td><td>1-7或SUN-SAT</td><td>, - * /</td></tr><tr><td>年（可选）</td><td>留空，1970-2099</td><td>, - * /</td></tr></tbody></table><p><code>-</code> 指定区间<br><code>*</code> 通配符<br><code>?</code> 你不想设置那个值<br><code>/</code> 没多少执行一次</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><table><thead><tr><th>CRON表达式</th><th>含义</th></tr></thead><tbody><tr><td><code>0 0 12 * * ?</code></td><td>每天中午12点触发</td></tr><tr><td><code>0 15 10 ? * *</code></td><td>每天上午10:15触发</td></tr><tr><td><code>0 15 10 * * ?</code></td><td>每天上午10:15触发</td></tr><tr><td><code>0 15 10 * * ? *</code></td><td>每天上午10:15触发</td></tr><tr><td><code>0 15 10 * * ? 2015</code></td><td>2015年的每天上午10:15触发</td></tr><tr><td><code>0 * 14 * * ?</code></td><td>每天下午14:00到14：59每分钟触发一次</td></tr><tr><td><code>0 0/5 14 * * ?</code></td><td>每天下午14:00到14:55没5分钟触发一次</td></tr><tr><td><code>0 0/5 14,18 * * ?</code></td><td>每天14:00到14:55和18:00到18:55每5分钟触发一次</td></tr><tr><td><code>0 0-5 14 * * ?</code></td><td>每天14:00前五分钟每分钟触发一次</td></tr><tr><td><code>0 10,44 14 ? 3 WED</code></td><td>3月每周三14:10和14:44触发</td></tr><tr><td><code>0 15 10 ? * MON-FRI</code></td><td>周一到周五的10:15触发</td></tr></tbody></table>]]></content>
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring异步任务</title>
      <link href="/2018/02/20/2018-02-20Spring%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1/"/>
      <content type="html"><![CDATA[<p>在Spring3.0之前如果我们想要异步执行某项任务，需要我们自己编写线程池来实现。在Spring3.X新增了注解@Async，可以标记方法或者类中的所有方法都可以异步执行，而调用他的方法会在原来的线程中执行。这样可以避免阻塞，保证任务的实时性。适用于处理log，发送邮件等</p><p>#### 配置</p><p>##### 配置文件</p><p>同Spring自己实现的定时任务一样，我们需要在配置文件中引入task命名空间</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">xmlns:task</span>=<span class="string">"http://www.springframework.org/schema/task"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">...</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">​    <span class="attr">http:</span>//<span class="attr">www.springframework.org</span>/<span class="attr">schema</span>/<span class="attr">task</span>/<span class="attr">spring-task.xsd</span>"&gt;</span></span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure><p>然后配置相关的线程池和缺省的异步调度器</p><p>\<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">&lt;!--配置executor，一个应用中可以有多个executor--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"mailExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span> <span class="attr">keep-alive</span>=<span class="string">"100"</span> <span class="attr">queue-capacity</span>=<span class="string">"5"</span> <span class="attr">rejection-policy</span>=<span class="string">"ABORT"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">task:executor</span> <span class="attr">id</span>=<span class="string">"logExecutor"</span> <span class="attr">pool-size</span>=<span class="string">"10"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--指定一个缺省的executor给@Async使用，当@Async没有指定使用哪个executor将默认使用该executor--&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">executor</span>=<span class="string">"mailExecutor"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>##### 配置参数</p><p>- id: 当配置多个executor时，被@Async(“id”)指定使用，也可以作为线程名的前缀</p><p>- pool-size 指定线程池的大小</p><p>- queue-capacity：当最小的线程数已经被占用满后，新的任务会被放进queue里面，当这个queue的capacity也被占满之后，pool里面会创建新线程处理这个任务，直到总线程数达到了max size，这是系统会拒绝这个任务并抛出TaskRejectedException异常(可以通过rejection-policy来决定如何处理这种情况)，缺省值为Integer.MAX_VALUE</p><p>- keey-alive：超过core size的那些线程，任务完成后，经过这个时长就会被结束掉</p><p>- rejection-policy：当pool已经达到max size的时候，如何处理新任务</p><p>ABORT（缺省）：抛出TaskRejectedException异常，然后不执行</p><p>DISCARD：不执行，也不抛出异常</p><p>DISCARD_OLDEST：丢弃queue中最旧的那个任务</p><p>CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</p><p>#### 注解</p><p>##### 注解源码</p><p>\<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Async &#123;</span><br><span class="line"></span><br><span class="line">​    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure></p><p>通过@Async的源码我们可以知道，该注解可以用在方法上也可以用在类上，注解在方法上表明该方法是一部执行的，注解在类上表明该类中的所有方法都是一步执行的</p><p>##### 方法返回值</p><p>如果我们不想从异步线程中获取返回值，那么我们可以将返回值声明为void。如果我们想要从线程中获取数据，可以使用Future作为返回值。通过future.get()得到需要返回的对象，也可以使用future,get(time,unit)，在制定时间内获取返回值，如果超过设置的时间则抛出异常</p><p>\<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Async</span>(<span class="string">"logExecutor"</span>)</span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">business</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务开始执行"</span>);</span><br><span class="line"></span><br><span class="line">​        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务执行结束"</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     \* 没有指定调度器将使用缺省值</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     \* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     \* <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">​     */</span>[^]</span><br><span class="line"></span><br><span class="line">​    <span class="meta">@Async</span></span><br><span class="line"></span><br><span class="line">​    <span class="function"><span class="keyword">public</span> Future&lt;String&gt; <span class="title">business2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务开始执行"</span>);</span><br><span class="line"></span><br><span class="line">​        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">​        System.out.println(<span class="string">"异步任务执行结束"</span>);</span><br><span class="line"></span><br><span class="line">​        <span class="keyword">return</span> <span class="keyword">new</span> AsyncResult&lt;String&gt;(<span class="string">"hello world"</span>);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">\</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Spring拦截器</title>
      <link href="/2015/10/25/2015-10-25Spring%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
      <content type="html"><![CDATA[<h4 id="处理器拦截器简介"><a href="#处理器拦截器简介" class="headerlink" title="处理器拦截器简介"></a>处理器拦截器简介</h4><p>Spring MVC的处理器拦截器类型于Servlet开发中的Filter，用于对处理器进行预处理和后处理</p><h5 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h5><ul><li>日志记录：记录请求信息的日志，以便进行信息监控、信息统计、计算PV（Page View）等</li><li>权限检查：如登录检测，进入处理器检测检测是否登录，如果没有直接返回到登录页面</li><li>性能监控：通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，从而得到该请求的处理时间</li><li>通用行为：读取cookie得到用户信息并将用户对象放入请求，从而方便后续流程使用，还有如提取Locale、Theme信息等，只要是多个处理器都需要的即可使用拦截器实现。</li><li>OpenSessionInView：如Hibernate，在进入处理器打开Session，在完成后关闭Session。</li></ul><p>本质也是AOP（面向切面编程），也就是说符合横切关注点的所有功能都可以放入拦截器实现。</p><h4 id="拦截器实现"><a href="#拦截器实现" class="headerlink" title="拦截器实现"></a>拦截器实现</h4><p>SpringMVC 中的<code>Interceptor</code>拦截请求是通过<code>HandlerInterceptor</code>来实现的。在SpringMVC中定义一个<code>Interceptor</code>非常简单，主要有两种方式，第一种方式是要定义的<code>Interceptor</code>类要实现了Spring 的<code>HandlerInterceptor</code>接口，或者是这个类继承实现了<code>HandlerInterceptor</code>接口的类，比如Spring 已经提供的实现了<code>HandlerInterceptor</code>接口的抽象类<code>HandlerInterceptorAdapte</code>；第二种方式是实现Spring的<code>WebRequestInterceptor</code>接口，或者是继承实现了<code>WebRequestInterceptor</code>的类。</p><h5 id="HandlerInterceptor接口"><a href="#HandlerInterceptor接口" class="headerlink" title="HandlerInterceptor接口"></a><code>HandlerInterceptor</code>接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response,   </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler)</span>   </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">           HttpServletRequest request, HttpServletResponse response,   </span></span></span><br><span class="line"><span class="function"><span class="params">           Object handler, ModelAndView modelAndView)</span>   </span></span><br><span class="line"><span class="function">           <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">  </span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(  </span></span></span><br><span class="line"><span class="function"><span class="params">            HttpServletRequest request, HttpServletResponse response,   </span></span></span><br><span class="line"><span class="function"><span class="params">            Object handler, Exception ex)</span>  </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>有接口的定义我们可以看出<code>HandlerInterceptor</code>中定义了三个方法，我们就是通过这三个方法来对用户的请求进行拦截处理的。</p><ul><li><code>preHandle</code>实现处理器的预处理，第三个参数为响应处理器（一般为Controller）。返回true表示继续流程；返回false表示中断流程，不会继续调用其他的拦截器和处理器，这时候我们需要通过<code>response</code>来产生响应。我们可以在该方法中进行一些前置初始化操作或者是对当前请求的一个预处理。</li><li><code>postHandle</code>实现处理器的后处理，但是在<code>DispatcherServlet</code>渲染页面之前调用，我们可以调用modelAndView进行模型数据进行处理或对视图进行处理</li><li><code>afterCompleting</code>视图渲染完毕后回调该方法，该方法主要用于数据清理</li></ul><p><img src="/images/Spring拦截器1.jpg" alt=""><br><img src="/images/Spring拦截器2.jpg" alt=""><br>如果我们继承自HandlerInterceptor接口，那么我们每次都需要重写三个方法。但是大多数时候我们只需要重写其中一两个方法，这时候我们可以继承HandlerInterceptorAdapter类，选择性的重写其中的方法。<br>下面给出一个计算请求处理时间的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StopWatchHandlerInterceptor</span> <span class="keyword">extends</span> <span class="title">HandlerInterceptorAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> NamedThreadLocal&lt;Clock&gt;  startTimeThreadLocal =</span><br><span class="line"><span class="keyword">new</span> NamedThreadLocal&lt;Clock&gt;(<span class="string">"StopWatch-StartTime"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Cloxk start = Clock.now()<span class="comment">//1、开始时间</span></span><br><span class="line">        startTimeThreadLocal.set(beginTime);<span class="comment">//线程绑定变量（该数据只有当前请求的线程可见）</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//继续流程</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Clock end = Clock.now();<span class="comment">//2、结束时间  </span></span><br><span class="line">        Clock start = startTimeThreadLocal.get();<span class="comment">//得到线程绑定的局部变量（开始时间）</span></span><br><span class="line">        <span class="keyword">long</span> consumeTime = Duration.betwen(start, end).toMillis()<span class="comment">//3、消耗的时间</span></span><br><span class="line">            System.out.println(String.format(<span class="string">"%s consume %d millis"</span>, request.getRequestURI(), consumeTime));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="WebRequestInterceptor接口"><a href="#WebRequestInterceptor接口" class="headerlink" title="WebRequestInterceptor接口"></a><code>WebRequestInterceptor</code>接口</h5><p>该接口中也定义了三个方法，我们也可以通过这三个方法来实现拦截，这三个方法都传递了同一个参数<code>WebRequest</code>，三个方法的调用时机同<code>HanlderInterceptor</code>。<code>WebRequest</code>是Spring中定义的一个接口，方法基本和<code>HttpServletRequest</code>一样，对<code>WebRequest</code>做的任何操作都会同步到<code>HttpServletRequest</code>，然后在当前请求中一直传递</p><ul><li><p><code>preHandle(WebRequest request)</code>由于没有返回值，无法控制请求流程。我们一般在该方法中进行资源的准备工作。比如我们在使用Hibernate的时候可以在这个方法中准备一个Hibernate的Session对象，然后利用WebRequest的<code>setAttribute(name, value, scope)</code>把它放到WebRequest 的属性中。这里可以说说这个setAttribute 方法的第三个参数scope：</p><ul><li><code>SCOPE_REQUEST</code> ：它的值是0 ，代表只有在request 中可以访问。</li><li><code>SCOPE_SESSION</code> ：它的值是1 ，如果环境允许的话它代表的是一个局部的隔离的session，否则就代表普通的session，并且在该session范围内可以访问。</li><li><code>SCOPE_GLOBAL_SESSION</code> ：它的值是2 ，如果环境允许的话，它代表的是一个全局共享的session，否则就代表普通的session，并且在该session 范围内可以访问。</li></ul></li><li><p><code>postHandle(WebRequest request, ModelMap model)</code>ModelMap 就是Controller 处理之后返回的Model 对象，我们可以通过改变它的属性来改变返回的Model 模型。</p></li><li><code>afterCompletion(WebRequest request, Exception ex)</code>可以在该方法中进行资源的释放操作，Exception 参数表示的是当前请求的异常对象，如果在Controller 中抛出的异常已经被Spring 的异常处理器给处理了的话，那么这个异常对象就是是null 。</li></ul><h4 id="配置拦截器"><a href="#配置拦截器" class="headerlink" title="配置拦截器"></a>配置拦截器</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.windylee.interceptor.AllInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--指定拦截器的拦截路径--&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/interceptor/**"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定拦截器的实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.windylee.interceptor.StopWatchHandlerInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>mvc:interceptors</code>标签声明一系列的拦截器，然后它们就可以形成一个拦截器链，拦截器的执行顺序是按声明的先后顺序执行的，在mvc:interceptors标签下声明interceptor主要有两种方式：</p><ul><li>直接定义一个Interceptor实现类的bean对象。使用这种方式声明的Interceptor拦截器将会对所有的请求进行拦截。例子中的<code>AllInterceptor</code>会拦截所有请求</li><li>使用mvc:interceptor标签进行声明。使用这种方式进行声明的Interceptor可以通过mvc:mapping子标签来定义需要进行拦截的请求路径。</li></ul><h4 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h4><p>推荐能使用servlet规范中的过滤器Filter实现的功能就用Filter实现，因为HandlerInteceptor只有在Spring Web MVC环境下才能使用，因此Filter是最通用的、最先应该使用的。如登录这种拦截器最好使用Filter来实现。</p>]]></content>
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java8新的时间日期库</title>
      <link href="/2015/10/24/2015-10-24Java8%E6%96%B0%E7%9A%84%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F%E5%BA%93/"/>
      <content type="html"><![CDATA[<h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><h5 id="时间API分类概述"><a href="#时间API分类概述" class="headerlink" title="时间API分类概述"></a>时间API分类概述</h5><p>新的API： java.time，由5个包组成</p><ul><li><code>java.time</code>- 包含值对象的基础包</li><li><code>java.time.chrono</code> - 提供对不同的日历系统的访问</li><li><code>java.time.format</code> - 格式化和解析时间和日期</li><li><code>java.time.temporal</code> - 包括底层框架和扩展特性</li><li><code>java.time.zone</code> - 包含市区支持的类</li></ul><p>我们平时只会用到基础和format包，也可能用到temporal包，因此虽然新的API提供了多达68个新的公开类型，但是我们一般只会用到其中的三分之一</p><h5 id="关键日期-时间概述"><a href="#关键日期-时间概述" class="headerlink" title="关键日期/时间概述"></a>关键日期/时间概述</h5><ul><li>不可变性。借鉴于java.util.Calendar的前车之鉴，设计这个API的时候着重考虑了原有方法的不可变性，不允许任何更改，如果必须改变的话就会返回一个新的实例，所以我们必须捕获该方法的返回值</li><li>瞬间性。表示时间上的某个精确的时刻，使用从epoch开始计算的毫秒表示</li></ul><h4 id="关键API使用"><a href="#关键API使用" class="headerlink" title="关键API使用"></a>关键API使用</h4><h5 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h5><p>他可以通过时区来获取当前的instant，日期和时间。Clock类可以用来代替<code>System.currentTimeMillis()</code>和<code>TimeZone.getDefault()</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Clock clock=Clock.systemUTC();<span class="comment">//获取格林尼治时间</span></span><br><span class="line">System.out.println(clock.instant());<span class="comment">//获取Instant类型数据，后面会讲到</span></span><br><span class="line">System.out.println(clock.millis());<span class="comment">//获取标准毫秒数</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h5 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h5><p>所谓的Instant累代表的是某个时间（有点类似与java.util.Date），他是精确到纳秒的，而Date是精确到毫秒的。instant表示的是时间线上的一点，而不需要任何上下文信息，例如：时区。概念上讲他只是简单的表示自1970年1月1日0是0分0秒开始的秒数。下面给去确定一个方法的运行时间长度的代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instant start = Instant.now();</span><br><span class="line">doSomeThing();</span><br><span class="line">Instant end = Instant.now();</span><br><span class="line">Duration duration = Duration.between(start, end);</span><br><span class="line"><span class="keyword">long</span> seconds = duration.getSeconds();<span class="comment">//秒表示</span></span><br><span class="line"><span class="keyword">long</span> millis = duration.toMillis();<span class="comment">//毫秒表示</span></span><br><span class="line"><span class="keyword">boolean</span> isAfter = end.isAfter(start);<span class="comment">//时间点end是否在start之后[^]</span></span><br></pre></td></tr></table></figure></p><p>常用函数</p><ul><li><code>now()</code> 静态函数，获取当前时间戳</li><li><code>isAfter()/isBefore()</code> 判断两个时间点的先后顺序</li><li><code>plusXXX()</code> 在该时间点加上某段时间</li><li><code>minusXXX()</code> 在该时间点上减去某段时间</li></ul><p>Instant用在当你需要记录事件的发生时间，额如需要记录任何有关时区信息时。Instant只能包含秒数和毫秒数，例如如下代码就会抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instant.get(ChronoField.MONTH_OF_YEAR);</span><br><span class="line">instant.plus(<span class="number">6</span>, ChronoUnit.YEARS);</span><br></pre></td></tr></table></figure></p><h5 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h5><p><code>LocalDate</code>表示日期的不可变类型，不包含时间和时区。LocalDate和下面要讲的LocalTime都被设计成值类型的，这意味着我们不能用<code>==</code>来判断两个LocalDate是不是相等而是应该通过<code>equals()</code>。下面给出一个获取当前年月日的例子<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now(); </span><br><span class="line"><span class="keyword">int</span> year = today.getYear(); </span><br><span class="line"><span class="keyword">int</span> month = today.getMonthValue(); </span><br><span class="line"><span class="keyword">int</span> day = today.getDayOfMonth(); </span><br><span class="line">System.out.printf(<span class="string">"Year : %d Month : %d day : %d \t %n"</span>, year, month, day);</span><br></pre></td></tr></table></figure></p><p>常用函数</p><ul><li><code>now()</code>根据当前时间戳创建<code>LocalDate</code></li><li><code>of()</code>根据制定的年月日创建<code>LocalDate</code></li><li><code>parse(charqueue, DateTimeFormatter)</code>根据传入的format将字符串转化为LocalDate对象</li><li><code>ofYearDay()</code>根据指定的年和一年中的第几天创建<code>LocalDate</code></li><li><code>getXXX()</code>获取当前<code>LocalDate</code>中关于日期的信息，年月日等等</li><li><code>plusXXX()</code>在当前的<code>LocalDate</code>的基础上增加指定时间类型来创建一个新的<code>LocalDate</code></li><li><code>minusXXX()</code>在当前的<code>LocalDate</code>的基础上减去指定时间类型来创建一个新的<code>LocalDate</code></li><li><code>withXXX()</code>在当前的<code>LocalDate</code>的基础上指定某个时间类型的值来创建一个新的<code>LocalDate</code></li><li><code>isXXX()</code>判断两个<code>LocalDate</code>的大小关系，特别（<code>isLeepYear()</code>判断是否为闰年）</li><li><code>lengthOfXXX()</code>获取LocalDate代表的年或月的天数</li><li><code>with(TemporalAdjuster)</code>TemporalAdjusters提供了几个用来获取<code>TemporalAdjuster</code>的方法，用来处理比较复杂的逻辑，比如获取当月的最后一天<code>lastDayOfMonth()</code></li><li><code>atTime()</code>将<code>LocalDate</code>转化为<code>LocalDateTime</code></li></ul><h5 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h5><p><code>LocalTime</code>是值类型，且和日期，时区没有关联。当我们对时间进行加减操作时，以午夜为基准，24小时一个周期。因此，20:00加上6小时，结果是02:00。LocalTime用法和LocalDate类似<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">LocalTime time = LocalTime.of(<span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line"><span class="keyword">int</span> hour = date.getHour(); <span class="comment">// 20</span></span><br><span class="line"><span class="keyword">int</span> minute = date.getMinute(); <span class="comment">// 30</span></span><br><span class="line">time = time.withSecond(<span class="number">6</span>); <span class="comment">// 20:30:06</span></span><br><span class="line">time = time.plusMinutes(<span class="number">3</span>); <span class="comment">// 20:33:06</span></span><br></pre></td></tr></table></figure></p><p>常用函数</p><ul><li>和<code>LocalDate</code>基本类似，只是将对年月日的操作转换为时分秒</li><li><code>toSecondOfDay()</code>获取该时间点距离0:00的秒数</li></ul><h5 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h5><p>这个值类型只是<code>LocalDate</code>和<code>LocalTime</code>的简单组合。他表示一个和时区无关的日期和时间。LocalDateTime可以直接创建或者组合时间和日期<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt1 = LocalDateTime.of(<span class="number">2014</span>, Month.JUNE, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>);</span><br><span class="line">LocalDateTime dt2 = LocalDateTime.of(date, time);</span><br><span class="line">Month month = dt1.getMonth();</span><br><span class="line"><span class="keyword">int</span> minute = dt1.getMinute();</span><br></pre></td></tr></table></figure></p><p>常用函数</p><ul><li>将<code>LocalDate</code>和<code>LocalTime</code>两个类的<code>plusXXX()</code>, <code>minusXXX()</code>, <code>withXXX()</code>,<code>getXXX()</code>简单相加</li><li>与<code>LocalDate</code>对象其他函数完全类似</li><li><code>isXXX()</code>与LocalDate完全一样</li><li><code>toLocalDate()/toLocalTime()</code>将<code>LocalDateTime</code>转换为<code>LocalTime</code>或者<code>LocalDate</code></li></ul><h5 id="时间长度"><a href="#时间长度" class="headerlink" title="时间长度"></a>时间长度</h5><p><code>Duration</code>表示以秒和纳秒位基准的时长；<code>Period</code>表示以年，月，日衡量的时长。他们可以作为参数，传给主要的时间/日期类的增加或减少的方法，也可以计算两个时间点之间的间隔<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Duration duration = Duration.ofDays(<span class="number">10</span>);</span><br><span class="line">LocalTime start = LocalTime.now();</span><br><span class="line">doSoneThing();</span><br><span class="line">LocalTime end = LocalTime.now();</span><br><span class="line">Duration spend = Duration.between(start, end);</span><br></pre></td></tr></table></figure></p><p>常用函数</p><ul><li><code>ofXXX()</code>根据参数指定的大小计算以<code>XXX</code>个单位的时间间隔</li><li><code>between(arg1, arg2)</code>计算两个参数时间点的时间间隔</li><li><code>plusXXX()/minuxXXX()</code>在当前时间间隔的基础上加上或减去指定个单位的时间</li><li><code>toXXX()</code>将时间间隔格式化位指定单位的时间，Duration一般使用该类型函数，Period一般使用<code>getXXX()</code></li><li><code>abs()</code>求时间间隔的绝对值，保证时间间隔不为负数</li><li><code>isZero()/isNegative()</code>判断时间间隔是否为0或负</li><li><code>withXXX()</code>直接指定某个单位的值</li></ul><h5 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h5><p><code>java.time.format</code>包是专门用来格式化输出输入时间/日期的。这个包围绕<code>DateTimeFormatter</code>类和它的辅助创建类<code>DateTimeFormatterBuilder</code>展开。静态方法<code>ofPattern(Charqueue)</code>和<code>DateTimeFormatter</code>中的常量是最通用的创建格式化器的方式</p><ul><li>常用ISO格式常量，如ISO_LOCAL_DATE</li><li>字母模式，如ofPattern(“dd/MM/uuuu”)</li><li>本地化样式，如ofLocalizedDate(FormatStyle.MEDIUM)</li></ul><p>有了格式化器，我们就可以将该实例传递给<code>parse()</code>或者<code>format()</code>作为参数，用来将字符串格式化为对象或者将对象格式化位字符串<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照内置的不同方式格式化</span></span><br><span class="line">String format = DateTimeFormatter.ISO_LOCAL_DATE.format(LocalDate.now());</span><br><span class="line">String format2 = DateTimeFormatter.ISO_LOCAL_TIME.format(LocalTime.now());</span><br><span class="line">String format3 = DateTimeFormatter.ISO_DATE.format(LocalDateTime.now());</span><br><span class="line">String format4 = DateTimeFormatter.ISO_INSTANT.format(Instant.now());</span><br><span class="line">System.out.println(format);</span><br><span class="line">System.out.println(format2);</span><br><span class="line">System.out.println(format3);</span><br><span class="line">System.out.println(format4);</span><br><span class="line">         </span><br><span class="line"><span class="comment">//按照标准格式格式化</span></span><br><span class="line">DateTimeFormatter formatter = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);</span><br><span class="line">String format5 = formatter.format(LocalDateTime.now());</span><br><span class="line">System.out.println(format5);</span><br><span class="line">         </span><br><span class="line"><span class="comment">//按照指定方式格式化</span></span><br><span class="line">DateTimeFormatter pattern = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd E HH:mm:ss"</span>);</span><br><span class="line">String format6 = pattern.format(LocalDateTime.now());</span><br><span class="line">System.out.println(format6);</span><br></pre></td></tr></table></figure></p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p><code>YearMonth</code>仅仅包含年和月字段，操作也<code>LocalDate</code>类似<br><code>MonthDay</code>仅仅包含月和日字段，操作与<code>LocalDate</code>类似</p>]]></content>
      
      <categories>
          
          <category> Java Web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>effictive-java读书笔记</title>
      <link href="/2015/10/20/2015-10-20effictive-java%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
      <content type="html"><![CDATA[<h1 id="Effective-Java一书笔记"><a href="#Effective-Java一书笔记" class="headerlink" title="Effective Java一书笔记"></a>Effective Java一书笔记</h1><h2 id="对象的创建与销毁"><a href="#对象的创建与销毁" class="headerlink" title="对象的创建与销毁"></a>对象的创建与销毁</h2><ul><li>Item 1: 使用static工厂方法，而不是构造函数创建对象<br>仅仅是创建对象的方法，并非Factory Pattern<ul><li>优点<ul><li>命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义</li><li>Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutable的对象来说，使得用<code>==</code>判等符合语义，且更高效；</li><li>工厂方法能够返回任何返回类型的子类对象，甚至是私有实现；使得开发模块之间通过接口耦合，降低耦合度；而接口的实现也将更加灵活；接口不能有static方法，通常做法是为其再创建一个工厂方法类，如Collection与Collections；</li><li>Read More: Service Provider Framework</li></ul></li><li>缺点<ul><li>仅有static工厂方法，没有public/protected构造函数的类将无法被继承；见仁见智，这一方面也迫使开发者倾向于组合而非继承；</li><li>Javadoc中不能和其他static方法区分开，没有构造函数的集中显示优点；但可以通过公约的命名规则来改善；</li></ul></li><li>小结<br>static工厂方法和public构造函数均有其优缺点，在编码过程中，可以先考虑一下工厂方法是否合适，再进行选择。</li></ul></li><li>Item 2: 使用当构造函数的参数较多，尤其是其中还有部分是可选参数时，使用Builder模式<ul><li>以往的方法<ul><li>Telescoping constructor：针对可选参数，从0个到最多个，依次编写一个构造函数，它们按照参数数量由少到多逐层调用，最终调用到完整参数的构造函数；代码冗余，有时还得传递无意义参数，而且容易导致使用过程中出隐蔽的bug；</li><li>JavaBeans Pattern：灵活，但是缺乏安全性，有状态不一致问题，线程安全问题；</li></ul></li><li>Builder Pattern<ul><li>代码灵活简洁；具备安全性；</li><li>immutable</li><li>参数检查：最好放在要build的对象的构造函数中，而非builder的构建过程中</li><li>支持多个field以varargs的方式设置（每个函数只能有一个varargs）</li><li>一个builder可以build多个对象</li><li>Builder结合泛型，实现Abstract Factory Pattern</li><li>传统的抽象工厂模式，是用Class类实现的，然而其有缺点：newInstance调用总是去调用无参数构造函数，不能保证存在；newInstance方法会抛出所有无参数构造函数中的异常，而且不会被编译期的异常检查机制覆盖；可能会导致运行时异常，而非编译期错误；</li></ul></li><li>小结<br>Builder模式在简单地类（参数较少，例如4个以下）中，优势并不明显，但是需要予以考虑，尤其是当参数可能会变多时，有可选参数时更是如此。</li></ul></li></ul><a id="more"></a><ul><li><p>Item 3: 单例模式！<br>不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。</p><ul><li>double-check-locking  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RestAdapter sRestAdapter = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestAdapter <span class="title">provideRestAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RestProvider.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sRestAdapter = <span class="keyword">new</span> RestAdapter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sRestAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>DCL可能会失效，因为指令重排可能导致同步解除后，对象初始化不完全就被其他线程获取；使用volatile关键字修饰对象，或者使用static SingletonHolder来避免该问题（后者JLS推荐）；</p><ul><li>class的static代码：一个类只有在被使用时才会初始化，而类初始化过程是非并行的，这些都由JLS能保证</li><li>用enum实现单例</li><li>还存在反射安全性问题：利用反射，可以访问私有方法，可通过加一个控制变量，该变量在getInstance函数中设置，如果不是从getInstance调用构造函数，则抛出异常；</li></ul></li><li>Item 4: 将构造函数私有化，使得不能从类外创建实例，同时也能禁止类被继承<br>util类可能不希望被实例化，有其需求</li><li>Item 5: 避免创建不必要的对象<ul><li>提高性能：创建对象需要时间、空间，“重量级”对象尤甚；immutable的对象也应该避免重复创建，例如String；</li><li>避免auto-boxing</li><li>但是因此而故意不创建必要的对象是错误的，使用object pool通常也是没必要的</li><li>lazy initialize也不是特别必要，除非使用场景很少且很重量级</li><li>Map#keySet方法，每次调用返回的是同一个Set对象，如果修改了返回的set，其他使用的代码可能会产生bug</li><li>需要defensive copying的时候，如果没有创建一个新对象，将导致很隐藏的Bug</li></ul></li><li>Item 6: 不再使用的对象一定要解除引用，避免memory leak<ul><li>例如，用数组实现一个栈，pop的时候，如果仅仅是移动下标，没有把pop出栈的数组位置引用解除，将发生内存泄漏</li><li>程序发生错误之后，应该尽快把错误抛出，而不是以错误的状态继续运行，否则可能导致更大的问题</li><li>通过把变量（引用）置为null不是最好的实现方式，只有在极端情况下才需要这样；好的办法是通过作用域来使得变量的引用过期，所以尽量缩小变量的作用域是很好的实践；注意，在Dalvik虚拟机中，存在一个细微的bug，可能会导致内存泄漏，<a href="MemoryLeak.md">详见</a></li><li>当一个类管理了一块内存，用于保存其他对象（数据）时，例如用数组实现的栈，底层通过一个数组来管理数据，但是数组的大小不等于有效数据的大小，GC器却并不知道这件事，所以这时候，需要对其管理的数据对象进行null解引用</li><li>当一个类管理了一块内存，用于保存其他对象（数据）时，程序员应该保持高度警惕，避免出现内存泄漏，一旦数据无效之后，需要立即解除引用</li><li>实现缓存的时候也很容易导致内存泄漏，放进缓存的对象一定要有换出机制，或者通过弱引用来进行引用</li><li>listner和callback也有可能导致内存泄漏，最好使用弱引用来进行引用，使得其可以被GC</li></ul></li><li>Item 7: 不要使用finalize方法<ul><li>finalize方法不同于C++的析构函数，不是用来释放资源的好地方</li><li>finalize方法执行并不及时，其执行线程优先级很低，而当对象unreachable之后，需要执行finalize方法之后才能释放，所以会导致对象生存周期变长，甚至根本不会释放</li><li>finalize方法的执行并不保证执行成功/完成</li><li>使用finalize时，性能会严重下降</li><li>finalize存在的意义<ul><li>充当“safety net”的角色，避免对象的使用者忘记调用显式termination方法，尽管finalize方法的执行时间没有保证，但是晚释放资源好过不释放资源；此处输出log警告有利于排查bug</li><li>用于释放native peer，但是当native peer持有必须要释放的资源时，应该定义显式termination方法</li></ul></li><li>子类finalize方法并不会自动调用父类finalize方法（和构造函数不同），为了避免子类不手动调用父类的finalize方法导致父类的资源未被释放，当需要使用finalize时，使用finalizer guardian比较好：<ul><li>定义一个私有的匿名Object子类对象，重写其finalize方法，在其中进行父类要做的工作</li><li>因为当父类对象被回收时，finalizer guardian也会被回收，它的finalize方法就一定会被触发</li></ul></li></ul></li></ul><!--more--><p>##Object的方法<br>尽管Object不是抽象类，但是其定义的非final方法设计的时候都是希望被重写的，finalize除外。</p><ul><li>Item 8: 当重写equals方法时，遵循其语义<ul><li>能不重写equals时就不要重写<ul><li>当对象表达的不是值，而是可变的状态时</li><li>对象不需要使用判等时</li><li>父类已重写，且满足子类语义</li></ul></li><li>当需要判等，且继承实现无法满足语义时，需要重写（通常是“value class”，或immutable对象）</li><li>当用作map的key时</li><li>重写equals时需要遵循的语义<ul><li>Reflexive（自反性）: x.equals(x)必须返回true（x不为null）</li><li>Symmetric（对称性）: x.equals(y) == y.equals(x)</li><li>Transitive（传递性）: x.equals(y) &amp;&amp; y.equals(z) ==&gt; x.equals(z)</li><li>Consistent（一致性）: 当对象未发生改变时，多次调用应该返回同一结果</li><li>x.equals(null)必须返回false</li></ul></li><li>实现建议<ul><li>先用==检查是否引用同一对象，提高性能</li><li>用instanceof再检查是否同一类型</li><li>再强制转换为正确的类型</li><li>再对各个域进行equals检查，遵循同样的规则</li><li>确认其语义正确，编写测例</li><li>重写equals时，同时也重写hashCode</li><li>！重写equals方法，传入的参数是Object</li></ul></li></ul></li><li>Item 9: 重写equals时也重写hashCode函数<ul><li>避免在基于hash的集合中使用时出错</li><li>语义<ul><li>一致性</li><li>当两个对象equals返回true时，hashCode方法的返回值也要相同</li></ul></li><li>hashCode的计算方式<ul><li>要求：equals的两个对象hashCode一样，但是不equals的对象hashCode不一样</li><li>取一个素数，例如17，result = 17</li><li>对每一个关心的field（在equals中参与判断的field），记为f，将其转换为一个int，记为c</li><li>boolean: f ? 1 : 0</li><li>byte/char/short/int: (int) f</li><li>long: (int) (f ^ (f &gt;&gt; 32))</li><li>float: Float.floatToIntBits(f)</li><li>double: Double.doubleToLongBits(f)，再按照long处理</li><li>Object: f == null ? 0 : f.hashCode()</li><li>array: 先计算每个元素的hashCode，再按照int处理</li><li>对每个field计算的c，result = 31 * result + c</li><li>返回result</li><li>编写测例</li></ul></li><li>计算hashCode时，不重要的field（未参与equals判断）不要参与计算</li></ul></li><li>Item 10: 重写toString()方法<ul><li>增加可读性，简洁、可读、具有信息量</li></ul></li><li>Item 11: 慎重重写clone方法<ul><li>Cloneable接口是一个mixin interface，用于表明一个对象可以被clone</li><li>Contract<ul><li>x.clone() != x</li><li>x.clone().getClass() ==  x.getClass()：要求太弱，当一个非final类重写clone方法的时候，创建的对象一定要通过super.clone()来获得，所有父类都遵循同样的原则，如此最终通过Object.clone()创建对象，能保证创建的是正确的类实例。而这一点很难保证。</li><li>x.clone().equals(x)</li><li>不调用构造函数：要求太强，一般都会在clone函数里面调用</li></ul></li><li>对于成员变量都是primitive type的类，直接调用super.clone()，然后cast为自己的类型即可（重写时允许返回被重写类返回类型的子类，便于使用方，不必每次cast）</li><li>成员变量包含对象（包括primitive type数组），可以通过递归调用成员的clone方法并赋值来实现</li><li>然而上述方式违背了final的使用协议，final成员不允许再次赋值，然而clone方法里面必须要对其赋值，则无法使用final保证不可变性了</li><li>递归调用成员的clone方法也会存在性能问题，对HashTable递归调用深拷贝也可能导致StackOverFlow（可以通过遍历添加来避免）</li><li>优雅的方式是通过super.clone()创建对象，然后为成员变量设置相同的值，而不是简单地递归调用成员的clone方法</li><li>和构造函数一样，在clone的过程中，不能调用non final的方法，如果调用虚函数，那么该函数会优先执行，而此时被clone的对象状态还未完成clone/construct，会导致corruption。因此上一条中提及的“设置相同的值”所调用的方法，要是final或者private。</li><li>重载类的clone方法可以省略异常表的定义，如果重写时把可见性改为public，则应该省略，便于使用；如果设计为应该被继承，则应该重写得和Object的一样，且不应该实现Cloneable接口；多线程问题也需要考虑；</li><li>要实现clone方法的类，都应该实现Cloneable接口，同时把clone方法可见性设为public，返回类型为自己，应该调用super.clone()来创建对象，然后手动设置每个域的值</li><li>clone方法太过复杂，如果不实现Cloneable接口，也可以通过别的方式实现copy功能，或者不提供copy功能，immutable提供copy功能是无意义的</li><li>提供拷贝构造函数，或者拷贝工厂方法，而且此种方法更加推荐，但也有其不足</li><li>设计用来被继承的类时，如果不实现一个正确高效的clone重写，那么其子类也将无法实现正确高效的clone功能</li></ul></li><li>Item 12: 当对象自然有序时，实现Comparable接口<ul><li>实现Comparable接口可以利用其有序性特点，提高集合使用/搜索/排序的性能</li><li>Contact<ul><li>sgn(x.compareTo(y)) == - sgn(y.compareTo(x))，当类型不对时，应该抛出ClassCastException，抛出异常的行为应该是一致的</li><li>transitive: x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 ==&gt; x.compareTo(z) &gt; 0</li><li>x.compareTo(y) == 0 ==&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z))</li><li>建议，但非必须：与equals保持一致，即 x.compareTo(y) == 0 ==&gt; x.equals(y)，如果不一致，需要在文档中明确指出</li></ul></li><li>TreeSet, TreeMap等使用的就是有序保存，而HashSet, HashMap则是通过equals + hashCode保存</li><li>当要为一个实现了Comparable接口的类增加成员变量时，不要通过继承来实现，而是使用组合，并提供原有对象的访问方法，以保持对Contract的遵循</li><li>实现细节<ul><li>优先比较重要的域</li><li>谨慎使用返回差值的方式，有可能会溢出</li></ul></li></ul></li></ul><p>##Classes and Interfaces</p><ul><li>Item 13: 最小化类、成员的可见性<ul><li>封装（隐藏）：公开的接口需要暴露，而接口的实现则需要隐藏，使得接口与实现解耦，降低模块耦合度，增加可测试性、稳定性、可维护性、可优化性、可修改性</li><li>如果一个类只对一个类可见，则应该将其定义为私有的内部类，而没必要public的类都应该定义为package private</li><li>为了便于测试，可以适当放松可见性，但也只应该改为package private，不能更高</li><li>成员不能是非private的，尤其是可变的对象。一旦外部可访问，将失去对其内容的控制能力，而且会有多线程问题</li><li>暴露的常量也不能是可变的对象，否则public static final也将失去其意义，final成员无法改变其指向，但其指向的对象却是可变的（immutable的对象除外），长度非0的数组同样也是有问题的，可以考虑每次访问时创建拷贝，或者使用<code>Collections.unmodifiableList(Arrays.asList(arr))</code></li></ul></li><li>Item 14: public class中，使用accessor method而非public field<ul><li>后者外部可以直接访问，失去了安全性</li><li>package private或者private则可以不必这样</li><li>把immutable的field置为public勉强可以接受，mutable的成员一定不能置为public</li></ul></li><li>Item 15: 最小化可变性<ul><li>不提供可以改变本对象状态的方法</li><li>保证类不可被继承</li><li>使用final field</li><li>使用private field</li><li>在构造函数、accessor中，对mutable field使用defensive copy</li><li>实现建议<ul><li>操作函数，例如BigInteger的add方法，不是static的，但也不能改变本对象的状态，则使用functional的方式，返回一个新的对象，其状态是本对象修改之后的状态</li><li>如此实现的immutable对象生来就是线程安全的，无需同步操作，但应该鼓励共用实例，避免创建过多重复的对象</li><li>正确实现的immutable对象也不需要clone, copy方法；可以适当引入Object cache；</li></ul></li><li>劣势<ul><li>每一个值都需要一个对象，调用改变状态的方法而创建一个新的对象，尤其是它是重量级的，开销会变大；连续调用这样的方法，影响更大；</li><li>为常用的多次操作组合提供一个方法</li></ul></li><li>其他<ul><li>保证class无法被继承，除了声明为final外，还可以将默认构造函数声明为private或package private，然后提供public static工厂方法</li><li>使用public static工厂方法，具体实现类可以有多个，还能进行object cache</li><li>当实现Serializable接口是，一定要实现readObject/readResolve方法，或者使用ObjectOutputStream.writeUnshared/ObjectInputStream.readUnshared</li></ul></li><li>小结<ul><li>除非有很好的理由让一个Class mutable，否则应该使其immutable</li><li>如果非要mutable，也应尽可能限制其可变性</li></ul></li></ul></li><li>Item 16: Favor composition (and forwarding) over inheritance<ul><li>跨包继承、继承不是被设计为应该被继承的实现类，是一件很危险的事情，继承接口、继承抽象类，当然是没问题的</li><li>如果子类的功能依赖于父类的实现细节，那么一旦父类发生变化，子类将有可能出现Bug，即便代码都没有修改；而设计为应被继承的类，在修改后，是应该有文档说明的，子类开发者既可以得知，也可以知道如何修改</li><li>例子：统计HashSet添加元素的次数<ul><li>用继承方式，重写add，addAll，在其中计数，这就不对，因为HashSet内部的addAll是通过调用add实现的</li><li>但是通过不重写addAll也只不对的，以后有可能HashSet的实现就变了</li><li>在重写中重新实现一遍父类的逻辑也是行不通的，因为这可能会导致性能问题、bug等，而且有些功能不访问私有成员也是无法实现的</li><li>还有一个原因就是父类的实现中，可能会增加方法，改变其行为，而这一点，在子类中是无法控制的</li></ul></li><li>而通过组合的方式，将不会有这些问题，把另一个类的对象声明为私有成员，外部将无法访问它，自己也能在转发（forwarding）过程中执行拦截操作，也不必依赖其实现细节，这种组合、转发的实现被称为wrapper，或者Decorator pattern，或者delegation（严格来说不是代理，代理一般wrapper对象都需要把自己传入到被wrap的对象方法中？）</li><li>缺点<ul><li>不适用于callback frameworks？</li></ul></li><li>继承应该在is-a的场景中使用</li><li>继承除了会继承父类的API功能，也会继承父类的设计缺陷，而组合则可以隐藏成员类的设计缺陷</li></ul></li><li>Item 17: Design and document for inheritance or else prohibit it<ul><li>一个类必须在文档中说明，每个可重写的方法，在该类的实现中的哪些地方会被调用（the class must document its self-use of overridable methods）。调用时机、顺序、结果产生的影响，包括多线程、初始化等情况。</li><li>被继承类应该通过谨慎选择protected的方法或成员，来提供一些hook，用于改变其内部的行为，例如java.util.AbstractList::removeRange。</li><li>The only way to test a class designed for inheritance is to write subclasses. 用于判断是否需要增加或者减少protected成员/方法，通常写3个子类就差不多了。</li><li>You must test your class by writing subclasses before you release it.</li><li>Constructors must not invoke overridable methods. 父类的构造函数比子类的构造函数先执行，而如果父类构造函数中调用了可重写的方法，那么就会导致子类的重写方法比子类的构造函数先执行，会导致corruption。</li><li>如果实现了Serializable/Cloneable接口，neither clone nor readObject may invoke an overridable method, directly or indirectly. 重写方法会在deserialized/fix the clone’s state之前执行。</li><li>如果实现了Serializable接口，readResolve/writeReplace必须是protected，而非private</li><li>designing a class for inheritance places substantial limitations on the class.</li><li>The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed. 声明为final class或者把构造函数私有化（提供public static工厂方法）。</li><li>如果确实想要允许继承，就应该为每个被自己使用的可重写方法都写好文档</li></ul></li><li>Item 18: Prefer interfaces to abstract classes<ul><li>Java类只允许单继承，接口可以多继承，使用接口定义类型，使得class hierarchy更加灵活</li><li>定义mixin（optional functionality to be “mixed in”）时使用interface是很方便的，需要增加此功能的类只需要implement该接口即可，而如果使用抽象类，则无法增加一个extends语句</li><li>接口允许构建没有hierarchy的类型系统</li><li>使用接口定义类型，可以使得item 16中提到的wrapper模式更加安全、强大，</li><li>skeletal implementation：该类为abstract，把必须由client实现的方法设为abstract，可以有默认实现的则提供默认实现</li><li>simulated multiple inheritance：通过实现定义的接口，同时在内部实现一个匿名的skeletal implementation，将对对该接口的调用转发到匿名类中，起到“多继承”的效果</li><li>simple implementation：提供一个非抽象的接口实现类，提供一个最简单、能work的实现，也允许被继承</li><li>使用接口定义类型的缺点：不便于演进，一旦接口发布，如果想要增加功能（增加方法），则client将无法编译；而使用abstract class，则没有此问题，只需要提供默认实现即可</li><li>小结<ul><li>通过接口定义类型，可以允许多实现（多继承）</li><li>但是演进需求大于灵活性、功能性时，抽象类更合适</li><li>提供接口时，提供一个skeletal implementation，同时审慎考虑接口设计</li></ul></li></ul></li><li>Item 19: 仅仅用interface去定义一个类型，该接口应该有实现类，使用者通过接口引用，去调用接口的方法<ul><li>避免用接口去定义常量，应该用noninstantiable utility class去定义常量</li><li>相关常量的命名，通过公共前缀来实现分组</li></ul></li><li>Item 20: Prefer class hierarchies to tagged classes<ul><li>tagged class: 在内部定义一个tag变量，由其控制功能的转换</li><li>tag classes are verbose, error-prone, and inefficient</li><li>而class hierarchy，不同功能由不同子类实现，公共部分抽象为一个基类，也能反映出各个子类之间的关系</li></ul></li><li>Item 21: Use function objects to represent strategies<ul><li>只提供一个功能函数的类实例，没有成员变量，只需一个对象（单例），为其功能定义一个接口，则可以实现策略模式，把具体策略传入相应函数中，使用策略</li><li>具体的策略实例通常使用匿名类定义，调用使用该策略的方法时才予以创建/预先创建好之后每次将其传入</li></ul></li><li>Item 22: Favor static member classes over nonstatic<ul><li>有4种nested class：non-static member class; static member class(inner class); anonymous class; local class</li><li>static member class<ul><li>经常作为helper class，和外部类一起使用</li><li>如果nested class的生命周期独立于外部类存在，则必须定义为static member class，否则可能造成内存泄漏</li><li>private static member class用处一：表示（封装）外部类的一些成员，例如Map的Entry内部类。</li></ul></li><li>non-static member class<ul><li>将持有外部类实例的强引用，可以直接引用外部类的成员和方法</li><li>用处一：定义一个Adapter，使得外部内的实例，可以作为和外部类语义不同的实例来查看（访问），例如Collection的Iterator。</li><li>如果nested class不需要引用外部类的成员和方法，则一定要将其定义为static，避免空间/时间开销，避免内存泄漏</li></ul></li><li>anonymous class<ul><li>当在非static代码块内定义时，会持有外部类的引用，否则不会持有</li><li>限制</li><li>只能在被声明的地方进行实例化</li><li>无法进行instanceof测试</li><li>不能用匿名类实现多个接口</li><li>不能用匿名类继承一个类的同时实现接口</li><li>匿名类中新添加的方法无法在匿名类外部访问</li><li>不能有static成员</li><li>应该尽量保持简短</li><li>用处一：创建function object</li><li>用处二：创建process object，例如：Runnable, Thread, TimberTask</li><li>用处三：用于public static工厂方法，例如Collections类里面的一些工厂方法，很多是返回一个匿名的内部实现</li></ul></li><li>local class<ul><li>比较少用</li><li>是否static取决于其定义的上下文</li><li>可以在作用域内重复使用</li><li>不能有static成员</li><li>也应尽量保持简短</li></ul></li><li>小结<ul><li>四种nested class</li><li>如果nested class在整个外部类内都需要可见，或者定义代码太长，应使用member class</li><li>能static就一定要static，即便需要对外部类进行引用，对于生命周期独立于外部类的，也应该通过WeakReference进行引用，避免内存泄漏；至于生命周期和外部类一致的，则不必这样</li></ul></li></ul></li></ul><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><ul><li><p>Item 23: Don’t use raw types in new code</p><ul><li>Java泛型，例如<code>List&lt;E&gt;</code>，真正使用的时候都是<code>List&lt;String&gt;</code>等，把E替换为实际的类型</li><li>Java泛型从1.5引入，为了保持兼容性，实现的是伪泛型，类型参数信息在编译完成之后都会被擦除，其在运行时的类型都是raw type，类型参数保存的都是Object类型，<code>List&lt;E&gt;</code>的raw type就是<code>List</code></li><li>编译器在编译期通过类型参数，为读操作自动进行了类型强制转换，同时在写操作时自动进行了类型检查</li><li>如果使用raw type，那编译器就不会在写操作时进行类型检查了，写入错误的类型也不会报编译错误，那么在后续读操作进行强制类型转换时，将会导致转换失败，抛出异常</li><li>一旦错误发生，应该让它尽早被知道（抛出/捕获），编译期显然优于运行期</li><li><p><code>List</code>与<code>List&lt;Object&gt;</code>的区别</p><ul><li>前者不具备类型安全性，后者具备，例如以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uses raw type (List) - fails at runtime!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  unsafeAdd(strings, <span class="keyword">new</span> Integer(<span class="number">42</span>));</span><br><span class="line">  String s = strings.get(<span class="number">0</span>); <span class="comment">// Compiler-generated cast</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unsafeAdd</span><span class="params">(List list, Object o)</span> </span>&#123;</span><br><span class="line">  list.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>不会报编译错误，但会给一个编译警告：<code>Test.java:10: warning: unchecked call to add(E) in raw type List list.add(o);</code>，而运行时则会发生错误。</p><ul><li>但如果使用<code>List&lt;Object&gt;</code>，即<code>unsageAdd</code>参数改为<code>List&lt;Object&gt; list, Object o</code>，则会报编译错误：<code>Test.java:5: unsafeAdd(List&lt;Object&gt;,Object) cannot be applied to (List&lt;String&gt;,Integer) unsafeAdd(strings, new Integer(42));</code>  </li><li>因为<code>List&lt;String&gt;</code>是<code>List</code>的子类，但却不是<code>List&lt;Object&gt;</code>的子类。  </li><li>并不是说这个场景应该使用<code>List&lt;Object&gt;</code>，这个场景应该使用<code>List&lt;String&gt;</code>，这里只是为了说明<code>List</code>和<code>List&lt;Object&gt;</code>是有区别的。</li></ul></li><li><p><code>List</code> v.s. <code>List&lt;?&gt;</code>（unbounded wildcard types），当不确定类型参数，或者说类型参数不重要时，也不应该使用raw type，而应该使用<code>List&lt;?&gt;</code></p><ul><li><p>任何参数化的List均是<code>List&lt;?&gt;</code>的子类，可以作为参数传入接受<code>List&lt;?&gt;</code>的函数，例如以下代码均是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="keyword">new</span> List&lt;Object&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;Integer&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;String&gt;());</span><br></pre></td></tr></table></figure></li><li><p>持有<code>List&lt;?&gt;</code>的引用后，并不能向其中加入任何元素，读取出来的元素也是<code>Object</code>类型，而不会被自动强转为任何类型。</p></li><li>如果<code>List&lt;?&gt;</code>的行为不能满足需求，可以考虑使用模板方法，或者<code>List&lt;E extends XXX&gt;</code>（bounded wildcard types）</li></ul></li><li>You must use raw types in class literals.<ul><li><code>List.class</code>, <code>String[].class</code>, and <code>int.class</code> are all legal, but <code>List&lt;String&gt;.class</code> and <code>List&lt;?&gt;.class</code> are not.</li></ul></li><li><p><code>instanceof</code>不支持泛型，以下用法是推荐的，但不应该将<code>o</code>强转为<code>List</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Legitimate use of raw type - instanceof operator</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123; <span class="comment">// Raw type</span></span><br><span class="line">  Set&lt;?&gt; m = (Set&lt;?&gt;) o; <span class="comment">// Wildcard type</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相关术语汇总<br><img src="assets/java_generic_terms.png" alt="java_generic_terms.png"></p></li></ul></li><li>Item 24: Eliminate unchecked warnings<ul><li>当出现类型不安全的强制转换时（一般都是涉及泛型，raw type），编译器会给出警告，首先要做的是尽量消除不安全的转换，消除警告</li><li>实在无法消除/确定不会导致运行时的<code>ClassCastException</code>，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>消除警告，但不要直接忽略该警告</li><li>使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>时，应该在注视内证明确实不存在运行时的<code>ClassCastException</code>；同时应该尽量减小其作用的范围，通常是应该为一个赋值语句添加注解</li></ul></li><li><p>Item 25: Prefer lists to arrays</p><ul><li>arrays are covariant(协变): 如果<code>Sub</code>是<code>Super</code>的子类，那么<code>Sub[]</code>也是<code>Super[]</code>的子类</li><li>generics are invariant(不变): 任意两个不同的类<code>Type1</code>和<code>Type2</code>，<code>List&lt;Type1&gt;</code>和<code>List&lt;Type2&gt;</code>之间没有任何继承关系</li><li><p>考虑以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fails at runtime!</span></span><br><span class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">"I don't fit in"</span>; <span class="comment">// Throws ArrayStoreException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Won't compile!</span></span><br><span class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// Incompatible types</span></span><br><span class="line">ol.add(<span class="string">"I don't fit in"</span>);</span><br></pre></td></tr></table></figure></li><li><p>arrays are reified(具体化): array在运行时能知道且强制要求元素的类型</p></li><li>generics are implemented by erasure(non-reifiable): 仅仅在编译时知道元素的类型</li><li>数组和泛型同时使用时会受到很大限制<ul><li>以下语句均不能通过编译：<code>new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]</code>；但是声明是可以的，例如<code>List&lt;String&gt;[] stringLists</code></li></ul></li><li>non-reifiable type: 例如<code>E, List&lt;E&gt;, List&lt;String&gt;</code>，这些类型在运行时的信息比编译时的信息更少</li><li>只有unbounded wildcard type才是reifiable的，如：<code>List&lt;?&gt;, Map&lt;?, ?&gt;</code></li><li>常规来说，不能返回泛型元素的数组，因为会报编译错误：<code>generic array creation errors</code></li><li>当泛型和<code>varargs</code>一起使用时，也会导致编译警告</li><li>有时为了类型安全，不得不做些妥协，牺牲性能和简洁，使用List而不是数组</li><li>把数组强转为non-reifiable类型是非常危险的，仅应在非常确定类型安全的情况下使用</li></ul></li><li>Item 26: Favor generic types<ul><li>当需要一个类成员的数据类型具备一般性时，应该用泛型，这也正是泛型的设计场景之一，不应该用Object类</li><li>但使用泛型有时也不得不进行cast，例如当泛型遇上数组</li><li>总的来说把suppress数组类型强转的unchecked warning比suppress一个标量类型强转的unchecked warning风险更大，但有时出于代码简洁性考虑，也不得不做出妥协</li><li>有时看似与item 25矛盾，实属无奈，Java原生没有List，ArrayList不得不基于数组实现，HashMap也是基于数组实现的</li><li>泛型比使用者进行cast更加安全，而且由于Java泛型的擦除实现，也可以和未做泛型的老代码无缝兼容</li></ul></li><li><p>Item 27: Favor generic methods</p><ul><li><p>泛型方法的类型参数在函数修饰符（可见性/static/final等）和返回值之间，例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>recursive type bound</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using a recursive type bound to express mutual comparability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型方法要比方法使用者进行cast更加安全</p></li></ul></li><li><p>Item 28: Use bounded wildcards to increase API flexibility</p><ul><li>考虑以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Iterable&lt;Integer&gt; integers = ... ;</span><br><span class="line">numberStack.pushAll(integers);</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = ... ;</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></li></ul><p>pushAll和popAll的调用均无法通过编译，因为尽管<code>Integer</code>是<code>Number</code>的子类，但<code>Iterable&lt;Integer&gt;</code>不是<code>Iterable&lt;Number&gt;</code>的子类，这是由泛型的invariant特性导致的，所以<code>Iterable&lt;Integer&gt;</code>不能传入接受<code>Iterable&lt;Number&gt;</code>参数的函数，popAll的使用同理</p><ul><li>bounded wildcards: <code>&lt;? extends E&gt;</code>, <code>&lt;? super E&gt;</code>, PECS stands for producer-extends, consumer-super. 如果传入的参数是要输入给该类型数据的，则应该使用extends，如果是要容纳该类型数据的输出，则应该使用super</li><li>这很好理解，作为输入是要赋值给E类型的，当然应该是E的子类（这里的extends包括E类型本身）；而容纳输出是要把E赋值给传入参数的，当然应该是E的父类（同样包括E本身）</li><li>返回值类型不要使用bounded wildcards，否则使用者也需要使用，这将会给使用者造成麻烦</li><li>代码对于bounded wildcards的使用在使用者那边应该是透明的，即他们不会感知到bounded wildcards的存在，如果他们也需要考虑bounded wildcards的问题，则说明对bounded wildcards的使用有问题了</li><li><p>有时候编译器的类型推导在遇到bounded wildcards会无法完成，这时就需要显示指定类型信息，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span></span>;</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; integers = ... ;</span><br><span class="line">Set&lt;Double&gt; doubles = ... ;</span><br><span class="line"><span class="comment">//Set&lt;Number&gt; numbers = union(integers, doubles); //compile error</span></span><br><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);  <span class="comment">//compile pass</span></span><br></pre></td></tr></table></figure></li><li><p>Comparables are always consumers, so you should always use <code>Comparable&lt;? super T&gt;</code> in preference to <code>Comparable&lt;T&gt;</code>. The same is true of comparators, so you should always use <code>Comparator&lt;? super T&gt;</code> in preference to <code>Comparator&lt;T&gt;</code>.</p></li><li>unbounded type parameter(<code>&lt;E&gt; ... List&lt;E&gt;</code>) v.s. unbounded wildcard(<code>List&lt;?&gt;</code>)：if a type parameter appears only once in a method declaration, replace it with a wildcard.</li></ul></li><li><p>Item 29: Consider typesafe heterogeneous containers</p><ul><li>使用泛型时，类型参数是有限个的，例如<code>List&lt;T&gt;</code>，<code>Map&lt;K, V&gt;</code>，但有时可能需要一个容器，能放入任意类型的对象，但需要具备类型安全性，例如数据库的一行，它的每一列都可能是任意类型的数据</li><li><p>由于<code>Class</code>类从1.5就被泛型化了，所以使得这种需求可以实现，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - API</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通常这样使用的<code>Class</code>对象被称为type token，它传入函数，用来表述编译时和运行时的类型信息</p></li><li><p><code>Favorites</code>的实现也是很简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - implementation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</span><br><span class="line">        favorites.put(type, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意，这里的unbound wildcard并不是应用于Map的，而是应用于Class的类型参数，因此Map可以put key进去，而且key可以是任意类型参数的Class对象</p></li><li>另外，Map的value类型是Object，一旦put到Map中去，其编译期类型信息就丢失了，将通过get方法的动态类型转换（cast）来重新获得其类型信息</li><li>cast方法将检查类型信息，如果是该类型（或其子类），转换将成功，并返回引用，否则将抛出ClassCastException</li><li><p>这一heterogeneous container实现有两个不足</p><ul><li>通过为put方法传入Class的raw type，使用者可以很轻易地破坏类型安全性，解决方案也很简单，在put时也进行一下cast：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Achieving runtime type safety with a dynamic cast</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样做的效果是使得想要破坏类型安全性的put使用者产生异常，而使用get的使用者则不会因为恶意put使用者产生异常。这种做法也被<code>java.util.Collections</code>包中的一些方法使用，例如命名为checkedSet, checkedList, checkedMap的类。</p><ul><li>这个容器内不能放入non-reifiable的类型，例如<code>List&lt;String&gt;</code>，因为<code>List&lt;String&gt;.class</code>是有语法错误的，<code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code>都只有同一个class对象：<code>List.class</code>；另外<code>String[].class</code>是合法的。</li></ul></li><li><code>Favorites</code>使用的类型参数是unbounded的，可以put任意类型，也可以使用bounded type token，使用bounded时可能需要把<code>Class&lt;?&gt;</code>转换为<code>Class&lt;? extends Annotation&gt;</code>，直接用<code>class.cast</code>将会导致unchecked warning，可以通过<code>class.asSubclass</code>来进行转换，例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of asSubclass to safely cast to a bounded type token</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Annotation <span class="title">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = <span class="keyword">null</span>; <span class="comment">// Unbounded type token</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element.getAnnotation(annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>##Enums and Annotations</p><ul><li><p>Item 30: Use enums instead of int constants</p><ul><li>类型安全</li><li>可以为常量提供数据和方法的绑定</li><li>可以遍历</li><li><p>实现建议</p><ul><li>如果是通用的，应该定义为top level enum，否则应定义为内部类</li><li><p>constant-specific method implementations</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific method implementations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS   &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x + y;&#125; &#125;,</span><br><span class="line">    MINUS  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x - y;&#125; &#125;,</span><br><span class="line">    TIMES  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x * y;&#125; &#125;,</span><br><span class="line">    DIVIDE &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x / y;&#125; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结合constant-specific data</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific class bodies and data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS(<span class="string">"+"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    Operation(String symbol) &#123; <span class="keyword">this</span>.symbol = symbol; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> symbol; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If switch statements on enums are not a good choice for implementing con- stant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting external enum types with constant-specific behavior.</p></li></ul></li><li>A minor performance disadvantage of enums over int constants is that there is a space and time cost to load and initialize enum types.</li><li>所以，在安卓设备（手机、平板）上，应该避免使用enum，减小空间和时间的开销</li></ul></li><li>Item 31: Use instance fields instead of ordinals<ul><li>每个enum的常量都有一个<code>ordinal()</code>方法获取其在该enum类型中的位置，但该方法只应该在实现<code>EnumSet</code>, <code>EnumMap</code>等类型的时候被使用，其他情形都不应该被使用</li><li>如果需要为每一个常量绑定一个数据，可以使用instance field实现，如果需要绑定方法，则可以用constant-specific method implementations，参考上一个item</li></ul></li><li>Item 32: Use EnumSet instead of bit fields<ul><li>bit fields的方式不优雅、容易出错、没有类型安全性</li><li>EnumSet则没有这些缺点，而且对于大多数enum类型来说，其性能都和bit field相当</li><li>通用建议：声明变量时，不要用实现类型，应该用接口类型，例如，应该用<code>List&lt;Integer&gt;</code>而不是<code>ArrayList&lt;Integer&gt;</code></li><li>EnumSet并非immutable的，可以通过<code>Conllections.unmodifiableSet</code>来封装为immutable，但是代码简洁性与性能都将受到影响</li></ul></li></ul>]]></content>
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDb索引</title>
      <link href="/2015/10/20/2015-10-20MongoDb%E7%B4%A2%E5%BC%95/"/>
      <content type="html"><![CDATA[<h4 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h4><p>索引是用来加速查询的，类似于数的目录一样。我们要查找某些内容不需要查遍整个数据库，只需要先在索引中查找，找到相应索引之后根据索引找到指向的文档。<br>创建索引使用ensureIndex函数，<code>db.people.ensureIndex({&#39;username&#39;:1})</code>,1代表对索引内容进行正向排序，-1代表对索引内容逆向排序。对某个键创建的索引会加速以该键为查询条件的查询，对其他查询没有帮助。索引创建既可以针对单个键创建也可以针对多个键创建，例如<code>db.people.ensureIndex({&#39;name&#39;:1,age:-1,&#39;sex&#39;:1})</code>其作用原理与sort相同(由前到后逐个匹配)。如果创建了我们上面所看到的索引实际上是有了<code>{name:1}</code>,<code>{name:1,age:-1}</code>,<code>{name:1,age:-1,sex:1}</code>三个索引，使用{age:-1}等索引的查询不会得到优化。<br>创建索引并不是只有优点的，他的缺点就是每次插入，更新，删除都会产生额外的开销用来更新索引。所以我们要根据实际情况合理的创建索引，通常我们要考虑实际情况中都需要经常对哪些键查询，然后对该查询字段创建索引，每个集合的最大索引个数为64个</p><h5 id="注意索引顺序"><a href="#注意索引顺序" class="headerlink" title="注意索引顺序"></a>注意索引顺序</h5><p>当我们创建多键索引时要分清主次，一般我们可以这样认为，当根据我们创建的多键索引进行查询时会先根据前面的条件筛选，将结果用于下一次筛选。所以创建多键索引时我们要将主要索引条件放在前面，建立索引时要考虑如下问题：</p><ol><li>会做什么样的查询，其中哪些键需要索引</li><li>每个键的索引方向是怎样的</li><li>如何应对拓展，有没有种不同的键的排列可以是常用数据更多地保存在内存中</li></ol><a id="more"></a><h5 id="索引内嵌文档"><a href="#索引内嵌文档" class="headerlink" title="索引内嵌文档"></a>索引内嵌文档</h5><p>为内嵌文档建立索引和为普通的键创建索引没有什么区别，只是在索引内嵌文档的字段的时候使用<strong>点表达式</strong>，也可以和普通键索引组成复合索引</p><h5 id="为排序创建索引"><a href="#为排序创建索引" class="headerlink" title="为排序创建索引"></a>为排序创建索引</h5><p>随着集合的增长，需要针对大量的排序做索引。因为如果排序实在内存中完成的，如果数据量特别大超出内存的限制就是报错。如果没有对数据进行sort，默认就是查询出来的顺序，所以创建索引之后查询出来的顺序就是排序之后的结果</p><h5 id="索引名称"><a href="#索引名称" class="headerlink" title="索引名称"></a>索引名称</h5><p>每一个索引都有一个字符串类型的名字用来唯一标示，数据库通过这个名字来删除或操作索引。默认情况索引名类似keyname1_dir1_keyname2_dir2…形式（keynameX代表索引的键，dirX代表索引的方向）。我们可以通过ensureIndex的第二个参数来指定索引的名字<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.ensureIndex(&#123;<span class="string">'name'</span>:<span class="number">1</span>,<span class="string">'age'</span>:<span class="number">-1</span>&#125;,&#123;<span class="string">'name'</span>:<span class="string">'index1'</span>&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>唯一所以可以确保集合的每一个文档的指定键都有唯一的值，相当于关系型数据库中的unique键。要创建唯一索引需要在ensureIndex的第二个参数中指定unique为true。在创建集合是自动给我们创建了<code>_id</code>唯一索引，与普通唯一索引的区别是不能被删除<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.ensureIndex(&#123;<span class="string">'username'</span>:<span class="number">1</span>&#125;,&#123;<span class="string">'unique'</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>可能当我们创建唯一索引的时候，有些值已经有重复了，这时候索引的创建就会失败。但是我们可以使用dropDups选项，这样可以保留发现的第一个文档，将其他重复文档删除<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.ensureIndex(&#123;<span class="string">'username'</span>:<span class="number">1</span>&#125;,&#123;<span class="string">'unique'</span>:<span class="literal">true</span>, <span class="string">'dropDups'</span>:<span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>创建符合唯一索引的时候，单个键的值可以相同，只要所有键的值组合起来不同就好</p><h4 id="强制使用索引"><a href="#强制使用索引" class="headerlink" title="强制使用索引"></a>强制使用索引</h4><p>如果发现MongoDb没有使用预期的索引，可以用hint强制使用某个索引。例如希望使用<code>{&#39;username&#39;:1,&#39;age&#39;:1}</code>索引<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.find(&#123;<span class="string">'age'</span>:<span class="number">14</span>,<span class="string">'username'</span>:<span class="string">'nicolas'</span>&#125;).hint(&#123;<span class="string">'username'</span>:<span class="number">1</span>,<span class="string">'age'</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>多数情况下并没有这么做的必要，MongoDb会非常智能的选择使用哪个索引。在初次查询时会尝试各种查询方案，最优方案会被记录下来，还会定期重试其他方案，防止建立新的索引之后方案不再是最优</p><h4 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h4><p>索引的原信息存储在每个数据库的system.indexes集合中，不能对该集合插入或删除文档，操作只能通过ensureIndex和dropIndex进行<br>建立索引既耗时有费力，还需要消耗很多资源，可以使用<code>{&#39;background&#39;:true}</code>选项是这个过程在后台完成，同时正常处理请求。一般来说为已有文档创建索引比先创建索引再插入所有文档要稍快一些。不管怎么说在无关紧要的时刻创建索引是最好的选择<br>当索引没用的时候可以通过dropIndex选项删除索引,删除依据是创建索引的条件<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.people.dropIndex(&#123;<span class="string">'username'</span>:<span class="number">1</span>,<span class="string">'age'</span>:<span class="number">-1</span>&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="地理空间索引"><a href="#地理空间索引" class="headerlink" title="地理空间索引"></a>地理空间索引</h4><p>MongoDb为坐标平面提供了专门的索引成为地理空间索引，可以找出离某一坐标平面最近的点。创建地理空间索引同样适用ensureIndex选项，只不过参数不是1或-1而是2d。建立索引的键的值必须是包含两个元素的数组或包含两个键的内嵌文档(键名可以随意)。地理空间索引默认的范围是180·-180，如果想要指定大小可以使用第二个参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.start.insureIndex(&#123;<span class="string">'light-year'</span>:<span class="string">'2d'</span>&#125;,&#123;<span class="string">'min'</span>:<span class="number">-1000</span>,<span class="string">'max'</span>:<span class="number">1000</span>&#125;)</span><br></pre></td></tr></table></figure></p><p>地理空间索引的查询和普通的find查询差别不大，只不过使用了<code>$near</code>，需要两个目标值的数组作为参数，默认返回100个距离给点坐标最近的文档，可以使用limit进行限制。还可以使用<code>$maxDistance</code>限定查询的最大距离<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$near</span>:[<span class="number">40</span>,<span class="number">-73</span>], <span class="attr">$maxDistance</span>:<span class="number">40</span>&#125;&#125;).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure></p><p>MongoDb不仅可以根据距离查询，还可以根据形状查询，目前支持矩形,圆形查询和多边形查询，需要用到<code>$within</code><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要给出矩形左上角和右下角坐标</span></span><br><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$within</span>:&#123;<span class="attr">$box</span>:&#123;[<span class="number">10</span>,<span class="number">30</span>],[<span class="number">15</span>,<span class="number">40</span>]&#125;&#125;&#125;&#125;)</span><br><span class="line"><span class="comment">//需要圆的原点坐标和半径</span></span><br><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$within</span>:&#123;<span class="attr">$circle</span>:&#123;[<span class="number">10</span>,<span class="number">20</span>],<span class="number">40</span>&#125;&#125;&#125;&#125;)</span><br><span class="line"><span class="comment">//多边形各个点的坐标</span></span><br><span class="line">db.map.find(&#123;<span class="string">'gps'</span>:&#123;<span class="attr">$within</span>:&#123;<span class="attr">$polygon</span>:[[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">6</span>,<span class="number">3</span>]]&#125;&#125;&#125;)</span><br></pre></td></tr></table></figure></p><p>我们可以组合地理空间索引和普通索引，这样可以满足继续要地里空间限制条件组合普通限制条件的查找<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.ensureIndex(&#123;<span class="string">'location'</span>:<span class="string">'2d'</span>,<span class="string">'desc'</span>:<span class="number">1</span>&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> MongoDb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDb查询</title>
      <link href="/2015/10/18/2015-10-20MongoDb%E6%9F%A5%E8%AF%A2/"/>
      <content type="html"><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>使用find或者findOne对数据库执行查询</li><li>使用<code>$</code>条件实现范围，集合包含，不等式和其他查询</li><li>使用<code>$where</code>子句用户复杂查询</li><li>查询会返回一个数据库游标，只有在需要数据的时候才会惰性的返回文档</li><li>针对游标执行的元操作，比如忽略一定数量的结果，限定返回结果的数量，对结果进行排序</li></ul><h4 id="find简介"><a href="#find简介" class="headerlink" title="find简介"></a>find简介</h4><blockquote><p>db.users.find()<br>db.users.find({‘name’:’nicolas’,’age’:20})</p></blockquote><p>不带参数的find会返回全部文档。find可以指定查询文档，只返回匹配查询条件的文档，当查询文档含有多个K-V时连接条件为AND,第二个查询语句会返回name为nicolas并且age为20的文档</p><ul><li>指定返回的键<blockquote><p>db.users.find({},{‘name’:1,’age’:0})</p></blockquote></li></ul><p>有时我们并不需要将文档中的所有K-V都返回，这种情况我们可以使用find函数的第二个参数指定要返回的键。其中1代表将返回的文档按照该字段正向排序，0代表将返回的文档按照该字段逆向排序</p><ul><li>限制<blockquote><p>db.stock.find({‘in_stock’:’this.num_sold’})</p></blockquote></li></ul><p>查询文档必须是常量（在自己代码里可以使正常的变量），但是不能引用文档中其他键的值。故上面的这个查询是错误的</p><h4 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h4><h5 id="比较操作符"><a href="#比较操作符" class="headerlink" title="比较操作符"></a>比较操作符</h5><p><code>$gt</code>,<code>$gte</code>,<code>$gt</code>,<code>gte</code>是全部的比较操作符，分别对应<code>&lt;</code>,<code>&lt;=</code>,<code>&gt;</code>,<code>&gt;=</code>，可以将其组合起来查找一个范围的值。其中对于日期查询尤为有用，因为对日期的精确匹配终究是徒劳的。</p><blockquote><p>db.users.find({‘age’:{$lt:30,$gt:20}) 查找年龄大于20小于30的人</p><p>start = new Date(“01/01/2007”)<br>db.users.find(‘registered’:{$lt:start}) 查找注册日期在2007年1月1日之前的用户</p></blockquote><a id="more"></a><h5 id="OR查询"><a href="#OR查询" class="headerlink" title="OR查询"></a>OR查询</h5><ul><li><p><code>$in</code>可以用来查询键值在给定数组中的文档，与之相反的是<code>$nin</code>。这两者用来对单个键做OR查询</p><blockquote><p>db.users.find({‘name’:{$in:[‘nicolas’,’windylee’]}) 返回name为nicolas或windylee的文档</p></blockquote></li><li><p><code>$or</code>可以对多个键做OR查询，<code>$or</code>接受一个包含所有可能条件的数组作为参数，只要符合数组中任何一个元素的条件就会被查询出来，<code>$or</code>可以包含其他条件。普通的and兴的查询，总是尽可能的用最少的条件来限定结果的范围，or型的查询真好相反，第一个条件尽可能地匹配更多的文档</p><blockquote><p>db.users.find({$or:[{‘name’:{$in:[‘nicolas’,’windylee’]}},’age’:20]}) 查询name为nicolas或windylee或age为20的用户</p></blockquote></li></ul><h5 id="not查询"><a href="#not查询" class="headerlink" title="$not查询"></a><code>$not</code>查询</h5><p><code>$not</code>是元条件句，可以用在任何其他条件之上，表示对其他条件的结果取反。经常与正则表达式联合使用，用来查询不匹配正则表达式的文档</p><blockquote><p>db.users.find({‘age’:{$not:{$mod:[5,1]}}) 查询age值模5余数不为1的文档</p></blockquote><h5 id="条件句的规则"><a href="#条件句的规则" class="headerlink" title="条件句的规则"></a>条件句的规则</h5><p>条件句是内层文档的键，修改器是外层文档的键，可对一个键应用多个条件，但是一个键不能对应多个更新修改器。例如<code>{$inc:{&#39;age&#39;:20},$set:{&#39;age&#39;:40}}</code>修改了age两次</p><h4 id="特定于类型的查询"><a href="#特定于类型的查询" class="headerlink" title="特定于类型的查询"></a>特定于类型的查询</h4><h5 id="空值查询"><a href="#空值查询" class="headerlink" title="空值查询"></a>空值查询</h5><ul><li>null<br>null不仅能够匹配到键值为null的文档，他还能匹配缺少这个键的所有文档</li><li><code>$exists</code><br>如果仅仅想匹配键值为null的文档，就需要使用到该关键字<blockquote><p>db.users.find({‘name’:{$exists:true}}) 返回name值不为空的文档</p></blockquote></li></ul><h5 id="查询数组"><a href="#查询数组" class="headerlink" title="查询数组"></a>查询数组</h5><ul><li><p><code>$ll</code><br>返回含有<code>$all</code>指向数组所有元素的文档</p><blockquote><p>db.users.find(‘course’:{$all:[‘english’,’chinese’]}) 返回课程含有english和chinese的用户</p></blockquote></li><li><p><code>$size</code><br>返回数组长度为指定大小的文档，<code>$size</code>不能与其他查询子句组合(比如<code>$gt</code>)</p><blockquote><p>db.users.find({‘course’:{$size:3}}) 返回选了3门课的文档</p></blockquote></li><li><p><code>$slice</code><br>返回一个数组的子集合。可以接受一个整型n，整数表示返回数组的前n条数据，负数表示返回数组的后n条数据；可以接受一个数组，数组的第一个元素表示偏移量，第二个元素表示获取的元素数量。除非特别声明，<code>$slice</code>返回文档中的所有键</p><blockquote><p>db.blog.posts.findOne(criteria,{‘comments’:{$slice,[1,2]}}) 默认会返回posts中的所有字段</p></blockquote></li></ul><h5 id="查询内嵌文档"><a href="#查询内嵌文档" class="headerlink" title="查询内嵌文档"></a>查询内嵌文档</h5><p>如果存在如下文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">'name'</span>:&#123;</span><br><span class="line">    <span class="string">'first'</span>:<span class="string">'Jone'</span></span><br><span class="line">        <span class="string">'last'</span>:<span class="string">'Schmoe'</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="string">'age'</span>:<span class="number">45</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>要查询姓名为Jon Schmoe的人可以这样<code>db.people.find({&#39;name&#39;:{&#39;first&#39;:&#39;Jon&#39;,&#39;last&#39;:&#39;Schmoe&#39;}})</code>这种方式采用全部匹配的规则，即查询条件中要包含内嵌文档的所有键，如果name内嵌文档中增加middle字段则上述查询条件就不起作用了。如果只想根据部分字段进行查询则需要点表达式<code>db.people.find({&#39;name.first&#39;:&#39;Joe&#39;,&#39;name.last&#39;:&#39;Schmoe&#39;})</code>，这也是带插入的文档不能包含’.’的原因<br>当文档变负责以后，即内嵌文档为数组时，如果有如下文档<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">'content'</span>:<span class="string">'...'</span></span><br><span class="line">    <span class="string">'comments'</span>:[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'author'</span>:<span class="string">'joe'</span>,</span><br><span class="line">            <span class="string">'score'</span>:<span class="number">3</span>,</span><br><span class="line">            <span class="string">'comment'</span>:<span class="string">'nice post'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="string">'author'</span>:<span class="string">'mary'</span>,</span><br><span class="line">            <span class="string">'score'</span>:<span class="number">6</span>,</span><br><span class="line">            <span class="string">'comment'</span>:<span class="string">'terrible post'</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果继续使用点表达式<code>db.blog.find({&#39;comments.author&#39;:&#39;jone&#39;,&#39;score&#39;:6})</code>则第一个条件会在comments1中找到，第二个条件会在comments2中找到，所以会返回我们上面看到的文档。若要正确指定一组条件我们需要<code>$elemMatch</code>，这种模糊的命名条件句能用来部分指定匹配数组中的单个嵌入文档的限定条件，所以正确的写法应该是这样的<code>db.blog.find({&#39;comments&#39;:{$eleMatch:{&#39;author:&#39;Jone&#39;,&#39;score&#39;:&#39;6}}})</code></p><h4 id="where查询"><a href="#where查询" class="headerlink" title="$where查询"></a><code>$where</code>查询</h4><p>我们上面说过find的查询条件只能是常量，不能是文档中的值，如果我们查询条件为文档中的数据，那这时候我们就需要<code>$where</code>子句了，例如<code>db.foo.find({$where:&#39;this.x+this.y=10&#39;})</code>。<code>$where</code>速度要慢很多，除非必要不要使用该条件。</p><h4 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h4><p>数据库使用游标来返回find的执行结果，客户端队游标的实现通常能够对最终结果进行有效的控制，可以限制结果的数量，略过部分结果，根据任意方向任意键的组合对结果进行各种排序，或者执行其他一些功能强大的操作。当调用find的时候并不立即查询数据库，而是等待真正开始要求获得结果的时候才发送查询，这样我们就可以在执行之前给查询附加额外的选项</p><h5 id="limit-skip-sort"><a href="#limit-skip-sort" class="headerlink" title="limit, skip, sort"></a>limit, skip, sort</h5><p>limit限定返回结果的上限，skip跳过前n个匹配的文档；sort指定排序的键和排序条件，1为正序排序，-1为降序排序，如果指定了多个键，则按照多个键的顺序逐个排序，例如要按照username升序和age降序排序<code>db.c.find().sort({&#39;username&#39;:1,&#39;age&#39;:-1})</code>。find函数返回游标，这三个函数都可以组成链式操作。如果一个键对应不同的类型，则规定的类型顺序：最小值 &lt; null &lt; 数字（整形，长整形，双精度）&lt; 字符串 &lt; 对象/文旦 &lt; 数组 &lt; 二进制数据 &lt; 对象ID &lt; 布尔型 &lt; 日期型 &lt; 时间戳 &lt; 正则表达式 &lt; 最大值</p><h5 id="避免使用skip略过大量结果"><a href="#避免使用skip略过大量结果" class="headerlink" title="避免使用skip略过大量结果"></a>避免使用skip略过大量结果</h5><p>使用skip略过大量结果就会使操作变得非常缓慢，几乎所有的数据库都有这个问题，所以我们应尽量避免使用skip</p><ul><li>不用skip对结果分页<br>分页最简单的方式就是结合使用limit和skip两个函数，但我们可以有更好的解决方案。例如我们最获取文档时一般按照时间顺序进行排序，我们可以获取第一次获取的文档最后一个的时间，然后可以利用该时间值最为查询条件来获取下一页</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> latest=<span class="literal">null</span></span><br><span class="line"><span class="keyword">while</span>(page1.hasNext())&#123;</span><br><span class="line">latest=page1.next();</span><br><span class="line">    display(latest)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> page2=db.foo.find(&#123;<span class="string">'date'</span>:&#123;<span class="attr">$gt</span>:latest.date&#125;).sort(<span class="string">'date'</span>:<span class="number">-1</span>).limit(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><ul><li>随机选取文档<br>一般做法是要查询文档总数，然后在0~n中选择一个随机数，使用skip跳过这些随机数来获取随机的一个文档。这样查询总数和使用skip略过文档都需要花费大量时间。我们可以再一开始就在文档中插入一个随机数的键，然后根据该随机数获取随机文档</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.people.insert(&#123;<span class="string">'name'</span>:<span class="string">'nicolas'</span>,<span class="string">'random'</span>:<span class="built_in">Math</span>.random()&#125;)</span><br><span class="line">db.people.findOne(&#123;<span class="attr">random</span>:&#123;<span class="attr">$lt</span>:<span class="built_in">Math</span>.random()&#125;&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> MongoDb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MongoDb创建，删除，更改</title>
      <link href="/2015/10/18/2015-10-20MongoDb%E5%88%9B%E5%BB%BA-%E5%88%A0%E9%99%A4-%E6%9B%B4%E6%94%B9/"/>
      <content type="html"><![CDATA[<h6 id="插入并保存文档"><a href="#插入并保存文档" class="headerlink" title="插入并保存文档"></a>插入并保存文档</h6><blockquote><p>db.foo.insert({‘bar’:baz”})</p></blockquote><p>会自动给文档增加一个”_id”键(如果原来没有的话)。驱动程序会将数据转换成BSON形式，数据库解析BSON，检验是否包含’_id’键，并且文档长度不能超过4MB<br>删除文档</p><blockquote><p>db.users.remove()</p></blockquote><p>会删除users集合中的所有文档，但是不会删除集合本身，原来的索引也会保留。remove函数可以接受一个查询文档作为可选参数，只有符合条件的文档才会被删除，例如 &gt;db.mailing.list.remove({‘opt-out’:true})<br>删除集合</p><blockquote><p>db.users.drop()</p></blockquote><p>会删除users集合，所有的索引也会被删除，速度要比remove()快很多</p><h6 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h6><p>文档存入数据库以后，可以使用update方法来修改他，update有两个参数，一个是查询文档，用来找出要更新的文档，另一个是修改器文档，描述对找到的文档做哪些更改<br><a id="more"></a></p><ul><li>文档替换<blockquote><p>db.users.update({‘name’:’nicolas’},{‘age’:20})</p></blockquote></li></ul><p>完全用一个文档去替换另一个文档，不使用任何关键字，默认文档会变成和第二个参数文档完全一样的形式，例子中更新之后文档中就只有age字段</p><ul><li>使用修改器</li></ul><p>对字段值修改不需要改变文档的大小，修改速度非常快。对数组修改可能需要改变文档的大小，修改速度回慢一下<br><code>$inc</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$age:{‘age’,1}})</p></blockquote><p>更新之后age字段会增加1，当为负数时自减。当键不存在时创建一个键。只能用于整数，长整数和说京都浮点数</p><p><code>$set</code></p><blockquote><p>db.user.update({‘name’:’nicolas’},{$set:{‘age’:20}}) </p></blockquote><p>$set用来指定一个键的值，如果这个键不存在就创建他。$set甚至可以修改键的数据类型。$set可以修改内嵌文档，只要将内嵌字段用”.”连接即可，类似于引用对象变量</p><p>`$unset·</p><blockquote><p>db.users.update({‘name’:’nicolas’},{$unset:{‘age’:1}})</p></blockquote><p>会将age的键删除</p><p><code>$push</code><br>如果指定的键已经存在，会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组</p><p><code>$ne</code></p><blockquote><p>db.users.update({‘course’:{$ne:’english’}},{$push:{‘course’:’english’}})    </p></blockquote><p>当course字段中不存在english值时，会向course字段数组中放入english</p><p><code>$addToSet</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$addToSet:{‘courses’:’english’}})</p></blockquote><p>当name为nicolas中的course字段数组中不包括english是向其中添加english</p><p><code>$each</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$addToSet:{‘course’:{$each:[‘english’,’chinese’,’math’]}}})    </p></blockquote><p>如果不存在这像个课程就像course字段中一次添加这些课程</p><p><code>$pop</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$pop:{‘course’:1}})    </p></blockquote><p>可以冲数组的任何一段删除元素，1从数组末尾删除一个元素，-1从数组头部删除</p><p><code>$pull</code></p><blockquote><p>db.users.update({‘name’:’nicolas’},{$pull:{‘course’:’english’}})    </p></blockquote><p>根据特定条件删除元素，例子中删除course数组中值为english的元素</p><p><code>$</code></p><blockquote><p>db.blog.update({‘post’:1},{$inc,{‘comments.0.votes’:1}})</p></blockquote><p>使comments数组下标为0的元素中votes字段的值自增1</p><blockquote><p>db.blog.update({‘comments.author’:’nicolas’},{$inc,{‘comments.$.votes’:1}})</p></blockquote><p>首先会查找comments数组中author为nicolas的元素，记录下其下标。并改变该下标中元素的votes值为1</p><ul><li>upsert</li></ul><blockquote><p>db.person.update({‘name’:’windylee’},{$set:{‘age’:21,’sex’:’man’}},true)</p></blockquote><p>upsert是一种特殊的更新，要是没有文档符合更新调价，就会以这个条件和更新文档为基础创建一个新的文档，如果匹配则正常更新。将update的第三个参数设置为true即可开启此功能。例子中将会插入name，age，sex三个字段</p><ul><li>更新多个文档</li></ul><p>默认情况下，更新只能对符合匹配条件的第一个文档执行操作，要使所有匹配到的文档都得到更新，可以设置update的第四个参数为true</p>]]></content>
      
      <categories>
          
          <category> MongoDb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Database </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>markdown新手指南</title>
      <link href="/2015/09/21/2015-09-21markdown%E6%96%B0%E6%89%8B%E6%8C%87%E5%8D%97/"/>
      <content type="html"><![CDATA[<h2 id="Markdown简介"><a href="#Markdown简介" class="headerlink" title="Markdown简介"></a>Markdown简介</h2><h3 id="Markdown是什么"><a href="#Markdown是什么" class="headerlink" title="Markdown是什么"></a>Markdown是什么</h3><p><strong>Markdown</strong>是一种极简的标记语言，可以轻易的将文本转化为HTML。语法非常容易学习，简单到每个人都可以在5分钟之内学会。Markdown之所以越来越流行，不是因为它复杂，而是因为他足够简单。</p><h3 id="Markdown优点"><a href="#Markdown优点" class="headerlink" title="Markdown优点"></a>Markdown优点</h3><ul><li>纯文本编写，兼容性很强，可以使用所有文本编辑器打开</li><li>让写作者专注与文字而不是排版</li><li>格式转换方便，可以将MarkDown文本轻易转换为HTML，电子书等</li></ul><h3 id="与word对比"><a href="#与word对比" class="headerlink" title="与word对比"></a>与word对比</h3><ul><li>使用word写文档需要浪费大量时间在word本身上，特别是那80%我们用不到的功能</li><li>浪费时间在排版上，需要花费大量时间用在调整粗体或者斜体，黑体还是宋体上</li></ul><h2 id="Markdown语法"><a href="#Markdown语法" class="headerlink" title="Markdown语法"></a>Markdown语法</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p>标题有两种方式：Setext方式和Atx方式<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Setext方式，三个或更多的=或者-</span><br><span class="line">大标题</span><br><span class="line">===</span><br><span class="line">小标题</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h1 id="大标题"><a href="#大标题" class="headerlink" title="大标题"></a>大标题</h1><h2 id="小标题"><a href="#小标题" class="headerlink" title="小标题"></a>小标题</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Atx方式，在标题前面加上#号，总共分为6个等级，#号越多，标题字号越小</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><a id="more"></a><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>无序列表，只需要在文字前面加上<code>-</code>,<code>+</code>或者<code>×</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 文本<span class="number">1</span></span><br><span class="line">- 文本<span class="number">2</span></span><br><span class="line">- 文本<span class="number">3</span></span><br></pre></td></tr></table></figure></p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><p>有序列表，只需要在文字前面加上<code>1.</code>， <code>2.</code>， <code>3.</code>等。前面序号只是代表语法标记，真正序号与我们所写的内容并无实际关系，例如：我将文本3的序号标记为4，但效果仍然显示为3。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 文本<span class="number">1</span></span><br><span class="line"><span class="number">2</span>. 文本<span class="number">2</span></span><br><span class="line"><span class="number">4</span>. 文本<span class="number">3</span></span><br></pre></td></tr></table></figure></p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><p>嵌套列表，<code>-</code>，<code>+</code>，<code>*</code>可循环使用，但符号之后的空格不能少，符号之前的空格也不能少<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- 一级列表</span><br><span class="line">  + 二级列表</span><br><span class="line">  + 二级列表</span><br><span class="line">    × 三级列表</span><br><span class="line">      - 四级列表</span><br><span class="line">- 一级列表</span><br><span class="line">```language</span><br></pre></td></tr></table></figure></p><ul><li>一级列表<ul><li>二级列表</li><li>二级列表<ul><li>三级列表<ul><li>四级列表</li></ul></li></ul></li></ul></li><li>一级列表</li></ul><h3 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h3><p>链接，插入链接只需要使用<code>[显示文本](连接地址 Tooltips)</code>这样的语法实现，Tooltips可以省略，Tooltips表示鼠标悬浮时候的文本提示<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](http:<span class="comment">//www.baidu.com)</span></span><br></pre></td></tr></table></figure></p><p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p><p>图片，插入图片只需要使用<code>![](图片链接 Tooptips)</code>这样的语法实现，Tooltips可以省略<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](http:<span class="comment">//ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg "埃菲尔铁塔")</span></span><br></pre></td></tr></table></figure></p><p><img src="http://ww4.sinaimg.cn/bmiddle/aa397b7fjw1dzplsgpdw5j.jpg" alt="" title="埃菲尔铁塔"></p><p>自动链接，直接显示链接网址，点击可以跳转<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http:<span class="comment">//www.sina.com&gt;</span></span><br></pre></td></tr></table></figure></p><p><a href="http://www.sina.com" target="_blank" rel="noopener">http://www.sina.com</a></p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>在我们写作的时候经常需要引用他人的文字，这时候就需要用到引用这个格式。这时候我们就需要在文字前面加上<code>&gt;</code>来表示引用内容。可以嵌套使用表示多级引用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 以眼看世界，即使站的最高，世界还是很小；以心看世界，即使身处局限，世界依然很大</span><br></pre></td></tr></table></figure></p><blockquote><p>以眼看世界，即使站的最高，世界还是很小；以心看世界，即使身处局限，世界依然很大</p></blockquote><h3 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h3><p>被<code>**</code>包含的表示<em>斜体</em>，被<code>****</code>包含的表示<strong>粗体</strong>，其中的<code>*</code>也可以换成<code>_</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">**一个人来到田纳西**</span><br><span class="line">__毫无疑问__</span><br><span class="line">*我做的馅饼</span><br><span class="line">是全天下*</span><br><span class="line">_最好吃的_</span><br></pre></td></tr></table></figure></p><p><strong>一个人来到田纳西</strong><br><strong>毫无疑问</strong><br><em>我做的馅饼<br>是全天下</em><br><em>最好吃的</em></p><h3 id="分隔符"><a href="#分隔符" class="headerlink" title="分隔符"></a>分隔符</h3><p><code>***</code>表示page break；<code>---</code>表示section break；<code>___</code>表示sentence break；<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">page <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">***</span><br><span class="line">section <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">sentence <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">___</span><br></pre></td></tr></table></figure></p><p>page break</p><hr><p>section break</p><hr><p>sentence break</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>使用` <figure class="highlight plain"><figcaption><span>&#123;codeblock&#125;``` `表示代码块，language表示代码块中代码的语言类型，在&#123;codeblock&#125;中插入要写的代码</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```java</span><br><span class="line">    ```java</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">``` `</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特殊表示"><a href="#特殊表示" class="headerlink" title="特殊表示"></a>特殊表示</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~删除元素~~</span><br><span class="line">++下划线++</span><br><span class="line">==高亮显示==</span><br></pre></td></tr></table></figure><p><del>删除元素</del><br>++下划线++<br>==高亮显示==</p>]]></content>
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
