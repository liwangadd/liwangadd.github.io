<!DOCTYPE html><html class="theme-next gemini use-motion" lang="zh-CN"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css"><link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css"><link rel="apple-touch-icon" sizes="180x180" href="http://windylee-blog.oss-cn-beijing.aliyuncs.com/4a80bfd22936342467d9b2d9f19a8a1f.jpeg?v=6.6.0"><link rel="icon" type="image/png" sizes="32x32" href="http://windylee-blog.oss-cn-beijing.aliyuncs.com/4a80bfd22936342467d9b2d9f19a8a1f.jpeg?v=6.6.0"><link rel="icon" type="image/png" sizes="16x16" href="http://windylee-blog.oss-cn-beijing.aliyuncs.com/4a80bfd22936342467d9b2d9f19a8a1f.jpeg?v=6.6.0"><link rel="mask-icon" href="http://windylee-blog.oss-cn-beijing.aliyuncs.com/4a80bfd22936342467d9b2d9f19a8a1f.jpeg?v=6.6.0" color="#222"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Gemini",version:"6.6.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!0,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><meta name="description" content="Effective Java一书笔记对象的创建与销毁Item 1: 使用static工厂方法，而不是构造函数创建对象仅仅是创建对象的方法，并非Factory Pattern优点命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutab"><meta name="keywords" content="Java"><meta property="og:type" content="article"><meta property="og:title" content="effictive-java读书笔记"><meta property="og:url" content="http://windylee.cn/posts/636894a/index.html"><meta property="og:site_name" content="windylee"><meta property="og:description" content="Effective Java一书笔记对象的创建与销毁Item 1: 使用static工厂方法，而不是构造函数创建对象仅仅是创建对象的方法，并非Factory Pattern优点命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutab"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://windylee.cn/posts/636894a/assets/java_generic_terms.png"><meta property="og:updated_time" content="2018-03-22T01:26:08.134Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="effictive-java读书笔记"><meta name="twitter:description" content="Effective Java一书笔记对象的创建与销毁Item 1: 使用static工厂方法，而不是构造函数创建对象仅仅是创建对象的方法，并非Factory Pattern优点命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutab"><meta name="twitter:image" content="http://windylee.cn/posts/636894a/assets/java_generic_terms.png"><link rel="alternate" href="/atom.xml" title="windylee" type="application/atom+xml"><link rel="canonical" href="http://windylee.cn/posts/636894a/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>effictive-java读书笔记 | windylee</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">windylee</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="http://windylee.cn/posts/636894a/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="windylee"><meta itemprop="description" content="Stay hungry, stay foolish"><meta itemprop="image" content="http://windylee-blog.oss-cn-beijing.aliyuncs.com/4a80bfd22936342467d9b2d9f19a8a1f.jpeg"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="windylee"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">effictive-java读书笔记</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2015-10-20 15:50:22" itemprop="dateCreated datePublished" datetime="2015-10-20T15:50:22+08:00">2015-10-20</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2018-03-22 09:26:08" itemprop="dateModified" datetime="2018-03-22T09:26:08+08:00">2018-03-22</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/读书笔记/" itemprop="url" rel="index"><span itemprop="name">读书笔记</span></a></span> </span><span class="post-comments-count"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-comment-o"></i> </span><a href="/posts/636894a/#comments" itemprop="discussionUrl"><span class="post-meta-item-text">评论数：</span> <span class="post-comments-count gitment-comments-count" data-xid="/posts/636894a/" itemprop="commentsCount"></span></a></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">23k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">20 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h1 id="Effective-Java一书笔记"><a href="#Effective-Java一书笔记" class="headerlink" title="Effective Java一书笔记"></a>Effective Java一书笔记</h1><h2 id="对象的创建与销毁"><a href="#对象的创建与销毁" class="headerlink" title="对象的创建与销毁"></a>对象的创建与销毁</h2><ul><li>Item 1: 使用static工厂方法，而不是构造函数创建对象<br>仅仅是创建对象的方法，并非Factory Pattern<ul><li>优点<ul><li>命名、接口理解更高效，通过工厂方法的函数名，而不是参数列表来表达其语义</li><li>Instance control，并非每次调用都会创建新对象，可以使用预先创建好的对象，或者做对象缓存；便于实现单例；或不可实例化的类；对于immutable的对象来说，使得用<code>==</code>判等符合语义，且更高效；</li><li>工厂方法能够返回任何返回类型的子类对象，甚至是私有实现；使得开发模块之间通过接口耦合，降低耦合度；而接口的实现也将更加灵活；接口不能有static方法，通常做法是为其再创建一个工厂方法类，如Collection与Collections；</li><li>Read More: Service Provider Framework</li></ul></li><li>缺点<ul><li>仅有static工厂方法，没有public/protected构造函数的类将无法被继承；见仁见智，这一方面也迫使开发者倾向于组合而非继承；</li><li>Javadoc中不能和其他static方法区分开，没有构造函数的集中显示优点；但可以通过公约的命名规则来改善；</li></ul></li><li>小结<br>static工厂方法和public构造函数均有其优缺点，在编码过程中，可以先考虑一下工厂方法是否合适，再进行选择。</li></ul></li><li>Item 2: 使用当构造函数的参数较多，尤其是其中还有部分是可选参数时，使用Builder模式<ul><li>以往的方法<ul><li>Telescoping constructor：针对可选参数，从0个到最多个，依次编写一个构造函数，它们按照参数数量由少到多逐层调用，最终调用到完整参数的构造函数；代码冗余，有时还得传递无意义参数，而且容易导致使用过程中出隐蔽的bug；</li><li>JavaBeans Pattern：灵活，但是缺乏安全性，有状态不一致问题，线程安全问题；</li></ul></li><li>Builder Pattern<ul><li>代码灵活简洁；具备安全性；</li><li>immutable</li><li>参数检查：最好放在要build的对象的构造函数中，而非builder的构建过程中</li><li>支持多个field以varargs的方式设置（每个函数只能有一个varargs）</li><li>一个builder可以build多个对象</li><li>Builder结合泛型，实现Abstract Factory Pattern</li><li>传统的抽象工厂模式，是用Class类实现的，然而其有缺点：newInstance调用总是去调用无参数构造函数，不能保证存在；newInstance方法会抛出所有无参数构造函数中的异常，而且不会被编译期的异常检查机制覆盖；可能会导致运行时异常，而非编译期错误；</li></ul></li><li>小结<br>Builder模式在简单地类（参数较少，例如4个以下）中，优势并不明显，但是需要予以考虑，尤其是当参数可能会变多时，有可选参数时更是如此。</li></ul></li></ul><a id="more"></a><ul><li><p>Item 3: 单例模式！<br>不管以哪种形式实现单例模式，它们的核心原理都是将构造函数私有化，并且通过静态方法获取一个唯一的实例，在这个获取的过程中你必须保证线程安全、反序列化导致重新生成实例对象等问题，该模式简单，但使用率较高。</p><ul><li>double-check-locking<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> RestAdapter sRestAdapter = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RestAdapter <span class="title">provideRestAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RestProvider.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sRestAdapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sRestAdapter = <span class="keyword">new</span> RestAdapter();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sRestAdapter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>DCL可能会失效，因为指令重排可能导致同步解除后，对象初始化不完全就被其他线程获取；使用volatile关键字修饰对象，或者使用static SingletonHolder来避免该问题（后者JLS推荐）；</p><ul><li>class的static代码：一个类只有在被使用时才会初始化，而类初始化过程是非并行的，这些都由JLS能保证</li><li>用enum实现单例</li><li>还存在反射安全性问题：利用反射，可以访问私有方法，可通过加一个控制变量，该变量在getInstance函数中设置，如果不是从getInstance调用构造函数，则抛出异常；</li></ul></li><li>Item 4: 将构造函数私有化，使得不能从类外创建实例，同时也能禁止类被继承<br>util类可能不希望被实例化，有其需求</li><li>Item 5: 避免创建不必要的对象<ul><li>提高性能：创建对象需要时间、空间，“重量级”对象尤甚；immutable的对象也应该避免重复创建，例如String；</li><li>避免auto-boxing</li><li>但是因此而故意不创建必要的对象是错误的，使用object pool通常也是没必要的</li><li>lazy initialize也不是特别必要，除非使用场景很少且很重量级</li><li>Map#keySet方法，每次调用返回的是同一个Set对象，如果修改了返回的set，其他使用的代码可能会产生bug</li><li>需要defensive copying的时候，如果没有创建一个新对象，将导致很隐藏的Bug</li></ul></li><li>Item 6: 不再使用的对象一定要解除引用，避免memory leak<ul><li>例如，用数组实现一个栈，pop的时候，如果仅仅是移动下标，没有把pop出栈的数组位置引用解除，将发生内存泄漏</li><li>程序发生错误之后，应该尽快把错误抛出，而不是以错误的状态继续运行，否则可能导致更大的问题</li><li>通过把变量（引用）置为null不是最好的实现方式，只有在极端情况下才需要这样；好的办法是通过作用域来使得变量的引用过期，所以尽量缩小变量的作用域是很好的实践；注意，在Dalvik虚拟机中，存在一个细微的bug，可能会导致内存泄漏，<a href="MemoryLeak.md">详见</a></li><li>当一个类管理了一块内存，用于保存其他对象（数据）时，例如用数组实现的栈，底层通过一个数组来管理数据，但是数组的大小不等于有效数据的大小，GC器却并不知道这件事，所以这时候，需要对其管理的数据对象进行null解引用</li><li>当一个类管理了一块内存，用于保存其他对象（数据）时，程序员应该保持高度警惕，避免出现内存泄漏，一旦数据无效之后，需要立即解除引用</li><li>实现缓存的时候也很容易导致内存泄漏，放进缓存的对象一定要有换出机制，或者通过弱引用来进行引用</li><li>listner和callback也有可能导致内存泄漏，最好使用弱引用来进行引用，使得其可以被GC</li></ul></li><li>Item 7: 不要使用finalize方法<ul><li>finalize方法不同于C++的析构函数，不是用来释放资源的好地方</li><li>finalize方法执行并不及时，其执行线程优先级很低，而当对象unreachable之后，需要执行finalize方法之后才能释放，所以会导致对象生存周期变长，甚至根本不会释放</li><li>finalize方法的执行并不保证执行成功/完成</li><li>使用finalize时，性能会严重下降</li><li>finalize存在的意义<ul><li>充当“safety net”的角色，避免对象的使用者忘记调用显式termination方法，尽管finalize方法的执行时间没有保证，但是晚释放资源好过不释放资源；此处输出log警告有利于排查bug</li><li>用于释放native peer，但是当native peer持有必须要释放的资源时，应该定义显式termination方法</li></ul></li><li>子类finalize方法并不会自动调用父类finalize方法（和构造函数不同），为了避免子类不手动调用父类的finalize方法导致父类的资源未被释放，当需要使用finalize时，使用finalizer guardian比较好：<ul><li>定义一个私有的匿名Object子类对象，重写其finalize方法，在其中进行父类要做的工作</li><li>因为当父类对象被回收时，finalizer guardian也会被回收，它的finalize方法就一定会被触发</li></ul></li></ul></li></ul><!--more--><p>##Object的方法<br>尽管Object不是抽象类，但是其定义的非final方法设计的时候都是希望被重写的，finalize除外。</p><ul><li>Item 8: 当重写equals方法时，遵循其语义<ul><li>能不重写equals时就不要重写<ul><li>当对象表达的不是值，而是可变的状态时</li><li>对象不需要使用判等时</li><li>父类已重写，且满足子类语义</li></ul></li><li>当需要判等，且继承实现无法满足语义时，需要重写（通常是“value class”，或immutable对象）</li><li>当用作map的key时</li><li>重写equals时需要遵循的语义<ul><li>Reflexive（自反性）: x.equals(x)必须返回true（x不为null）</li><li>Symmetric（对称性）: x.equals(y) == y.equals(x)</li><li>Transitive（传递性）: x.equals(y) &amp;&amp; y.equals(z) ==&gt; x.equals(z)</li><li>Consistent（一致性）: 当对象未发生改变时，多次调用应该返回同一结果</li><li>x.equals(null)必须返回false</li></ul></li><li>实现建议<ul><li>先用==检查是否引用同一对象，提高性能</li><li>用instanceof再检查是否同一类型</li><li>再强制转换为正确的类型</li><li>再对各个域进行equals检查，遵循同样的规则</li><li>确认其语义正确，编写测例</li><li>重写equals时，同时也重写hashCode</li><li>！重写equals方法，传入的参数是Object</li></ul></li></ul></li><li>Item 9: 重写equals时也重写hashCode函数<ul><li>避免在基于hash的集合中使用时出错</li><li>语义<ul><li>一致性</li><li>当两个对象equals返回true时，hashCode方法的返回值也要相同</li></ul></li><li>hashCode的计算方式<ul><li>要求：equals的两个对象hashCode一样，但是不equals的对象hashCode不一样</li><li>取一个素数，例如17，result = 17</li><li>对每一个关心的field（在equals中参与判断的field），记为f，将其转换为一个int，记为c</li><li>boolean: f ? 1 : 0</li><li>byte/char/short/int: (int) f</li><li>long: (int) (f ^ (f &gt;&gt; 32))</li><li>float: Float.floatToIntBits(f)</li><li>double: Double.doubleToLongBits(f)，再按照long处理</li><li>Object: f == null ? 0 : f.hashCode()</li><li>array: 先计算每个元素的hashCode，再按照int处理</li><li>对每个field计算的c，result = 31 * result + c</li><li>返回result</li><li>编写测例</li></ul></li><li>计算hashCode时，不重要的field（未参与equals判断）不要参与计算</li></ul></li><li>Item 10: 重写toString()方法<ul><li>增加可读性，简洁、可读、具有信息量</li></ul></li><li>Item 11: 慎重重写clone方法<ul><li>Cloneable接口是一个mixin interface，用于表明一个对象可以被clone</li><li>Contract<ul><li>x.clone() != x</li><li>x.clone().getClass() == x.getClass()：要求太弱，当一个非final类重写clone方法的时候，创建的对象一定要通过super.clone()来获得，所有父类都遵循同样的原则，如此最终通过Object.clone()创建对象，能保证创建的是正确的类实例。而这一点很难保证。</li><li>x.clone().equals(x)</li><li>不调用构造函数：要求太强，一般都会在clone函数里面调用</li></ul></li><li>对于成员变量都是primitive type的类，直接调用super.clone()，然后cast为自己的类型即可（重写时允许返回被重写类返回类型的子类，便于使用方，不必每次cast）</li><li>成员变量包含对象（包括primitive type数组），可以通过递归调用成员的clone方法并赋值来实现</li><li>然而上述方式违背了final的使用协议，final成员不允许再次赋值，然而clone方法里面必须要对其赋值，则无法使用final保证不可变性了</li><li>递归调用成员的clone方法也会存在性能问题，对HashTable递归调用深拷贝也可能导致StackOverFlow（可以通过遍历添加来避免）</li><li>优雅的方式是通过super.clone()创建对象，然后为成员变量设置相同的值，而不是简单地递归调用成员的clone方法</li><li>和构造函数一样，在clone的过程中，不能调用non final的方法，如果调用虚函数，那么该函数会优先执行，而此时被clone的对象状态还未完成clone/construct，会导致corruption。因此上一条中提及的“设置相同的值”所调用的方法，要是final或者private。</li><li>重载类的clone方法可以省略异常表的定义，如果重写时把可见性改为public，则应该省略，便于使用；如果设计为应该被继承，则应该重写得和Object的一样，且不应该实现Cloneable接口；多线程问题也需要考虑；</li><li>要实现clone方法的类，都应该实现Cloneable接口，同时把clone方法可见性设为public，返回类型为自己，应该调用super.clone()来创建对象，然后手动设置每个域的值</li><li>clone方法太过复杂，如果不实现Cloneable接口，也可以通过别的方式实现copy功能，或者不提供copy功能，immutable提供copy功能是无意义的</li><li>提供拷贝构造函数，或者拷贝工厂方法，而且此种方法更加推荐，但也有其不足</li><li>设计用来被继承的类时，如果不实现一个正确高效的clone重写，那么其子类也将无法实现正确高效的clone功能</li></ul></li><li>Item 12: 当对象自然有序时，实现Comparable接口<ul><li>实现Comparable接口可以利用其有序性特点，提高集合使用/搜索/排序的性能</li><li>Contact<ul><li>sgn(x.compareTo(y)) == - sgn(y.compareTo(x))，当类型不对时，应该抛出ClassCastException，抛出异常的行为应该是一致的</li><li>transitive: x.compareTo(y) &gt; 0 &amp;&amp; y.compareTo(z) &gt; 0 ==&gt; x.compareTo(z) &gt; 0</li><li>x.compareTo(y) == 0 ==&gt; sgn(x.compareTo(z)) == sgn(y.compareTo(z))</li><li>建议，但非必须：与equals保持一致，即 x.compareTo(y) == 0 ==&gt; x.equals(y)，如果不一致，需要在文档中明确指出</li></ul></li><li>TreeSet, TreeMap等使用的就是有序保存，而HashSet, HashMap则是通过equals + hashCode保存</li><li>当要为一个实现了Comparable接口的类增加成员变量时，不要通过继承来实现，而是使用组合，并提供原有对象的访问方法，以保持对Contract的遵循</li><li>实现细节<ul><li>优先比较重要的域</li><li>谨慎使用返回差值的方式，有可能会溢出</li></ul></li></ul></li></ul><p>##Classes and Interfaces</p><ul><li>Item 13: 最小化类、成员的可见性<ul><li>封装（隐藏）：公开的接口需要暴露，而接口的实现则需要隐藏，使得接口与实现解耦，降低模块耦合度，增加可测试性、稳定性、可维护性、可优化性、可修改性</li><li>如果一个类只对一个类可见，则应该将其定义为私有的内部类，而没必要public的类都应该定义为package private</li><li>为了便于测试，可以适当放松可见性，但也只应该改为package private，不能更高</li><li>成员不能是非private的，尤其是可变的对象。一旦外部可访问，将失去对其内容的控制能力，而且会有多线程问题</li><li>暴露的常量也不能是可变的对象，否则public static final也将失去其意义，final成员无法改变其指向，但其指向的对象却是可变的（immutable的对象除外），长度非0的数组同样也是有问题的，可以考虑每次访问时创建拷贝，或者使用<code>Collections.unmodifiableList(Arrays.asList(arr))</code></li></ul></li><li>Item 14: public class中，使用accessor method而非public field<ul><li>后者外部可以直接访问，失去了安全性</li><li>package private或者private则可以不必这样</li><li>把immutable的field置为public勉强可以接受，mutable的成员一定不能置为public</li></ul></li><li>Item 15: 最小化可变性<ul><li>不提供可以改变本对象状态的方法</li><li>保证类不可被继承</li><li>使用final field</li><li>使用private field</li><li>在构造函数、accessor中，对mutable field使用defensive copy</li><li>实现建议<ul><li>操作函数，例如BigInteger的add方法，不是static的，但也不能改变本对象的状态，则使用functional的方式，返回一个新的对象，其状态是本对象修改之后的状态</li><li>如此实现的immutable对象生来就是线程安全的，无需同步操作，但应该鼓励共用实例，避免创建过多重复的对象</li><li>正确实现的immutable对象也不需要clone, copy方法；可以适当引入Object cache；</li></ul></li><li>劣势<ul><li>每一个值都需要一个对象，调用改变状态的方法而创建一个新的对象，尤其是它是重量级的，开销会变大；连续调用这样的方法，影响更大；</li><li>为常用的多次操作组合提供一个方法</li></ul></li><li>其他<ul><li>保证class无法被继承，除了声明为final外，还可以将默认构造函数声明为private或package private，然后提供public static工厂方法</li><li>使用public static工厂方法，具体实现类可以有多个，还能进行object cache</li><li>当实现Serializable接口是，一定要实现readObject/readResolve方法，或者使用ObjectOutputStream.writeUnshared/ObjectInputStream.readUnshared</li></ul></li><li>小结<ul><li>除非有很好的理由让一个Class mutable，否则应该使其immutable</li><li>如果非要mutable，也应尽可能限制其可变性</li></ul></li></ul></li><li>Item 16: Favor composition (and forwarding) over inheritance<ul><li>跨包继承、继承不是被设计为应该被继承的实现类，是一件很危险的事情，继承接口、继承抽象类，当然是没问题的</li><li>如果子类的功能依赖于父类的实现细节，那么一旦父类发生变化，子类将有可能出现Bug，即便代码都没有修改；而设计为应被继承的类，在修改后，是应该有文档说明的，子类开发者既可以得知，也可以知道如何修改</li><li>例子：统计HashSet添加元素的次数<ul><li>用继承方式，重写add，addAll，在其中计数，这就不对，因为HashSet内部的addAll是通过调用add实现的</li><li>但是通过不重写addAll也只不对的，以后有可能HashSet的实现就变了</li><li>在重写中重新实现一遍父类的逻辑也是行不通的，因为这可能会导致性能问题、bug等，而且有些功能不访问私有成员也是无法实现的</li><li>还有一个原因就是父类的实现中，可能会增加方法，改变其行为，而这一点，在子类中是无法控制的</li></ul></li><li>而通过组合的方式，将不会有这些问题，把另一个类的对象声明为私有成员，外部将无法访问它，自己也能在转发（forwarding）过程中执行拦截操作，也不必依赖其实现细节，这种组合、转发的实现被称为wrapper，或者Decorator pattern，或者delegation（严格来说不是代理，代理一般wrapper对象都需要把自己传入到被wrap的对象方法中？）</li><li>缺点<ul><li>不适用于callback frameworks？</li></ul></li><li>继承应该在is-a的场景中使用</li><li>继承除了会继承父类的API功能，也会继承父类的设计缺陷，而组合则可以隐藏成员类的设计缺陷</li></ul></li><li>Item 17: Design and document for inheritance or else prohibit it<ul><li>一个类必须在文档中说明，每个可重写的方法，在该类的实现中的哪些地方会被调用（the class must document its self-use of overridable methods）。调用时机、顺序、结果产生的影响，包括多线程、初始化等情况。</li><li>被继承类应该通过谨慎选择protected的方法或成员，来提供一些hook，用于改变其内部的行为，例如java.util.AbstractList::removeRange。</li><li>The only way to test a class designed for inheritance is to write subclasses. 用于判断是否需要增加或者减少protected成员/方法，通常写3个子类就差不多了。</li><li>You must test your class by writing subclasses before you release it.</li><li>Constructors must not invoke overridable methods. 父类的构造函数比子类的构造函数先执行，而如果父类构造函数中调用了可重写的方法，那么就会导致子类的重写方法比子类的构造函数先执行，会导致corruption。</li><li>如果实现了Serializable/Cloneable接口，neither clone nor readObject may invoke an overridable method, directly or indirectly. 重写方法会在deserialized/fix the clone’s state之前执行。</li><li>如果实现了Serializable接口，readResolve/writeReplace必须是protected，而非private</li><li>designing a class for inheritance places substantial limitations on the class.</li><li>The best solution to this problem is to prohibit subclassing in classes that are not designed and documented to be safely subclassed. 声明为final class或者把构造函数私有化（提供public static工厂方法）。</li><li>如果确实想要允许继承，就应该为每个被自己使用的可重写方法都写好文档</li></ul></li><li>Item 18: Prefer interfaces to abstract classes<ul><li>Java类只允许单继承，接口可以多继承，使用接口定义类型，使得class hierarchy更加灵活</li><li>定义mixin（optional functionality to be “mixed in”）时使用interface是很方便的，需要增加此功能的类只需要implement该接口即可，而如果使用抽象类，则无法增加一个extends语句</li><li>接口允许构建没有hierarchy的类型系统</li><li>使用接口定义类型，可以使得item 16中提到的wrapper模式更加安全、强大，</li><li>skeletal implementation：该类为abstract，把必须由client实现的方法设为abstract，可以有默认实现的则提供默认实现</li><li>simulated multiple inheritance：通过实现定义的接口，同时在内部实现一个匿名的skeletal implementation，将对对该接口的调用转发到匿名类中，起到“多继承”的效果</li><li>simple implementation：提供一个非抽象的接口实现类，提供一个最简单、能work的实现，也允许被继承</li><li>使用接口定义类型的缺点：不便于演进，一旦接口发布，如果想要增加功能（增加方法），则client将无法编译；而使用abstract class，则没有此问题，只需要提供默认实现即可</li><li>小结<ul><li>通过接口定义类型，可以允许多实现（多继承）</li><li>但是演进需求大于灵活性、功能性时，抽象类更合适</li><li>提供接口时，提供一个skeletal implementation，同时审慎考虑接口设计</li></ul></li></ul></li><li>Item 19: 仅仅用interface去定义一个类型，该接口应该有实现类，使用者通过接口引用，去调用接口的方法<ul><li>避免用接口去定义常量，应该用noninstantiable utility class去定义常量</li><li>相关常量的命名，通过公共前缀来实现分组</li></ul></li><li>Item 20: Prefer class hierarchies to tagged classes<ul><li>tagged class: 在内部定义一个tag变量，由其控制功能的转换</li><li>tag classes are verbose, error-prone, and inefficient</li><li>而class hierarchy，不同功能由不同子类实现，公共部分抽象为一个基类，也能反映出各个子类之间的关系</li></ul></li><li>Item 21: Use function objects to represent strategies<ul><li>只提供一个功能函数的类实例，没有成员变量，只需一个对象（单例），为其功能定义一个接口，则可以实现策略模式，把具体策略传入相应函数中，使用策略</li><li>具体的策略实例通常使用匿名类定义，调用使用该策略的方法时才予以创建/预先创建好之后每次将其传入</li></ul></li><li>Item 22: Favor static member classes over nonstatic<ul><li>有4种nested class：non-static member class; static member class(inner class); anonymous class; local class</li><li>static member class<ul><li>经常作为helper class，和外部类一起使用</li><li>如果nested class的生命周期独立于外部类存在，则必须定义为static member class，否则可能造成内存泄漏</li><li>private static member class用处一：表示（封装）外部类的一些成员，例如Map的Entry内部类。</li></ul></li><li>non-static member class<ul><li>将持有外部类实例的强引用，可以直接引用外部类的成员和方法</li><li>用处一：定义一个Adapter，使得外部内的实例，可以作为和外部类语义不同的实例来查看（访问），例如Collection的Iterator。</li><li>如果nested class不需要引用外部类的成员和方法，则一定要将其定义为static，避免空间/时间开销，避免内存泄漏</li></ul></li><li>anonymous class<ul><li>当在非static代码块内定义时，会持有外部类的引用，否则不会持有</li><li>限制</li><li>只能在被声明的地方进行实例化</li><li>无法进行instanceof测试</li><li>不能用匿名类实现多个接口</li><li>不能用匿名类继承一个类的同时实现接口</li><li>匿名类中新添加的方法无法在匿名类外部访问</li><li>不能有static成员</li><li>应该尽量保持简短</li><li>用处一：创建function object</li><li>用处二：创建process object，例如：Runnable, Thread, TimberTask</li><li>用处三：用于public static工厂方法，例如Collections类里面的一些工厂方法，很多是返回一个匿名的内部实现</li></ul></li><li>local class<ul><li>比较少用</li><li>是否static取决于其定义的上下文</li><li>可以在作用域内重复使用</li><li>不能有static成员</li><li>也应尽量保持简短</li></ul></li><li>小结<ul><li>四种nested class</li><li>如果nested class在整个外部类内都需要可见，或者定义代码太长，应使用member class</li><li>能static就一定要static，即便需要对外部类进行引用，对于生命周期独立于外部类的，也应该通过WeakReference进行引用，避免内存泄漏；至于生命周期和外部类一致的，则不必这样</li></ul></li></ul></li></ul><h2 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h2><ul><li><p>Item 23: Don’t use raw types in new code</p><ul><li>Java泛型，例如<code>List&lt;E&gt;</code>，真正使用的时候都是<code>List&lt;String&gt;</code>等，把E替换为实际的类型</li><li>Java泛型从1.5引入，为了保持兼容性，实现的是伪泛型，类型参数信息在编译完成之后都会被擦除，其在运行时的类型都是raw type，类型参数保存的都是Object类型，<code>List&lt;E&gt;</code>的raw type就是<code>List</code></li><li>编译器在编译期通过类型参数，为读操作自动进行了类型强制转换，同时在写操作时自动进行了类型检查</li><li>如果使用raw type，那编译器就不会在写操作时进行类型检查了，写入错误的类型也不会报编译错误，那么在后续读操作进行强制类型转换时，将会导致转换失败，抛出异常</li><li>一旦错误发生，应该让它尽早被知道（抛出/捕获），编译期显然优于运行期</li><li><p><code>List</code>与<code>List&lt;Object&gt;</code>的区别</p><ul><li>前者不具备类型安全性，后者具备，例如以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Uses raw type (List) - fails at runtime!</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  unsafeAdd(strings, <span class="keyword">new</span> Integer(<span class="number">42</span>));</span><br><span class="line">  String s = strings.get(<span class="number">0</span>); <span class="comment">// Compiler-generated cast</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unsafeAdd</span><span class="params">(List list, Object o)</span> </span>&#123;</span><br><span class="line">  list.add(o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>不会报编译错误，但会给一个编译警告：<code>Test.java:10: warning: unchecked call to add(E) in raw type List list.add(o);</code>，而运行时则会发生错误。</p><ul><li>但如果使用<code>List&lt;Object&gt;</code>，即<code>unsageAdd</code>参数改为<code>List&lt;Object&gt; list, Object o</code>，则会报编译错误：<code>Test.java:5: unsafeAdd(List&lt;Object&gt;,Object) cannot be applied to (List&lt;String&gt;,Integer) unsafeAdd(strings, new Integer(42));</code></li><li>因为<code>List&lt;String&gt;</code>是<code>List</code>的子类，但却不是<code>List&lt;Object&gt;</code>的子类。</li><li>并不是说这个场景应该使用<code>List&lt;Object&gt;</code>，这个场景应该使用<code>List&lt;String&gt;</code>，这里只是为了说明<code>List</code>和<code>List&lt;Object&gt;</code>是有区别的。</li></ul></li><li><p><code>List</code> v.s. <code>List&lt;?&gt;</code>（unbounded wildcard types），当不确定类型参数，或者说类型参数不重要时，也不应该使用raw type，而应该使用<code>List&lt;?&gt;</code></p><ul><li><p>任何参数化的List均是<code>List&lt;?&gt;</code>的子类，可以作为参数传入接受<code>List&lt;?&gt;</code>的函数，例如以下代码均是合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(List&lt;?&gt; list)</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func(<span class="keyword">new</span> List&lt;Object&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;Integer&gt;());</span><br><span class="line">func(<span class="keyword">new</span> List&lt;String&gt;());</span><br></pre></td></tr></table></figure></li><li><p>持有<code>List&lt;?&gt;</code>的引用后，并不能向其中加入任何元素，读取出来的元素也是<code>Object</code>类型，而不会被自动强转为任何类型。</p></li><li>如果<code>List&lt;?&gt;</code>的行为不能满足需求，可以考虑使用模板方法，或者<code>List&lt;E extends XXX&gt;</code>（bounded wildcard types）</li></ul></li><li>You must use raw types in class literals.<ul><li><code>List.class</code>, <code>String[].class</code>, and <code>int.class</code> are all legal, but <code>List&lt;String&gt;.class</code> and <code>List&lt;?&gt;.class</code> are not.</li></ul></li><li><p><code>instanceof</code>不支持泛型，以下用法是推荐的，但不应该将<code>o</code>强转为<code>List</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Legitimate use of raw type - instanceof operator</span></span><br><span class="line"><span class="keyword">if</span> (o <span class="keyword">instanceof</span> Set) &#123; <span class="comment">// Raw type</span></span><br><span class="line">  Set&lt;?&gt; m = (Set&lt;?&gt;) o; <span class="comment">// Wildcard type</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>相关术语汇总<br><img src="assets/java_generic_terms.png" alt="java_generic_terms.png"></p></li></ul></li><li>Item 24: Eliminate unchecked warnings<ul><li>当出现类型不安全的强制转换时（一般都是涉及泛型，raw type），编译器会给出警告，首先要做的是尽量消除不安全的转换，消除警告</li><li>实在无法消除/确定不会导致运行时的<code>ClassCastException</code>，可以通过<code>@SuppressWarnings(&quot;unchecked&quot;)</code>消除警告，但不要直接忽略该警告</li><li>使用<code>@SuppressWarnings(&quot;unchecked&quot;)</code>时，应该在注视内证明确实不存在运行时的<code>ClassCastException</code>；同时应该尽量减小其作用的范围，通常是应该为一个赋值语句添加注解</li></ul></li><li><p>Item 25: Prefer lists to arrays</p><ul><li>arrays are covariant(协变): 如果<code>Sub</code>是<code>Super</code>的子类，那么<code>Sub[]</code>也是<code>Super[]</code>的子类</li><li>generics are invariant(不变): 任意两个不同的类<code>Type1</code>和<code>Type2</code>，<code>List&lt;Type1&gt;</code>和<code>List&lt;Type2&gt;</code>之间没有任何继承关系</li><li><p>考虑以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Fails at runtime!</span></span><br><span class="line">Object[] objectArray = <span class="keyword">new</span> Long[<span class="number">1</span>];</span><br><span class="line">objectArray[<span class="number">0</span>] = <span class="string">"I don't fit in"</span>; <span class="comment">// Throws ArrayStoreException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Won't compile!</span></span><br><span class="line">List&lt;Object&gt; ol = <span class="keyword">new</span> ArrayList&lt;Long&gt;(); <span class="comment">// Incompatible types</span></span><br><span class="line">ol.add(<span class="string">"I don't fit in"</span>);</span><br></pre></td></tr></table></figure></li><li><p>arrays are reified(具体化): array在运行时能知道且强制要求元素的类型</p></li><li>generics are implemented by erasure(non-reifiable): 仅仅在编译时知道元素的类型</li><li>数组和泛型同时使用时会受到很大限制<ul><li>以下语句均不能通过编译：<code>new List&lt;E&gt;[], new List&lt;String&gt;[], new E[]</code>；但是声明是可以的，例如<code>List&lt;String&gt;[] stringLists</code></li></ul></li><li>non-reifiable type: 例如<code>E, List&lt;E&gt;, List&lt;String&gt;</code>，这些类型在运行时的信息比编译时的信息更少</li><li>只有unbounded wildcard type才是reifiable的，如：<code>List&lt;?&gt;, Map&lt;?, ?&gt;</code></li><li>常规来说，不能返回泛型元素的数组，因为会报编译错误：<code>generic array creation errors</code></li><li>当泛型和<code>varargs</code>一起使用时，也会导致编译警告</li><li>有时为了类型安全，不得不做些妥协，牺牲性能和简洁，使用List而不是数组</li><li>把数组强转为non-reifiable类型是非常危险的，仅应在非常确定类型安全的情况下使用</li></ul></li><li>Item 26: Favor generic types<ul><li>当需要一个类成员的数据类型具备一般性时，应该用泛型，这也正是泛型的设计场景之一，不应该用Object类</li><li>但使用泛型有时也不得不进行cast，例如当泛型遇上数组</li><li>总的来说把suppress数组类型强转的unchecked warning比suppress一个标量类型强转的unchecked warning风险更大，但有时出于代码简洁性考虑，也不得不做出妥协</li><li>有时看似与item 25矛盾，实属无奈，Java原生没有List，ArrayList不得不基于数组实现，HashMap也是基于数组实现的</li><li>泛型比使用者进行cast更加安全，而且由于Java泛型的擦除实现，也可以和未做泛型的老代码无缝兼容</li></ul></li><li><p>Item 27: Favor generic methods</p><ul><li><p>泛型方法的类型参数在函数修饰符（可见性/static/final等）和返回值之间，例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generic method</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;E&gt; s1, Set&lt;E&gt; s2)</span> </span>&#123;</span><br><span class="line">    Set&lt;E&gt; result = <span class="keyword">new</span> HashSet&lt;&gt;(s1);</span><br><span class="line">    result.addAll(s2);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>recursive type bound</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Using a recursive type bound to express mutual comparability</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function">T <span class="title">max</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure></li><li><p>泛型方法要比方法使用者进行cast更加安全</p></li></ul></li><li><p>Item 28: Use bounded wildcards to increase API flexibility</p><ul><li>考虑以下代码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushAll</span><span class="params">(Iterable&lt;E&gt; src)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">popAll</span><span class="params">(Collection&lt;E&gt; dst)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Iterable&lt;Integer&gt; integers = ... ;</span><br><span class="line">numberStack.pushAll(integers);</span><br><span class="line"></span><br><span class="line">Stack&lt;Number&gt; numberStack = <span class="keyword">new</span> Stack&lt;Number&gt;();</span><br><span class="line">Collection&lt;Object&gt; objects = ... ;</span><br><span class="line">numberStack.popAll(objects);</span><br></pre></td></tr></table></figure></li></ul><p>pushAll和popAll的调用均无法通过编译，因为尽管<code>Integer</code>是<code>Number</code>的子类，但<code>Iterable&lt;Integer&gt;</code>不是<code>Iterable&lt;Number&gt;</code>的子类，这是由泛型的invariant特性导致的，所以<code>Iterable&lt;Integer&gt;</code>不能传入接受<code>Iterable&lt;Number&gt;</code>参数的函数，popAll的使用同理</p><ul><li>bounded wildcards: <code>&lt;? extends E&gt;</code>, <code>&lt;? super E&gt;</code>, PECS stands for producer-extends, consumer-super. 如果传入的参数是要输入给该类型数据的，则应该使用extends，如果是要容纳该类型数据的输出，则应该使用super</li><li>这很好理解，作为输入是要赋值给E类型的，当然应该是E的子类（这里的extends包括E类型本身）；而容纳输出是要把E赋值给传入参数的，当然应该是E的父类（同样包括E本身）</li><li>返回值类型不要使用bounded wildcards，否则使用者也需要使用，这将会给使用者造成麻烦</li><li>代码对于bounded wildcards的使用在使用者那边应该是透明的，即他们不会感知到bounded wildcards的存在，如果他们也需要考虑bounded wildcards的问题，则说明对bounded wildcards的使用有问题了</li><li><p>有时候编译器的类型推导在遇到bounded wildcards会无法完成，这时就需要显示指定类型信息，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function">Set&lt;E&gt; <span class="title">union</span><span class="params">(Set&lt;? extends E&gt; s1, Set&lt;? extends E&gt; s2)</span></span>;</span><br><span class="line"></span><br><span class="line">Set&lt;Integer&gt; integers = ... ;</span><br><span class="line">Set&lt;Double&gt; doubles = ... ;</span><br><span class="line"><span class="comment">//Set&lt;Number&gt; numbers = union(integers, doubles); //compile error</span></span><br><span class="line">Set&lt;Number&gt; numbers = Union.&lt;Number&gt;union(integers, doubles);  <span class="comment">//compile pass</span></span><br></pre></td></tr></table></figure></li><li><p>Comparables are always consumers, so you should always use <code>Comparable&lt;? super T&gt;</code> in preference to <code>Comparable&lt;T&gt;</code>. The same is true of comparators, so you should always use <code>Comparator&lt;? super T&gt;</code> in preference to <code>Comparator&lt;T&gt;</code>.</p></li><li>unbounded type parameter(<code>&lt;E&gt; ... List&lt;E&gt;</code>) v.s. unbounded wildcard(<code>List&lt;?&gt;</code>)：if a type parameter appears only once in a method declaration, replace it with a wildcard.</li></ul></li><li><p>Item 29: Consider typesafe heterogeneous containers</p><ul><li>使用泛型时，类型参数是有限个的，例如<code>List&lt;T&gt;</code>，<code>Map&lt;K, V&gt;</code>，但有时可能需要一个容器，能放入任意类型的对象，但需要具备类型安全性，例如数据库的一行，它的每一列都可能是任意类型的数据</li><li><p>由于<code>Class</code>类从1.5就被泛型化了，所以使得这种需求可以实现，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - API</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span></span>;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通常这样使用的<code>Class</code>对象被称为type token，它传入函数，用来表述编译时和运行时的类型信息</p></li><li><p><code>Favorites</code>的实现也是很简单的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Typesafe heterogeneous container pattern - implementation</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Favorites</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Object&gt; favorites = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Type is null"</span>);</span><br><span class="line">        favorites.put(type, instance);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getFavorite</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type.cast(favorites.get(type));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>注意，这里的unbound wildcard并不是应用于Map的，而是应用于Class的类型参数，因此Map可以put key进去，而且key可以是任意类型参数的Class对象</p></li><li>另外，Map的value类型是Object，一旦put到Map中去，其编译期类型信息就丢失了，将通过get方法的动态类型转换（cast）来重新获得其类型信息</li><li>cast方法将检查类型信息，如果是该类型（或其子类），转换将成功，并返回引用，否则将抛出ClassCastException</li><li><p>这一heterogeneous container实现有两个不足</p><ul><li>通过为put方法传入Class的raw type，使用者可以很轻易地破坏类型安全性，解决方案也很简单，在put时也进行一下cast：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Achieving runtime type safety with a dynamic cast</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">putFavorite</span><span class="params">(Class&lt;T&gt; type, T instance)</span> </span>&#123;</span><br><span class="line">    favorites.put(type, type.cast(instance));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这样做的效果是使得想要破坏类型安全性的put使用者产生异常，而使用get的使用者则不会因为恶意put使用者产生异常。这种做法也被<code>java.util.Collections</code>包中的一些方法使用，例如命名为checkedSet, checkedList, checkedMap的类。</p><ul><li>这个容器内不能放入non-reifiable的类型，例如<code>List&lt;String&gt;</code>，因为<code>List&lt;String&gt;.class</code>是有语法错误的，<code>List&lt;String&gt;</code>, <code>List&lt;Integer&gt;</code>都只有同一个class对象：<code>List.class</code>；另外<code>String[].class</code>是合法的。</li></ul></li><li><code>Favorites</code>使用的类型参数是unbounded的，可以put任意类型，也可以使用bounded type token，使用bounded时可能需要把<code>Class&lt;?&gt;</code>转换为<code>Class&lt;? extends Annotation&gt;</code>，直接用<code>class.cast</code>将会导致unchecked warning，可以通过<code>class.asSubclass</code>来进行转换，例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Use of asSubclass to safely cast to a bounded type token</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> Annotation <span class="title">getAnnotation</span><span class="params">(AnnotatedElement element, String annotationTypeName)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; annotationType = <span class="keyword">null</span>; <span class="comment">// Unbounded type token</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        annotationType = Class.forName(annotationTypeName);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> element.getAnnotation(annotationType.asSubclass(Annotation.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>##Enums and Annotations</p><ul><li><p>Item 30: Use enums instead of int constants</p><ul><li>类型安全</li><li>可以为常量提供数据和方法的绑定</li><li>可以遍历</li><li><p>实现建议</p><ul><li>如果是通用的，应该定义为top level enum，否则应定义为内部类</li><li><p>constant-specific method implementations</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific method implementations</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS   &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x + y;&#125; &#125;,</span><br><span class="line">    MINUS  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x - y;&#125; &#125;,</span><br><span class="line">    TIMES  &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x * y;&#125; &#125;,</span><br><span class="line">    DIVIDE &#123; <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>&#123;<span class="keyword">return</span> x / y;&#125; &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>结合constant-specific data</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Enum type with constant-specific class bodies and data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Operation &#123;</span><br><span class="line">    PLUS(<span class="string">"+"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    MINUS(<span class="string">"-"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x - y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    TIMES(<span class="string">"*"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x * y; &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    DIVIDE(<span class="string">"/"</span>) &#123;</span><br><span class="line">        <span class="function"><span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span> </span>&#123; <span class="keyword">return</span> x / y; &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String symbol;</span><br><span class="line">    Operation(String symbol) &#123; <span class="keyword">this</span>.symbol = symbol; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> symbol; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">apply</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>If switch statements on enums are not a good choice for implementing con- stant-specific behavior on enums, what are they good for? Switches on enums are good for augmenting external enum types with constant-specific behavior.</p></li></ul></li><li>A minor performance disadvantage of enums over int constants is that there is a space and time cost to load and initialize enum types.</li><li>所以，在安卓设备（手机、平板）上，应该避免使用enum，减小空间和时间的开销</li></ul></li><li>Item 31: Use instance fields instead of ordinals<ul><li>每个enum的常量都有一个<code>ordinal()</code>方法获取其在该enum类型中的位置，但该方法只应该在实现<code>EnumSet</code>, <code>EnumMap</code>等类型的时候被使用，其他情形都不应该被使用</li><li>如果需要为每一个常量绑定一个数据，可以使用instance field实现，如果需要绑定方法，则可以用constant-specific method implementations，参考上一个item</li></ul></li><li>Item 32: Use EnumSet instead of bit fields<ul><li>bit fields的方式不优雅、容易出错、没有类型安全性</li><li>EnumSet则没有这些缺点，而且对于大多数enum类型来说，其性能都和bit field相当</li><li>通用建议：声明变量时，不要用实现类型，应该用接口类型，例如，应该用<code>List&lt;Integer&gt;</code>而不是<code>ArrayList&lt;Integer&gt;</code></li><li>EnumSet并非immutable的，可以通过<code>Conllections.unmodifiableSet</code>来封装为immutable，但是代码简洁性与性能都将受到影响</li></ul></li></ul></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">------本文结束<i class="fa fa-paw"></i>感谢阅读------</div></div></div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者： </strong>windylee</li><li class="post-copyright-link"><strong>本文链接：</strong> <a href="http://windylee.cn/posts/636894a/" title="effictive-java读书笔记">http://windylee.cn/posts/636894a/</a></li><li class="post-copyright-license"><strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"><i class="fa fa-tag"></i> Java</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/c2f6f9e3/" rel="next" title="MongoDb索引"><i class="fa fa-chevron-left"></i> MongoDb索引</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/posts/b5a2dc36/" rel="prev" title="Java8新的时间日期库">Java8新的时间日期库 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="gitment-container"></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="http://windylee-blog.oss-cn-beijing.aliyuncs.com/4a80bfd22936342467d9b2d9f19a8a1f.jpeg" alt="windylee"><p class="site-author-name" itemprop="name">windylee</p><p class="site-description motion-element" itemprop="description">Stay hungry, stay foolish</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">19</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">9</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">12</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/liwangadd" title="GitHub &rarr; https://github.com/liwangadd" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="/liwangadd@gmail.com" title="E-Mail &rarr; liwangadd@gmail.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Effective-Java一书笔记"><span class="nav-number">1.</span> <span class="nav-text">Effective Java一书笔记</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#对象的创建与销毁"><span class="nav-number">1.1.</span> <span class="nav-text">对象的创建与销毁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Generics"><span class="nav-number">1.2.</span> <span class="nav-text">Generics</span></a></li></ol></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><div class="copyright">&copy; 2015 – <span itemprop="copyrightYear">2018</span> <span class="with-love" id="animate"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">windylee</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span class="post-meta-item-text">站点总字数：</span> <span title="站点总字数">139k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span class="post-meta-item-text">站点阅读时长 &asymp;</span> <span title="站点阅读时长">2:06</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span id="scrollpercent"><span>0</span>%</span></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=6.6.0"></script><script src="/js/src/motion.js?v=6.6.0"></script><script src="/js/src/affix.js?v=6.6.0"></script><script src="/js/src/schemes/pisces.js?v=6.6.0"></script><script src="/js/src/scrollspy.js?v=6.6.0"></script><script src="/js/src/post-details.js?v=6.6.0"></script><script src="/js/src/bootstrap.js?v=6.6.0"></script><link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css"><script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script><script>function renderGitment(){new Gitmint({id:window.location.pathname,owner:"liwangadd",repo:"liwangadd.github.io",lang:navigator.language||navigator.systemLanguage||navigator.userLanguage,oauth:{client_secret:"f640ba05fb087b6fb07b06c1f14925e585efb621",client_id:"c490cd479a8b45168d6a"}}).render("gitment-container")}renderGitment()</script><script>// Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });</script><style>.copy-btn{display:inline-block;padding:6px 12px;font-size:13px;font-weight:700;line-height:20px;color:#333;white-space:nowrap;vertical-align:middle;cursor:pointer;background-color:#eee;background-image:linear-gradient(#fcfcfc,#eee);border:1px solid #d5d5d5;border-radius:3px;user-select:none;outline:0}.highlight-wrap .copy-btn{transition:opacity .3s ease-in-out;opacity:0;padding:2px 6px;position:absolute;right:4px;top:8px}.highlight-wrap .copy-btn:focus,.highlight-wrap:hover .copy-btn{opacity:1}.highlight-wrap{position:relative}</style><script>$(".highlight").each(function(e,t){var n=$("<div>").addClass("highlight-wrap");$(t).after(n),n.append($("<button>").addClass("copy-btn").append("复制").on("click",function(e){var t=$(this).parent().find(".code").find(".line").map(function(e,t){return $(t).text()}).toArray().join("\n"),n=document.createElement("textarea"),o=document.createRange(),a=window.getSelection(),i=window.pageYOffset||document.documentElement.scrollTop;n.style.top=i+"px",n.style.position="absolute",n.style.opacity="0",n.value=t,n.textContent=t,n.contentEditable=!0,n.readOnly=!1,document.body.appendChild(n),o.selectNode(n),a.removeAllRanges(),a.addRange(o),n.setSelectionRange(0,t.length),document.execCommand("copy")?$(this).text("复制成功"):$(this).text("复制失败"),n.blur(),$(this).blur()})).on("mouseleave",function(e){var t=$(this).find(".copy-btn");setTimeout(function(){t.text("复制")},300)}).append(t)})</script></body></html>